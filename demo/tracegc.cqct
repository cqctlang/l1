@include <ctlmux.cqct>

l1 = "../../l1/l1";
l1names = l1+".names";
dom = nil;

@define car(p)  { (((`Pair*)p)->car); }
@define cdr(p)  { (((`Pair*)p)->cdr); }
@define caar(p) { (car(car(p))); }
@define cadr(p) { (car(cdr(p))); }
@define cdar(p) { (cdr(car(p))); }
@define cddr(p) { (cdr(cdr(p))); }

@define phash(p)
{
	@local key;
	key = (`uint64)p;
	key = (~key) + (key << 18);
	key = key ^ (key >> 31);
	key = key * 21;
	key = key ^ (key >> 11);
	key = key + (key << 6);
	key = key ^ (key >> 22);
	return (`uint32)key;
}

@define hgetp(ht, k)
{
	@local hp;
	hp = ht->ht[phash(k)%ht->sz];
	while(hp){
		if(hp->key == k)
			return hp->val;
		hp = hp->next;
	}
	return 0;
}

@define lookseg(a)
{
	v = (dom`uintptr_t)a;
	v &= dom`Segmask;
	s = hgetp(dom`segtab, (void*)v);
	if(s == 0)
		error("lookseg bug");
	return (`Seg*)s;
}

@define fmtseg(s)
{
	return sprintfa("seg %p %e gen %d %p-%p",
		       s, s->kind, s->gen, s->addr, s->e);
}
@define trace0(dom)
{
	@local H, o, s, p, i, m, qs;
	H = &dom`H;
	qs = dom`qs;
	for(i = 0; i < dom`Ngen; i++){
		p = (`Head*)H->gd[i];
		m = 0;
		while(p){
			m++;
//			o = caar(p);
//			s = lookseg(o);
//			printf("\t%s\n", fmtseg(s));
			p = cdr(p);
		}
		printf("gd[%d]: %d guarded objects\n", i, m);
	}
	p = (`Head*)H->gd[2];
	if(!p)
		return;
	printf("guarded at generation 2:\n");
	while(p){
		o = caar(p);
		s = lookseg(o);
		printf("\t%p in %s\n", o, fmtseg(s));
		p = cdr(p);
	}
}

@define trace1(dom)
{
	@local H, o, s, p, i, m, qs;
	H = &dom`H;
	s = H->data[0].h;
	while(s){
		printf("\t%s\n", fmtseg(s));		
		s = s->link;
	}
}

@define doit(args)
{
	@local mux, ns, as, e, nexec;

	nexec = 0;
	npop = 0;
	e = sprintfa("@names clp64le { @include \"%s\" };", l1names);
	ns = eval(e);
	mux = mkctlmux_local();
	push(args, l1);
	ctl = mux.launch(args, 0);
	as = ctl.mem();
	dom = mkdom(ns, as);
	dom.xtrap(&dom`gc,
		  @lambda(ctl){
			  printf("enter gc\n");
			  trace0(dom);
			  return nil;
		  });
	dom.xcont();
	mux.run();
}

doit([ "/tmp/x" ]);
