@include <ctlmux.cqct>

l1 = "../../l1/l1";
l1names = l1+".names";
ns = nil;
dom = nil;

@define car(p)  { (((`Pair*)p)->car); }
@define cdr(p)  { (((`Pair*)p)->cdr); }
@define caar(p) { (car(car(p))); }
@define cadr(p) { (car(cdr(p))); }
@define cdar(p) { (cdr(car(p))); }
@define cddr(p) { (cdr(cdr(p))); }

@define Vfwd(p)		{ ((((p)->bits)>>dom`Vfwdoff)&dom`Vfwdmask); }
@define Vfwdaddr(p)
{
	return {domof(p)}((void*)((p)->bits & ~(dom`Vfwdmask<<dom`Vfwdoff)));
}
@define Vkind(p)        { ((((p)->bits)>>dom`Vkindoff)&dom`Vkindmask); }
@define Vprot(p)        { ((((p)->bits)>>dom`Vprotoff)&dom`Vprotmask); }
@define Vdead(p)        { ((((p)->bits)>>dom`Vdeadoff)&dom`Vdeadmask); }

@define phash(p)
{
	@local key;
	key = (`uint64)p;
	key = (~key) + (key << 18);
	key = key ^ (key >> 31);
	key = key * 21;
	key = key ^ (key >> 11);
	key = key + (key << 6);
	key = key ^ (key >> 22);
	return (`uint32)key;
}

@define hgetp(ht, k)
{
	@local hp;
	hp = ht->ht[phash(k)%ht->sz];
	while(hp){
		if(hp->key == k)
			return hp->val;
		hp = hp->next;
	}
	return 0;
}

@define dumpht(ht)
{
	@local i, hp;
	for(i = 0; i < ht->sz; i++){
		hp = ht->ht[i];
		while(hp){
			printf("\thash %5x key %p val %s\n", i, hp->key,
			       fmtseg((`Seg*)hp->val));
			hp = hp->next;
		}
	}
}

@define dumpprot(dom)
{
	@local H, s;
	H = &dom`H;
	s = H->prot.h;
	printf("protected segments:\n");
	while(s){
		printf("\t%s\n", fmtseg(s));
		s = s->link;
	}
}


@define lookseg(a)
{
	v = (dom`uintptr_t)a;
	v &= dom`Segmask;
	s = hgetp(dom`segtab, (void*)v);
	if(s == 0)
		return 0;
	return (`Seg*)s;
}

@define fmtseg(s)
{
	@local r;
	if(s == 0)
		return "no segment!";
	r = sprintfa("seg %p %e %e", s, s->kind, s->gen);
	if(s->gen == dom`Gprot)
		r += sprintfa("(%u)", s->nprotect);
	r += sprintfa(" %p-%p", s->addr, s->e);
}

@define fmthd(h)
{
	@local s;
	if(h == 0)
		return "(null)";
	h = (`Head*)h;
	if(Vfwd(h))
		return sprintfa("obj %p -> %s", h, fmthd(Vfwdaddr(h)));
	if(Vdead(h))
		return sprintfa("obj %p [dead]", h);
	s = sprintfa("obj %p (%s)", h, dom`qs[Vkind(h)].id);
	if(Vprot(h))
		s += " protected";
	return s;
}

@define trace0(dom)
{
	@local H, o, s, p, i, m, qs, o, g;
	H = &dom`H;
	qs = dom`qs;
	for(i = 0; i < dom`Ngen; i++){
		p = (`Head*)H->gd[i];
		printf("%e guarded objects:\n", (dom`Gen)i);
		m = 0;
		while(p){
			m++;
			o = caar(p);
			g = cdar(p);
			if(o == 0x7ffff7ff4940){
				printf("%s", fmthd(o));
				printf(" in %s\n", fmtseg(lookseg(o)));
			}
			p = cdr(p);
		}
	}
	p = (`Head*)H->gd[2];
	if(!p)
		return;
	printf("guarded at generation 2:\n");
	while(p){
		o = caar(p);
		s = lookseg(o);
		printf("\t%p in %s\n", o, fmtseg(s));
		p = cdr(p);
	}
}

@define oldconfig(dom)
{
if(0)	dom.xtrap(&dom`hputp,
		  @lambda(ctl){
			  @local pd, tab, k, v, regs;
			  regs = ctl.reg();
			  pd = mkdom(dom.ns, ctl.mem());
			  tab = (`HT*){pd}regs->rdi;
			  k = (void*){pd}regs->rsi;
			  v = (`Seg*){pd}regs->rdx;
			  if(tab != pd`segtab)
				  return;
			  printf("hputp %p -> %s\n", k, fmtseg(v));
		  });
if(0)	dom.xtrap(&dom`freeseg,
		  @lambda(ctl){
			  @local pd, regs, s;
			  regs = ctl.reg();
			  pd = mkdom(dom.ns, ctl.mem());
			  s = (`Seg*){pd}regs->rdi;
			  printf("freeseg %s\n", fmtseg(s));
		  });
if(0)	dom.xtrap(&dom`minsert,
		  @lambda(ctl){
			  @local pd, regs, m, s;
			  regs = ctl.reg();
			  pd = mkdom(dom.ns, ctl.mem());
			  m = (`M*){pd}regs->rdi;
			  s = (`Seg*){pd}regs->rsi;
			  printf("minsert into %e %s\n", m->gen, fmtseg(s));
		  });
if(0)	dom.xtrap(&dom`gc,
		  @lambda(ctl){
			  @local pd, regs, g, tg;
			  regs = ctl.reg();
			  pd = mkdom(dom.ns, ctl.mem());
			  g = (`u32){pd}regs->rdi;
			  tg = (`u32){pd}regs->rsi;
			  printf("gc(%d,%d)\n", g, tg);
			  dumpprot(dom);
		  });
if(0)	dom.xtrap(&dom`updateguards,
		  @lambda(ctl){
			  trace0(dom);
		  });

if(0)	dom.xtrap(&dom`gcprotect,
		  @lambda(ctl){
			  @local pd, regs, v;
			  regs = ctl.reg();
			  pd = mkdom(dom.ns, ctl.mem());
			  v = (`Head*){pd}regs->rdi;
			  if(Vkind(v) == dom`Qcl){
				  v = (`Closure*)v;
				  printf("gcprotect %s (code %p)\n",
					 fmthd(v), v->code);
			  }else if(Vkind(v) == dom`Qcode){
				  v = (`Code*)v;
				  printf("gcprotect %s\n", fmthd(v));
			  }
		  });

if(0)	dom.xtrap(&dom`freecode,
		  @lambda(ctl){
			  @local pd, regs, v;
			  regs = ctl.reg();
			  pd = mkdom(dom.ns, ctl.mem());
			  v = (`Head*){pd}regs->rdi;
			  printf("freecode %s\n", fmthd(v));
		  });

if(0)	dom.xtrap(&dom`copy,
		  @lambda(ctl){
			  @local pd, regs, v;
			  regs = ctl.reg();
			  pd = mkdom(dom.ns, ctl.mem());
			  v = (`Head**){pd}regs->rdi;
			  v = *v;
			  if(v == 0)
				  return;
			  if((`uint64)v&1)
				  return;
			  if(Vkind(v) == dom`Qcode && !Vfwd(v))
				  printf("maybe copy %s\n", fmthd(v));
		  });

if(0)	dom.xtrap(&dom`mkcl,
		  @lambda(ctl){
			  @local pd, regs, v;
			  regs = ctl.reg();
			  pd = mkdom(dom.ns, ctl.mem());
			  v = (`Head*){pd}regs->rdi;
			  printf("mkcl %s\n", fmthd(v));
			  printf("%s\n", fmtstack(ctl, ns));
		  });
if(0)	brk(&dom`mkcl,
	    @lambda(ctl, code, entry, len, id){
		    printf("mkcl %s\n", fmthd(code));
		    printf("%s\n", fmtstack(ctl, nsof(code)));
	    });

if(0)	brk(&dom`freecode,
	    @lambda(ctl, code){
		    printf("freecode %s\n", fmthd(code));
	    });

if(0)	brk(&dom`gc,
	    @lambda(ctl, g, tg){
		    printf("gc(%d,%d) entered\n", g, tg);
		    printf("%s\n", fmtstack(ctl, nsof(g)));
	    });

if(0)	rbrk(&dom`gc,
	     @lambda(ctl, g, tg){
		     printf("gc(%d,%d) returned\n", g, tg);
		     printf("%s\n", fmtstack(ctl, nsof(g)));
	     });
if(0)	brk(&dom`reloc1,
	    @lambda(ctl, c){
		    if(Vdead((`Head*)c))
			    printf("relocating dead code %s!\n", fmthd(c));
	    });

if(0)	rbrk(&dom`malcode,
	     @lambda(ctl, h){
		     printf("malcode %p\n", h);
		     printf("%s\n", fmtstack(ctl, nsof(h)));
	     });

{
	@local tid, once, setmalloc, dumpstack;
	@local tab, segs;
	@local nmk, nfr;
	@local oops;
	@local live, adj;

	@define reset()
	{
		nmk = nfr = 0;
		tab = [:];
		segs = [:];
		oops = [:];
		adj = 0;
	}

	live = [:];
	reset();

	@define getstack(ctl)
	{
		@local xs, pcs;
		xs = ctl.unwind();
		if(xs == nil){
			printf("cannot unwind\n");
			return;
		}
		pcs = map(@lambda(x){ x->rip; }, xs);
		return pcs;
	}

	@define printstack(pcs)
	{
		foreach(@lambda(pc){
				printf("\t%016p\t\t%y\n",
				       pc, {dom}pc);
			}, pcs);
		printf("\n");
	}

	@define dumpstack(ctl)
	{
		@local pcs;
		pcs = getstack(ctl);
		if(tab[pcs] == nil)
			tab[pcs] = 1;
		else
			tab[pcs] += 1;
		return;
		foreach(@lambda(x){
				printf("\t%016p\t\t%y\n",
				       x->rip,
				       {dom}x->rip);
			}, xs);
		printf("\n");
	}

	@define summarize()
	{
		@local i, q, cnt, lo;

		printf("\n**********\n");
		if(0)foreach(@lambda(pcs, n) {
				printf("\t%d times:\n", n);
				printstack(pcs);
			}, tab);
		printf("#mkseg = %u\n", nmk);
		printf("#freeseg = %u\n", nfr);
		printf("H.nseg = %u\n", dom`H.nseg);
		printf("#leftover = %u\n", length(segs));
		printf("cqctmeminuse = %u\n", dom`cqctmeminuse);
		printf("segtag->sz = %u\n", dom`segtab->sz);
		printf("segtag->nent = %u\n", dom`segtab->nent);

		@define cnt(q)
		{
			@local n;
			n = 0;
			while(q){
				n++;
				q = q->link;
			}
			return n;
		}

		for(i = 0; i < dom`Ngen; i++){
			printf("length(H.data[%u]) = %u\n", i,
			       cnt(dom`H.data[i].h));
			printf("length(H.code[%u]) = %u\n", i,
			       cnt(dom`H.code[i].h));
		}
		printf("**********\n");
		return;


		if(0)foreach(@lambda(seg, pcs){
				printf("\tsegment %p leftover\n", seg);
				printstack(pcs);
			}, segs);


		@define checklost(q)
		{
			while(q){
				tabdelete(segs, q);
				q = q->link;
			}
		}

		@define invert(t)
		{
			@local inv;
			inv = [:];
			foreach(@lambda(k, v){
					if(inv[v] == nil)
						inv[v] = 1;
					else
						inv[v]++;
				}, t);
			return inv;
		}

		@define dumpstackhist(pref, t)
		{
			foreach(@lambda(pcs, n){
					printf("%u %s\n", n, pref);
					printstack(pcs);
				}, t);
		}

		dumpstackhist("unfreed allocations made from:",
			      invert(live));
		printf("%d bytes of realloc adjustments\n", adj);

		if(0){
			for(i = 0; i < dom`Ngen; i++){
				checklost(dom`H.data[i].h);
				checklost(dom`H.code[i].h);
			}

			lo = [:];
			foreach(@lambda(seg, pcs){
					if(lo[pcs] == nil)
						lo[pcs] = 1;
					else
						lo[pcs]++;
				}, segs);
			foreach(@lambda(pcs, n){
					printf("\t%d segments lost from:\n", n);
					printstack(pcs);
				}, lo);
		}
		if(0){
			printf("oops:\n");
			foreach(@lambda(pcs, n){
					printf("\t%d oops\n", n);
					printstack(pcs);
				}, oops);
		}
		reset();
	}

	brk(&dom`l1_meminuse, @lambda(args ...){ summarize(); });
	if(0)brk(&dom`minit,
	    @lambda(ctl, m, s){
		    if(m->h != 0){
			    @local pcs;
			    pcs = getstack(ctl);
			    if(oops[pcs] == nil)
				    oops[pcs] = 1;
			    else
				    oops[pcs]++;
		    }
	    });

	once = 0;
	@define setmalloc()
	{
		rbrk(&dom`emalloc,
		     @lambda(ctl, p, sz){
			     live[p] = slice(getstack(ctl), 0, 2);
		     });
	}

	@define setfree()
	{
		brk(&dom`efree,
		    @lambda(ctl, p){
			    tabdelete(live, p);
		    });
	}

	@define setrealloc()
	{
		rbrk(&dom`erealloc,
		     @lambda(ctl, newp, oldp, oldsz, newsz){
			     @local s;
			     s = live[oldp];
			     if(s != nil){
				     tabdelete(live, oldp);
				     live[newp] = s;
			     }
			     adj += newsz-oldsz;
			     printstack(getstack(ctl));
		     });
	}

	if(0)rbrk(&dom`mkseg,
	     @lambda(ctl, s, type){
		     nmk++;
		     segs[s] = getstack(ctl);
	     });

	if(0)brk(&dom`freeseg,
	    @lambda(ctl, s){
		    nfr++;
		    if(segs[s] != nil)
			    tabdelete(segs, s);
		    else{
			    printf("unregistered segment %p\n", s);
			    printstack(getstack(ctl));
		    }
	    });
			    
	if(0)brk(&dom`gc,
	    @lambda(ctl, g, tg){
//			 printf("gc(%d,%d) entered!\n", g, tg);
			 if(!once){
				 setmalloc();
				 setfree();
				 setrealloc();
				 once = 1;
			 }
	    });
	if(0)rbrk(&dom`gc,
	     @lambda(ctl, g, tg){
		     printf("gc(%d,%d) returned\n", g, tg);
		     printf("deleting %a\n", tid);
		     ctl.trapdel(tid);
		     printf("did delete\n");
	     });
}
}

@define getstack(ctl)
{
	@local xs, pcs;
	xs = ctl.unwind();
	if(xs == nil){
		printf("cannot unwind\n");
		return;
	}
	pcs = map(@lambda(x){ x->rip; }, xs);
	return pcs;
}

@define printstack(pcs)
{
	foreach(@lambda(pc){
			printf("\t%016p\t\t%y\n",
			       pc, {dom}pc);
		}, pcs);
	printf("\n");
}

@define config(dom)
{
	@local dumpcl, watch, rwatch;

	watch = [:];
	rwatch = [:];

	@define setwatch(id, a)
	{
		watch[id] = (`Head*){dom}a;
		rwatch[(`Head*){dom}a] = id;
	}

	@define clrwatch(id)
	{
		tabdelete(rwatch, watch[id]);
		tabdelete(watch, id);
	}

	@define upwatch(id, a)
	{
		clrwatch(id);
		setwatch(id, a);
	}

	@define lookwatch(id)
	{
		return watch[id];
	}

	@define lookrwatch(a)
	{
		return rwatch[(`Head*){dom}a];
	}


	@define dumpcl(cl)
	{
		@local i, p;
		cl = (`Closure*)cl;
		printf("\tcl->dlen = %d\n", cl->dlen);
		for(i = 0; i < cl->dlen; i++){
			p = cl->display[i];
			if(Vkind(p) == dom`Qbox){
				p = (`Box*)p;
//				printf("\t[%u] = %s -> %s\n",
//				       i,
//				       fmthd(p),
//				       fmthd(p->v));
				printf("\t[%u] = %s\n", i, fmthd(p));
			}else{
				printf("\t[%u] = %s\n",
				       i,
				       fmthd(p));
			}
		}
		printf("\n");
	}

	@define watchcl(cl)
	{
		@local i, p;
		cl = (`Closure*)cl;
		printf("\tcl->dlen = %d\n", cl->dlen);
		for(i = 0; i < cl->dlen; i++){
			p = cl->display[i];
			if(Vkind(p) == dom`Qbox){
				p = (`Box*)p;
				setwatch(sprintfa("cl-disp-%u", i), p);
//				printf("\t[%u] = %s -> %s\n",
//				       i,
//				       fmthd(p),
//				       fmthd(p->v));
				printf("\t[%u] = %s\n", i, fmthd(p));
			}else{
				printf("\t[%u] = %s\n",
				       i,
				       fmthd(p));
			}
		}
		printf("\n");
	}

	brk(&dom`freeseg,
	    @lambda(ctl, s){
		    printf("freeseg %p - %p\n", s->addr, s->e);
		    foreach(@lambda(id, a){
				    if(a >= {dom}s->addr & a < {dom}s->e)
					    printf("freeing live object %s!\n",
						   id);
			    }, watch);
	    });

	rbrk(&dom`mkseg,
	     @lambda(ctl, s, kind){
		     printf("mkseg %p - %p\n", s->addr, s->e);
	     });

	brbrk(&dom`gc,
	     @lambda(ctl, g, tg){
		     if(dom`vms[0] == 0)
			     return nil;
		     if(lookwatch("thecl") == nil)
			     return nil;
		     printf("enter gc(%u,%u)\n", g, tg);
		     return @lambda(ctl, t, gc){
			     printf("after gc(%u,%u):\n", g, tg);
			     printf("\tthecl = %s\n",
				    fmthd(lookwatch("thecl")));
		     };
	     });

	rbrk(&dom`l1_cons,
	     @lambda(ctl, vm, argc, argv, rv){
		     setwatch("thecons", *rv);
		     printf("l1_cons returned -> %s\n",
			    fmthd(lookwatch("thecons")));
		     rbrk(&dom`mkcl,
			  @lambda(ctl, cl, code, insn, len, label){
				  setwatch("thecl", cl);
				  printf("\n leave mkcl (len = %u, cl = %s)\n",
					 len, fmthd(cl));
				  printstack(getstack(ctl));
				  rbrk(&dom`itercl,
				       @lambda(ctl, v, hd, ictx){
					       if({dom}hd != lookwatch("thecl"))
						       return;
					       printf("itercl on thecl -> %s\n",
						      fmthd(*v));
				      });
			 });

		     rbrk(&dom`xclo,
			 @lambda(ctl, vm, dl, label, dst){
				 printf("leave xclo\n");
				 watchcl(lookwatch("thecl"));
			 });
	     });

	brbrk(&dom`copy,
	      @lambda(ctl, v){
		      @local id, s;
		      id = lookrwatch(*v);
		      if(id == nil)
			      return nil;
		      printf(" enter copy on %s: %s\n", id, fmthd(*v));
		      if(!Vfwd(*v) || !Vprot(*v))
			      printf("  object is in %s\n",
				     fmtseg(lookseg(*v)));
		      return @lambda(ctl, v){
			      printf("return copy on %s: %s\n", id, fmthd(*v));
			      upwatch(id, *v);
		      };
	      });
}

@define trace1(dom)
{
	@local H, o, s, p, i, m, qs;
	H = &dom`H;
	s = H->data[0].h;
	while(s){
		printf("\t%s\n", fmtseg(s));		
		s = s->link;
	}
}

@define doit(args)
{
	@local mux, as, e, nexec, xns;

	nexec = 0;
	npop = 0;
//	e = sprintfa("@names clp64le { @include \"%s\" };", l1names);
//	ns = eval(e);
	mux = mkctlmux_local();
	push(args, l1);
	ctl = mux.launch(args, 0);
	as = ctl.mem();
	ns = ctl.ns();
	if(isns(ns))
		printf("got namespace %a!\n", ns);
	else
		error("hmmf.  no namespace! (got %a)\n", ns);
	dom = mkdom(ns, as);
	
	config(dom);
	dom.trace(ctlmux`Esignal,
		  @lambda(ctl, sig){
			  @local regs;
			  printf("proc %d received signal %d\n", ctl.id, sig);
			  regs = ctl.reg();
			  printf("%s\n", fmtstack(ctl, ns));
			  ctl.kill();
		  });
	dom.xcont();
	mux.run();
}

doit([ "-o", args[1] ]);
