@include <debug.cqct>

@define getstarted(cmd)
{
	@local mux;
	mux = mksctlmux();
	ctllaunch(mux, ["./list"]);
	mux.run();
}

@define start(cmd)
{
	@local mux, ctl, exe;
	mux = mksctlmux();
	ctl = ctllaunch(mux, cmd);
	exe = ctl.exe();
	return [mux, ctl, exe];
}

@define brkentry1()
{
	@local mux, ctl, exe;
	[mux,ctl,exe] = start(["./list"]);
	ctl.trap('brk, &exe`main, @lambda(ctl) { printf("enter main\n"); });
	ctl.trap('brk, &exe`dowork, @lambda(ctl) { printf("enter dowork\n"); });
	ctl.trap('brk, &exe`insert, @lambda(ctl) { printf("enter insert\n"); });
	mux.run();
}

@define brkentry2()
{
	@local mux, ctl, exe;
	[mux,ctl,exe] = start(["./list"]);

	@defloc handler(ctl)
	{
		printf("enter insert\n");
	}

	ctl.trap('brk, &exe`insert, handler);
	mux.run();
}

@define ctx1()
{
	@local mux, ctl, exe, ctx;
	[mux,ctl,exe] = start(["./list"]);
	ctx = ctl.ctx();
	printf("pc = %p, sp = %p, fp = %p\n",
	       ctx->pc, ctx->sp, ctx->fp);
}

@define ctx2()
{
	@local mux, ctl, exe, ctx;
	[mux,ctl,exe] = start(["./list"]);
	ctx = ctl.ctx();
	ctl.dialect().dumpctx(ctx);
}

@define ctx3()
{
	@local mux, ctl, exe, ctx;
	[mux,ctl,exe] = start(["./list"]);
	ctx = ctl.ctx();
	printtype(typedeftype(@typeof(*ctx)));
}

@define unwind()
{
	@local mux, ctl, exe;
	[mux,ctl,exe] = start(["./list"]);

	@defloc handler(ctl)
	{
		@local ctxs;
		printf("enter insert\n");
		ctxs = ctl.unwind();
		foreach(@lambda(ctx){ printf("%s\n", fmtframe(ctl, ctx)); },
			ctxs);
		printf("\n");
	}

	ctl.trap('brk, &exe`insert, handler);
	mux.run();
}

@define args1()
{
	@local mux, ctl, exe;
	[mux,ctl,exe] = start(["./list"]);

	@defloc handler(ctl)
	{
		@local ctx;
		ctx = ctl.ctx();
		printf("enter insert(0x%p, %d)\n", ctx->rdi, ctx->rsi);
	}

	ctl.trap('brk, &exe`insert, handler);
	mux.run();
}

@define args2()
{
	@local mux, ctl, exe;
	[mux,ctl,exe] = start(["./list"]);

	@defloc showlist(h)
	{
		printf("\tlist =");
		while(h){
			printf(" %d", h->v);
			h = h->next;
		}
		printf("\n");
	}

	@defloc handler(ctl)
	{
		@local ctx, exe, h;

		ctx = ctl.ctx();
		exe = ctl.exe();
		printf("enter insert(0x%p, %d)\n", ctx->rdi, ctx->rsi);
		h = (Node*){exe}ctx->rdi;
		showlist(h);
	}

	ctl.trap('brk, &exe`insert, handler);
	mux.run();
}

@define locals()
{
	@local mux, ctl, exe;
	[mux,ctl,exe] = start(["./list"]);

	@defloc handler(ctl)
	{
		@local ctx, ctxs, ldom;
		ctx = ctl.ctx();
		printf("enter insert(0x%p, %d)\n", ctx->rdi, ctx->rsi);
		ctxs = ctl.unwind();
		ctx = ctxs[1]; /* context for "dowork" */
		ldom = ctl.ldom(ctx);
		printf("\tcalled from dowork: i=%d, head=0x%p, n=%d\n",
		       ldom`i, ldom`head, ldom`n);
	}

	ctl.trap('brk, &exe`insert, handler);
	mux.run();
}

@define brkreturn()
{
	@local mux, ctl, exe;
	[mux,ctl,exe] = start(["./list"]);

	@defloc handler(ctl)
	{
		@local ctx, sp, id;
		ctx = ctl.ctx();
		sp = (void**)ctl.cast(ctx->sp);
		printf("enter insert\n");
		id = ctl.trap('brk, *sp,
			      @lambda(rctl){
				      @local ctx;
				      ctl.clear(id);
				      ctx = rctl.ctx();
				      printf("return from insert -> %p\n",
					     ctx->rax);
			      });
	}

	ctl.trap('brk, &exe`insert, handler);
	mux.run();
}

@define syscalls()
{
	@local mux, ctl, exe;
	[mux,ctl,exe] = start(["./list"]);

	@defloc handler(ctl)
	{
		@local ctx;
		ctx = ctl.ctx();
		
		printf("syscall %e\n",
		       {ctl.dialect().Syscall}ctx->orig_rax);
	}

	ctl.trap('syscall, handler);
	mux.run();
}

@define forks()
{
	@local mux, ctl, exe;
	[mux,ctl,exe] = start(["./forks"]);

	@defloc handler(ctl, spwn)
	{
		printf("%d has forked %d\n", ctl.id, spwn.id);
	}

	ctl.trap('fork, handler);
	mux.run();
}

@define forkexec()
{
	@local mux, ctl, exe;
	[mux,ctl,exe] = start(["./forkexec", "./list"]);

	@defloc	onload(ctl, path, base)
	{
		printf("%d has loaded %s at 0x%p\n", ctl.id, path, base);
	}

	@defloc	onfork(ctl, spwn)
	{
		printf("%d has forked %d\n", ctl.id, spwn.id);
	}

	@defloc onexec(ctl)
	{
		@local exe;
		exe = ctl.exe();
		printf("%d has exec'ed %s\n", ctl.id, ctl.nsmap().nspath(exe.ns));
	}

	@defloc onexit(ctl, status)
	{
		printf("%d has exited with status %d\n", ctl.id, status);
	}

	ctl.trap('load, onload);
	ctl.trap('fork, onfork);
	ctl.trap('exec, onexec);
	ctl.trap('exit, onexit);

	mux.run();
}

@define exits()
{
	@local mux, ctl, exe;
	@local h;
	[mux,ctl,exe] = start(["./list"]);

	@defloc showlist(h)
	{
		while(h){
			printf(" %d", h->v);
			h = h->next;
		}
	}

	@defloc oninsert(ctl)
	{
		@local ctx;

		ctx = ctl.ctx();
		printf("enter insert(0x%p, %d)\n", ctx->rdi, ctx->rsi);
		if(!h)
			h = (Node*){exe}ctx->rdi;
		printf("\n");
	}
	ctl.trap('brk, &exe`insert, oninsert);

	@defloc onexit(ctl, stat)
	{
		@local ctx, ctxs;
		ctx = ctl.ctx();
		printf("%d has exited %d at %p\n", ctl.id, stat, ctx->pc);
		ctxs = ctl.unwind();
		foreach(@lambda(ctx){ printf("%s\n", fmtframe(ctl, ctx)); },
			ctxs);
		printf("\n");
		printf("list = "); showlist(h); printf("\n");
	}

	ctl.trap('exit, onexit);
	mux.run();
}

/*
  want interface for getting registers/context pre-cast
  into the address space and name space.
  
  ctl.cast(addr) -- project addr into the right domain

  {ctl}ctx->pc  -- would be ideal

  ctx->pc -- somehow pre cast

 */
