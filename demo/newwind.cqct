@include <ctlmux.cqct>
@include <sctlclt.cqct>
@include <dwunwind.cqct>
@include <dwlocal.cqct>
/* @include <dump.cqct> */ /* objectStr */

progs = [ [ "./wind1", 'f ],
	  [ "./wind1.32", 'f ],
	  [ "./wind2", 'f ],
	  [ "./wind2.32", 'f ],
	];

// @define fmtloc(ldom)
// {
// 	@local nptr, s, t;
// 	nptr = nsptr(ldom);
// 	s = "";
// 	foreach(@lambda(id, sym){
// 			s += sprintfa("\t%016p\t%t ",
// 				     symoff(sym), sym);
// 			t = mkctype_ptr(symtype(sym), nptr);
// 			printf("objectStr on %016p\t%t\n",
// 			       symoff(sym), sym);
// 			s += objectStr({t}{ldom}symoff(sym));
// 			s += "\n";
// 		}, ldom.enumsym());
// 	return s;
// }

@define fmtstack(pcs, lls)
{
	@local s, m;
	s = "";
	m = 0;
	foreach(@lambda(pc){
			@local ldom;
			s += sprintfa("%016p\t%y\n", pc, pc);
			ldom = lls[m++];
			if(ldom)
//				s += fmtloc(ldom);
				foreach(@lambda(id, l){
						s += sprintfa("\t%016p\t%t\n",
							      symoff(l),
							      l);
					}, ldom.enumsym());
		}, pcs);
	return s;
}

@define try(spec)
{
	@local ctl, as, ns, dom, dvec, mux, xs, pcs, lls;
	@local prog, id, sym;

	prog = spec[0];
	id = spec[1];
	printf("%s:\n", prog);
	mux = mkctlmux_local();
	ctl = mux.launch([prog], 0);
	as = ctl.mem();
	ns = ctl.ns();
	dom = mkdom(ns, as);
	sym = looksym(dom, id);
	if(sym == nil)
		error("%s is not defined in %s", id, prog);
	dom.xtrap(symoff(sym),
		  @lambda(ctl){
			  if(dvec == nil)
				  dvec = mkdvec(ctl);
			  xs = dwunwind(dvec, ctl.reg());
			  pcs = map(@lambda(ctx){
					  @local v;
					  v = lookdvec(dvec, ctx->rip);
					  return {v.dom}ctx->rip;
				  }, xs);
			  lls = map(@lambda(ctx){ dwlocal(dvec, ctx); }, xs);
			  printf("%s\n", fmtstack(pcs, lls));
		  });
	dom.xcont();
	mux.run();
}

foreach(try, progs);
