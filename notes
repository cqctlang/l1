todo
----
- core functionality
  - other string functions
    strcata
    isstring like old cqct isstring?
  - rationalize names of various type routines
	 (isfunc/mkctype_fn, isenumconst/mkctype_const,...)
  - provide a mapfile mode argument:
	"r" - private copy of the file
	"w" - shared copy of the file
    perhaps there should be a way to map a newly created file?
  - implement copy and foreach on missing container types (strings and tables)
  - formatted printing:
	- with widths (and precisions)
  - switch enum operands shortform
  - introduce address types
    - shouldn't bpset take an address argument?
  - figure out interactive control story:
  	- fast exit
  	- interruption
    interactions of signals with threads?
    gc state vs exit and interruption
    useful for blocking/polling on remote events
  - optional names for as, ns, and dom
    - display names in errors such as "undefined type"
  - does pointer conversion make sense when type comes from a domain
    with different pointer size?
    e.g.:
	t = dom32.ns.looktype(T*)
	v = {t}<dom64,.,val>
        now v is a 32-bit pointer in a 64-bit domain
        certainly it does not make sense when structs containing
        pointers are carried over.
        seems too unusual to handle in a special way; instead,
	should just note the problem.
  - i/o on pointer arguments:
	if buffer for sprintf, read, or write, is a pointer, then
        do the i/o directly on the domain.
  - make cval and put instructions callable
  - isundefined
  - rename istypename to isctype
  - move most thunks to builtins, clean up instruction set
  - ; 'a';
    <cval 97> // do 'a' instead
  - foreach as @foreach syntax with break and continue
  - callcc broken: cannot invoke continuation in different dovm frame
    from one in which it was taken.
    need to capture C stack as well as VM stack.
    soln: 1. vm maintains pointer to base of C stack, init 0;
             first call to dovm initializes, clears on exit
          2. callcc copies C stack from current frame to base;
             it also copies gcprot list.
          3. cont invocation restores C stack (from temp stack?)
             and gc prot list.
  
          4. gc walks gc prot list on all continuations
  - determine and document what happens when ns defines
    typedef X and enum X or sym X and user says
    	    sizeof(dom`X);
    seems now that typedef wins.
  - make define implicitly add @local binding to enclosing block
  - b6b4d11b339 (sep 8 2008) causes label conflict on "x.f();"
  - define equality operators, their meaning (==, equal, ...),
    and their role in hash tables
    - for ctypes: pointer eq, name eq, structure eq;

- usability
  - change "entry" to "toplevel"
  - print the original source for a lambda
  - use-before-define analysis
  - when an as .operator errors, the stack trace shows "apply"
    as the next frame, followed by the name of the as dispatch
    routine, instead of the name of the faulting operator.
    it would be nice to see the name of the operator.

- robustness
  - can we programmatically dump all fields in a struct, even
    if there are bitfields?  would be a nice example.
  - handle stack overflow
  - how to define strings of length 2^64?
  - does a negative array index work?
  - check for negative cvals on Irange, Istr, Islice*, Ivec*, etc.
  - change all thunks that do not return values to return nil
  - check various parse/compile error recovery paths for leaks
  - mutator can alloc new cvalues faster than gc can
    put them back onto the freelist.
    potential solution: block halloc from allocating new memory
         until one of more gc epoch has finished;
         then retry.
         need to be careful about not restarting gc, because
         existing invariant holds that dovm is a gc epoch barrier.
  - all type deconstructors (e.g., fields) need to check for
    type attributes that are not required for constructors
  - why do vmerr backtraces include entry, but not fatal ones?
  - why doesn't inline fn call work:  lambda(x){ printf("%d\n"); }()
  - this draws confusing diagnostic:
    	tab = mktab(); print("%d\n", tab->len);
  - rationalize MAX and max()
  - what domain are cvals in symbol offsets in name spaces?
    for actual symbols (not consts), should they be Vptr in containing ns?
    can dorawns perform this cast?
  - also: verify that address range calculations wrap correctly in
    32-bit contexts
  - does lookaddr constructor sort only symbols (not enums?)
  - detect re-use of tags like k.scm does
  - sizeof(t) errors if t references an undefined subtype;
    we need a simple test for whether a type has such a reference.

- check semantics of scope

  old cqct: var refs create binding in nearest
  lexical scope, unless there is already a binding
  in outer scope, or a top-level binding.

  new cqct: harder to determine at compile time
  whether there is a toplevel binding (really?);
  also, i don't think there is a mechanism to
  add new local bindings to a lambda.

- performance/simplicity
  - consider making routines like nsptr take a cvalue argument
    to avoid intermediate domof calls (they already accept domains)
  - apply is expensive
  - can we remove a level of box indirection on compile0 output?

    how to make it gc-safe? (i.e., without boxes, old values will be
    clobbered w/o being made a root, violating snapshot-at-beginning).

    see imp3, section 4.5, page 101.
    we can detect that our tmp vars (!*)
    are not captured by any closures
    below.
    
    we cannot determine that the functions
    will not capture continuations.
    what are the consequences?
    seems like worse case is that
    resumed continuation would get
    old value of vars...which might
    be the right thing, since these
    are implicit variables.
    
    probably should aggressively
    shadow on the way down, to reduce
    unwanted boxing.
  - simplify labels in cg
  - rationalize protection of toplevel vals from gc 
  - c.y: replace empty statement bodies with nop statement?
    (empty statement bodies caused cg bug:
	if(1) {} return 3; (fixed 8/22/08)
  - jvm "quick" instructions that replace themselves
    on first execution with new instructions that cache
    results of first execution.  e.g., getfield instructions
  - david gregg et al use super instructions
    and replication of code implementing an instruction
    to reduce branch misprediction.  how does their
    model of branch prediction map to current intel processors?
    (2-level indirect as used on pentium M?)
    see also at least 3 items in related work.

- ideas
  - immutable vectors for type datastructures (fields and params)?
  - immutable strings for pre-computed "$get", etc?
  - vector() seems to take arguments in reverse order, which is
    confusing to see in compile0 output...why is this?
  - BISONFLAW:
      whether bison, when building a glr parser, includes the c.y
      prologue is version sensitive (it does in bison 2.3 but not others)
      so we do the #ifdef dance around the headers shared by c.y and c.l.
  - be more flexible about requiring aggregate size and field offsets
    tolerate their absence; raise errors when they are needed.
  - system domain:
	read-only for all but "user controls", e.g., flags.
	get address space layout from os
	with adequate /proc, can we do with just builtin access to ptr 0?

  - extend ns to accommodate non-contiguous functions with inlined code
    inside
	- multiple symbol definitions for the same fn symbol for functions
          that are inlined
	- notion of set of location ranges associated with a symbol
	- lookaddr that can handle these cases
	- @names syntax for above

- grammar
  - sort out problems with odd rule about int(int) in abstract declarators;

other systems
-------------

inferno
- inferno/libinterp/xec.c - vm interpreter
  does gc ever actually run in parallel?  does vm ever use more
  than one host thread concurrently?
- check out inferno discussion jun 3 2008 on refs

dtrace
- ctf
- object code

emmett

parsers
- antlr/peg

new javascript vms
- squirrelfish (webkit)
- tracemonkey (mozilla)
- v8 (chrome)
