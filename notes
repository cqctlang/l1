todo
----

- core functionality
  - bitfields
  - enums
  - incomplete types
  - void types

  - be access routines
  - stringof
  - address space map()

  - switch (plus tia's enum operand idea)

  - binop(T1,T2) -> canonical type
  - mkzas
  - mkmas
  - mapfile
  - introduce address types
    - does bpset require an address argument?
  - dot operator on dom/as
  - extended domain/address space operations
  - figure out interactive control story:
  	- exit
  	- interruption
    interactions of signals with threads?
    gc state vs exit and interruption
    useful for blocking/polling on remote events
  - old-style lists 
  - i/o (file, net)

- robustness
  - test on real name spaces
  - check for negative cvals on Irange, Istr, Islice*, Ivec*
  - check argument count on calls to lambdas
  - change all thunks that do not return values to return nil
  - verify that address range calculations wrap correctly in 32-bit contexts
  - enforce Efields at end of struct, only
  - cleanup and recover from parse/compiler errors
	-> compile-local context for program, memory, recovery

- check semantics of scope

  old cqct: var refs create binding in nearest
  lexical scope, unless there is already a binding
  in outer scope, or a top-level binding.

  new cqct: harder to determine at compile time
  whether there is a toplevel binding (really?);
  also, i don't think there is a mechanism to
  add new local bindings to a lambda.

- performance/simplicity
  - can we remove a level of box indirection on compile0 output?

    how to make it gc-safe? (i.e., without boxes, old values will be
    clobbered w/o being made a root, violating snapshot-at-beginning).

    see imp3, section 4.5, page 101.
    we can detect that our tmp vars (!*)
    are not captured by any closures
    below.
    
    we cannot determine that the functions
    will not capture continuations.
    what are the consequences?
    seems like worse case is that
    resumed continuation would get
    old value of vars...which might
    be the right thing, since these
    are implicit variables.
    
    probably should aggressively
    shadow on the way down, to reduce
    unwanted boxing.

- ideas
  - immutable vectors for type datastructures (fields and params)?
  - immutable strings for pre-computed "$get", etc?
  - vector() seems to take arguments in reverse order, which is
    confusing to see in compile0 output...why is this?
  - BISONFLAW:
      whether bison, when building a glr parser, includes the c.y
      prologue is version sensitive (it does in bison 2.3 but not others)
      so we do the #ifdef dance around the headers shared by c.y and c.l.
  - be more flexible about requiring aggregate size and field offsets
    tolerate their absence; raise errors when they are needed.

- grammar
  - sort out problems with odd rule about int(int) in abstract declarators;

other systems
-------------

inferno
- inferno/libinterp/xec.c - vm interpreter
- check out inferno discussion jun 3 2008 on refs

dtrace
- ctf
- object code

emmett
