todo
----
- core functionality
  - string operations:
    - strcata?
    - isstring like old cqct isstring?
    - search for a substring
    - parse/tokenize ascii, e.g., file of lines containing
	val1 val2
	val1 val2
	...
  - rationalize names of various type routines
	 (isfunc/mkctype_fn, isenumconst/mkctype_const,...)
  - implement copy and foreach on missing container types (strings)
  - switch enum operands shortform
  - more general: x == `enumconst: lookup enumconst in domof(x)
  - introduce address types
    - shouldn't bpset take an address argument?
  - figure out interactive control story:
  	- fast exit
  	- interruption
    interactions of signals with threads?
    gc state vs exit and interruption
    useful for blocking/polling on remote events
  - does pointer conversion make sense when type comes from a domain
    with different pointer size?
    e.g.:
	t = dom32.ns.looktype(T*)
	v = {t}<dom64,.,val>
        now v is a 32-bit pointer in a 64-bit domain
        certainly it does not make sense when structs containing
        pointers are carried over.
        seems too unusual to handle in a special way; instead,
	should just note the problem.
  - i/o on pointer arguments:
	if buffer for sprintf, read, or write, is a pointer, then
        do the i/o directly on the domain.
  - make cval and put instructions callable
  - isundefined
  - move most thunks to builtins, clean up instruction set
  - ; 'a';
    <cval 97> // do 'a' instead
  - foreach as @foreach syntax with break and continue
  - callcc broken: cannot invoke continuation in different dovm frame
    from one in which it was taken.
    need to capture C stack as well as VM stack.
    soln: 1. vm maintains pointer to base of C stack, init 0;
             first call to dovm initializes, clears on exit
          2. callcc copies C stack from current frame to base;
             it also copies gcprot list.
          3. cont invocation restores C stack (from temp stack?)
             and gc prot list.
  
          4. gc walks gc prot list on all continuations
  - determine and document what happens when ns defines
    typedef X and enum X or sym X and user says
    	    sizeof(dom`X);
    seems now that typedef wins.
  - make define implicitly add @local binding to enclosing block
  - b6b4d11b339 (sep 8 2008) causes label conflict on "x.f();"
  - define equality operators, their meaning (==, equal, ...),
    and their role in hash tables
    - for ctypes: pointer eq, name eq, structure eq;
  - make enumtype etc implicit calls to underlying ns functions
    get rid of nsenumtype accessor
  - sometimes it would be nice to reference symbols/types in
    a namespace without creating a domain.
  - direct access to name space types and functions
  - named constants outside of a name space
    - seek and its constants
    - provide a mapfile mode argument:
	"r" - private copy of the file
	"w" - shared copy of the file
      perhaps there should be a way to map a newly created file?
      make mmap general
  - alternate equality for cvalues (useful for table keys):
    - struct* : structure equality on values of fields, or recursively thus
                used as simple mech for showing variety of values
                some structure obtains
  - detect variable use-before-define errors, especially
    because locals share storage in frame 
  - it should be easier to write htons
  - move gcpersist's list to GC (from VM), and put kcode, ccode, etc. on it
  - del operator to force unbinding and gc
    - e.g., terminate an iostats-like interposition op on a value
  - what does typeof(`foo) on type foo mean?  does it compute
    just the type name, or does it look it up in a dom, providing
    a definition?  current impl looks it up in litdom; and there
    is no syntactic way to build just the name (## is sugar for typeof)
  - getcwd
  - time formatting
  - eq and equal tables
  - weak keys?
  - attr to xaccess ctype
  - revise as interface to use unit idea
  - enforce return value type on sort
  - change tabenum to return kv pairs
 
- usability
  - change "entry" to "toplevel"
  - print the original source for a lambda
  - use-before-define analysis
  - when an as .operator errors, the stack trace shows "apply"
    as the next frame, followed by the name of the as dispatch
    routine, instead of the name of the faulting operator.
    it would be nice to see the name of the operator.

- robustness
  - get rid of efree
  - can we programmatically dump all fields in a struct, even
    if there are bitfields?  would be a nice example.
  - handle stack overflow:
     stack should grow as needed;
     mechanisms need to work with gc and continuations;
     BUG: sub %sp, n, %sp does not detect overflow of sp;
          allows code to write off the stack.
  - how to define strings of length 2^64?
  - does a negative array index work?
  - check for negative cvals on Irange, Istr, Islice*, Ivec*, etc.
  - change all thunks that do not return values to return nil
  - fix leaks in parse/compile error recovery paths
  - all type deconstructors (e.g., fields) need to check for
    type attributes that are not required for constructors
  - this draws confusing diagnostic:
    	tab = mktab(); print("%d\n", tab->len);
  - what domain are cvals in symbol offsets in name spaces?
    for actual symbols (not consts), should they be Vptr in containing ns?
    can dorawns perform this cast?
  - also: verify that address range calculations wrap correctly in
    32-bit contexts
  - does lookaddr constructor sort only symbols (not enums?)
  - detect re-use of tags like k.scm does
  - sizeof(t) errors if t references an undefined subtype;
    we need a simple test for whether a type has such a reference.
  - does enconsts make bad assumption about domlook?
  - map-based ismapped model is broken, because map may be expensive;
    maybe as should implement both.
  - can <domain > occur during %a printing?
  - fix lookaddr to ignore enums when matching addr values
    (e.g. Vlongmax)


- performance/simplicity
  - consider making routines like nsptr take a cvalue argument
    to avoid intermediate domof calls (they already accept domains)
  - apply is expensive
  - can we remove a level of box indirection on compile0 output?

    how to make it gc-safe? (i.e., without boxes, old values will be
    clobbered w/o being made a root, violating snapshot-at-beginning).

    see imp3, section 4.5, page 101.
    we can detect that our tmp vars (!*)
    are not captured by any closures
    below.
    
    we cannot determine that the functions
    will not capture continuations.
    what are the consequences?
    seems like worse case is that
    resumed continuation would get
    old value of vars...which might
    be the right thing, since these
    are implicit variables.
    
    probably should aggressively
    shadow on the way down, to reduce
    unwanted boxing.
  - simplify labels in cg
  - rationalize protection of toplevel vals from gc 
  - c.y: replace empty statement bodies with nop statement?
    (empty statement bodies caused cg bug:
	if(1) {} return 3; (fixed 8/22/08)
  - jvm "quick" instructions that replace themselves
    on first execution with new instructions that cache
    results of first execution.  e.g., getfield instructions
  - david gregg et al use super instructions
    and replication of code implementing an instruction
    to reduce branch misprediction.  how does their
    model of branch prediction map to current intel processors?
    (2-level indirect as used on pentium M?)
    see also at least 3 items in related work.
  - mutator can alloc new cvalues faster than gc can
    put them back onto the freelist.
    potential solution: block halloc from allocating new memory
         until one of more gc epoch has finished;
         then retry.
         need to be careful about not restarting gc, because
         existing invariant holds that dovm is a gc epoch barrier.
  - measure useless computations, e.g., casts that don't change
    the type of a value (instrument xcast instructions).
    report for each operation program point # of id and non-id ops.

- warnings
  - statically report use of +=, ++, etc on uninitialized vars
  - on unused variables
  - redundantly declared locs
  - locs that shadow params


- ideas
  - immutable vectors for type datastructures (fields and params)?
  - immutable strings for pre-computed "$get", etc?
  - vector() seems to take arguments in reverse order, which is
    confusing to see in compile0 output...why is this?
  - BISONFLAW:
      whether bison, when building a glr parser, includes the c.y
      prologue is version sensitive (it does in bison 2.3 but not others)
      so we do the #ifdef dance around the headers shared by c.y and c.l.
  - be more flexible about requiring aggregate size and field offsets
    tolerate their absence; raise errors when they are needed.
  - system domain:
	read-only for all but "user controls", e.g., flags.
	get address space layout from os
	with adequate /proc, can we do with just builtin access to ptr 0?
  - extend ns to accommodate non-contiguous functions with inlined code
    inside
	- multiple symbol definitions for the same fn symbol for functions
          that are inlined
	- notion of set of location ranges associated with a symbol
	- lookaddr that can handle these cases
	- @names syntax for above
  - on string types, arithmetic works like pointer arithmetic:
	s += 3;	/* bind s to new string advanced by 3 */
    might be confusing unless there is a shared string notion
    that we can use to generate pointers.
  - expressions in a @names form are evaluated in unspecified order;
    cannot depend on side effects occurring in some order.
    this precludes a potentially useful idiom:
	x = 0;
	@(x+=4) int x;
	@(x+=4) int y;


- grammar
  - sort out problems with odd rule about int(int) in abstract declarators;
  - statement blocks as general expressions
    currently not permitted in concrete syntax
    but used (productively) by internal source rewriter

    issue is that forms in which block used as expr, such as

	x = { 3;};

    do not parse.  grammar does not allow compound statement
    to be form of expr

    since stmt is defined to be:   <expr> ';'

    this change would cause ordinary compound statements
    to end in a semicolon:

	{
		stmt;
		{
			stmt;
		};  <---  this ; would be new
	}

  - choice of $ in @names extension is unfortunate but other choices
    are also problematic:

	@names expr expr { ... }       ambiguous
	@names expr , expr { ... }     ambiguous
	@names expr (expr) { ... }     ambiguous

- documentation
  - defining an enumeration type (enumconst)
  - revise symbol interface docs (symval is defunct; describe attr tab)
  - toplevel args variable

- regular expressions
  - ranges of values (0x1000-0x2000)
  - binary (no constraints on pattern or text)
  - generalize to searching over types (type patterns?)
  - bit patterns c&0x3==1
  - assertions (rsc terminology) for alignment matches
    akin to beginning-of-line, etc matches
  - backreferences (maybe)
  - compound res: conveniently stream matches into next re search
  - ensure that a0|a1|...|an for large n works as well
    as sequential a0, a1, ..., an searches
  

other systems
-------------

inferno
- inferno/libinterp/xec.c - vm interpreter
  does gc ever actually run in parallel?  does vm ever use more
  than one host thread concurrently?
- check out inferno discussion jun 3 2008 on refs

dtrace
- ctf
- object code

emmett

gdb agent

parsers
- antlr/peg

new javascript vms
- squirrelfish (webkit)
- tracemonkey (mozilla)
- v8 (chrome)
