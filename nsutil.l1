define typeequal(t1, t2){
	@local i, j, flds1, flds2, f1, f2, c1, c2;
	if(t1 != t2)
		return 0;	/* name equality */
	if(issu(t1)){
		if(susize(t1) != susize(t2))
			return 0;
		flds1 = fields(t1);
		flds2 = fields(t2);
		if(length(flds1) != length(flds2))
			return 0;
		for(i = 0; i < length(flds1); i++){
			f1 = vecref(flds1, i);
			f2 = vecref(flds2, i);
			if(fieldoff(f1) != fieldoff(f2))
				return 0;
			if(fieldid(f1) != fieldid(f2))
				return 0;
			if(fieldtype(f1) != fieldtype(f2))
				return 0;
		}
		return 1;
	}
	if(isenum(t1)){
		cs1 = enumconsts(t1);
		cs2 = enumconsts(t2);
		if(length(cs1) != length(cs2))
			return 0;
		for(i = 0; i < length(cs1); i++){
			c1 = vecref(cs1, i);
			for(j = 0; j < length(cs2); j++){
				c2 = vecref(cs2, j);
				if(vecref(c1, 0) != vecref(c2, 0))
					break;
				if(vecref(c1, 1) != vecref(c2, 1))
					break;
			}
			if(j >= length(cs2))
				return 0;
		}
		return 1;
	}
	return 1;
}

define nsdiff(ns1, ns2){
	@local u1, u2, diff, nsdiff0;

	define nsdiff0(ns1, ns2){
		@local t2, undef;

		undef = mktab();
		foreach(lambda(k, t1){
				t2 = looktype(ns2, t1);
				if(t2 == nil)
					tabinsert(undef, t1, t1);
				else if(!typeequal(t1, t2))
					tabinsert(diff, t1, t1);
			}, nsenumtype(ns1)());
		return undef;
	}


	diff = mktab();
	u2 = nsdiff0(ns1, ns2);
	u1 = nsdiff0(ns2, ns1);

	printf("defined in ns1 but not ns2:\n");
	foreach(lambda(t,ignore){
			printf("\t%t\n", t);
		}, u2);
	printf("defined in ns2 but not ns1:\n");
	foreach(lambda(t,ignore){
			printf("\t%t\n", t);
		}, u1);
	printf("defined differently in ns1 and ns2:\n");
	foreach(lambda(t,ignore){
			printf("\t%t\n", t);
		}, diff);
}

define printtype(t){
	@local ct, i, fld, flds, sz, off;

	if(issu(t)){
		printf("%s %s {\n", suekind(t), suetag(t));
		flds = fields(t);
		for(i = 0; i < veclen(flds); i++){
			fld = vecref(flds, i);
			off = fieldoff(fld);
			ft = fieldtype(fld);
			id = fieldid(fld);
			if(off == nil){
				printf("\t");
				printf("\t%t;\n", fld);
			}else if(isbitfield(ft)){
				printf("\t/*@@(8*0x%x+%x)*/",
				       off, bitfieldpos(ft));
				printf("\t%t %s : %d;\n",
				       bitfieldcontainer(ft), id,
				       bitfieldwidth(ft));
			}else{
				printf("\t/*@0x%x*/", off);
				printf("\t%t;\n", fld);
			}
		}
		sz = susize(t);
		if(sz == nil)
			printf("\t/*@0x%x;*/\n", sz);
		printf("};\n");
	}else if(istypedef(t)){
		printf("typedef %t %s\n", typedeftype(t), typedefid(t));
	}else if(isenum(t)){
		printf("%s %s {\n", suekind(t), suetag(t));
		ens = enumconsts(t);
		for(i = 0; i < veclen(ens); i++){
			en = vecref(ens, i);
			printf("\t%s = %d,\n", vecref(en, 0), vecref(en, 1));
		}
		printf("};\n");
	}
}

define printns(ns){
	@local i, vec;
	vec = tabvals(nsenumtype(ns)());
	for(i = 0; i < veclen(vec); i++)
		printtype(vecref(vec, i));
	vec = tabvals(nsenumsym(ns)());
	for(i = 0; i < veclen(vec); i++){
		@local sym, off, type;
		sym = vecref(vec, i);
		type = symtype(sym);
		if(isenumconst(type))
			continue;
		off = symval(sym);
		if(off != nil)
			printf("/*@0x%x*/", off);
		printf("\t%t;\n", sym);
	}
}
