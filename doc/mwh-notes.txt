HOURS

6/8 3:35-6:15

TO DO

- Deal with nil: this is actually an identifier that's pre-bound in
  the environment.  Since it's not a constant, if I attempt to pattern
  match on it, I effectively rebind it.  This is probably bad in
  general; i.e., allowing users to write nil = 1.
- Deal with fall-through when we've bound stuff
  - Make sure we end with a break or somesuch?
- Warn about shadowing outer bindings in switches, or else fix the
  scoping problem (maybe do both).
- Make a bunch of test cases and check in!

TO DO LATER

- Consider allowing ellipsis immediately following a comma, to
  indicate a tail that you don't need to bind (basically, shorthand
  for _ ...)
- Generalize pattern syntax to be p && e where e is a boolean
  expression (see further below)?  Problem is that this will look like
  a normal expression and defeat pattern matching unless I treat it
  specially.  I suppose I could look for this as a top-level pattern,
  but I'm not sure how it would be parsed; is that reliable?
- Idea with variables @@x is a variable that's bound in a pattern, but
  you drop the @@ part inside the body.  Need to reject such variables
  outside of patterns (presumably doing the same as I would for _
  outside of patterns).
- Add record patterns and C patterns; see below.

NOTES

A description of the design I have in mind is at the bottom of this
file (search for DESIGN).  These are notes about the implementation of
said design.

======================================================================

LIMITATIONS

* Scoping is a little busted.  I declare all bound variables at the
outset of the switch statement.  For example, if you had

@local x,z;
x = 5; z = 0;
switch (e) {
case [y] : z = y+x; break;
case [x,y...] : z = x; break;
default: break;
}

In my current implementation, if e == [1] then we'll get an error that
x is not initialized.  You would expect that the result would be z =
6, since we assume that z = y+x amounts to z = 1+5, as x would be the
outer local.  What's happening is that this x is being shadowed by a
declaration for the x bound in the second case of the switch.

The reason for this is that I'm not sure how to define the scope of
the expression list between cases.  Perhaps there could be some pass
prior to this one that gathers up all expressions between cases and
sticks them in a block attached directly to the case.  Then you could
declare the variables at the start of this block.

======================================================================

** Cyclone pattern compilation (v0.8.1):

Workflow:
 tc @ tc.cyc ==>
   tcStmt @ tcstmt.cyc ==>
   case for Switch_s:
     if matching on a non-variable (i.e., switch (foo()) as opposed
       to switch(x)), introduce a temp
     For each arm of the pattern match, in order,
       Call tcPat @ tcpat.cyc ==>
         check pattern; this produces a tc_pat_result which is checked
         by pattern_synth; but I think this is only for type checking
     Call check_switch_exhaustive @ tcpat.cyc ==> 
       fills in the decision tree of the expression, which is used
       later in pattern compilation 
 toc @ toc.cyc ==>
   stmt_to_c @ toc.cyc ==>
     xlate_switc @ toc.cyc ==>
       This is given the expression being switched on, the list of 
       switch clauses, and the decision tree.  Calls
       compile_decision_tree @ toc.cyc.

 Note that this is based on a paper by Peter Sestoft.  Look for
 comment in tcpat.cyc toward the bottom of the file.  Made it up to
 section 4 in this paper.  I can see that the names of functions and
 the basic datastructures used are the same, but they are much more
 complicated in Cyclone!  Probably I should just try to understand
 the Sestoft paper on its own and not look here, for now.

======================================================================

DESIGN: PATTERNS IN SWITCH STATEMENTS

I propose we follow Cyclone's syntax for C-like pattern matching,
which piggybacks on the switch statement.  In particular, the syntax
would be

switch (E) {
 case P1 && E1: S1
 case P2 && E2: S2
 ...
 default: SN
}

where E is an expression; P1, P2, etc. are patterns; E1, E2, etc. are
expressions of type int (interpreted as booleans); and S1, S2, etc are
statements.  Unification variables occurring in Pi are bound in Ei and
Si.  There are some restrictions on this form, e.g., with respect to
falling through the Si.  Otherwise, it seems this is compatible with
Cqct as it stands now (according to the cqctworld.org manual).  Here
is a simple example:

 switch (f()) {
   case 5: return 0;
   case n && n > 1: return n;
   default: return -1;
 }

This code pattern matches the call f(); if the result is 5 it returns
0; if it's a positive integer then it is bound to n and returned;
otherwise, 0 is returned.  

That's the basic idea.  The next interesting question is form of the
patterns Pi and how binding is handled; these are considered below.
Note that patterns are NOT first class in the above; and indeed it
wouldn't necessarily make sense for them to be so, to have the best
possible binding semantics.  Thoughts on first-class patterns for
handling breakpoints at the bottom of the document.

Details on Cyclone pattern matching, and in particular the
restrictions, given here

http://cyclone.thelanguage.org/wiki/Switch%20Statements


BASIC PATTERN FORMS

The pattern language ought to look at least something like this:

P ::= 
      id                  pattern variable
    | _                   wilcard pattern
    | [L]                 nonempty list pattern
    | []                  empty list pattern
    | [T]                 nonempty table pattern
    | [ : ]               empty table pattern
    | e                   any expression

L ::= 
      P                   single element list
   |  P ...               list tail (last pattern must be a variable)
   |  P,L                 multi element list (may include unlimited tail)

T ::=
      e:P                 key/val pair (e must not contain binders)
      e:P,T               more than one k/v pair

Notice that for tables, keys are not permitted to be binders; this
would be too inefficient and ambiguous.  For lists with ellipsis (...)
the last pattern of the list must be a variable, which is bound to the
tail of the list.

Patterns may not contain duplicate variables, though they may contain
more than one wildcard.

Later we can extend patterns to include ordered records:

P ::= 
    | id(P1,...,Pn[,...]) ordered record pattern
    | id(id=P1,...,id=Pn) named record pattern

The ordered record pattern requires a trailing ellipsis if the record
being matched does not have all of the listed fields.  For the named
record pattern we don't need this since listing the names implicitly
projects them, and hopefully is not confusing (whereas matching (X,Y)
for a three-element record is more confusing then (X,Y,...)).

Missing from this syntax is support for vectors separate from lists
(maybe reuse the same syntax?) and file descriptors (maybe just treat
as integers?).  Also missing, and more interesting, is support for
symbols, domains, namespaces, etc.  Will touch on that shortly.

Examples:

@define list_length(x) {
 @local n = 0;
 while (1) {
   switch (x) {
   case []: return n;
   case [_,T ...]: n = n+1; x = T;
   }
 }
}

@define third(x) {
 switch (t) {
 case [_,_,X,_ ...]: return X;
 default: return 0;
 }
}

Example for extensions:

@record myrec { field1, field2, field3 }

@define foo(r) {
 switch (r) {
 case {X,Y,0}: return X+Y;
 case {X,Y,Z}: return (X+Y)/Z; 
 }
}

@define bar(r) {
 switch (r) {
 case { field3 = N } && N > 5 : return 0;
 case { field1 = N1, field3 = N3 } : return N1+N3;
 case { _, N, ... } : return N;
 }
}


CQCT-SPECIAL PATTERN FORMS

The main thing to deal with here is matching C values, and matching
symbols.  For the latter in the simplest case we can extend the
language of constants to include `id and id`id; i.e., we can match
against particular values in their domain.  More interesting would be
to match against a value of C structured type and extract some of its
contents in the pattern.  E.g., suppose I have a C type struct Pair {
int fst; int snd; }, then I might do:

 switch (s) {
 case dom`Pair{.fst = X; .snd = Y;}:
   return X + Y
 }

That is, the pattern projects out the two field values from the object
and adds them up.  Should we have ` on the field names too?

I propose, again, that we follow Cyclone's pattern forms for C syntax,
by and large.  The tricky thing is that we have to make this syntax
relative to namespaces.

Details on Cyclone pattern forms here:

http://cyclone.thelanguage.org/wiki/Pattern%20Forms


FIRST-CLASS PATTERNS

We want first-class patterns for setting breakpoints, e.g., on
the shape of stacks.  Perhaps we'd want something like this:

brk(@pat(P && E)),
   @lambda(X1,...,Xn) {...})

Here, the argument to @pat() is a pattern arm as found in the switch
statement above, such that all pattern variables bound in the pattern
may appear in E.  Then if the stack matches this pattern, the lambda
expression is executed with its variables X1,...,Xn bound to the bound
pattern variables in the pattern.  Tricky here: need clear ordering of
variables to match them up with the lambda.  So maybe not a great
idea.  Perhaps better to tie the names directly and have built in
language support?  Even moreso since I'm not sure @pat() is useful for
anything other than breakpoints.
