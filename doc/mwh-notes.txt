TO DO

- Deal with fall-through when we've bound stuff
  - Make sure we end with a break or somesuch?
- Fix scoping problem.  Idea for fix:

  Implement a pre-pass, prior to the cases() pass that groups together
  adjacent elements of an Eelist into a single block.  So if we had
  ((case e1 e2) e3 e4 (case e5 e6) ...) we would convert this to
  ((case e1 (e2 e3 e4)) (case e5 (e6 ...))).  It's possible I can do
  this in the cases() pass itself, I'm not sure.  But we need to
  account for nested switches, as it does, so we don't end one case
  expression block with the beginning of a case in a nested switch.
  Once this prepass is complete, we can just declare the local
  variables at the point of the case since we know that when we see a
  (case e1 e2) that e2 is the entire block for the case. 

TO DO LATER

- Consider allowing ellipsis immediately following a comma, to
  indicate a tail that you don't need to bind (basically, shorthand
  for _ ...)
- Generalize pattern syntax to be p && e where e is a boolean
  expression (see further below)?  Problem is that this will look like
  a normal expression and defeat pattern matching unless I treat it
  specially.  I suppose I could look for this as a top-level pattern,
  but I'm not sure how it would be parsed; is that reliable?
- Idea: variables ^^x in a pattern are emphasize they are NOT binders,
  but rather should inherit from the outer scope.  Should only affect
  pattern matching---any occurrence of ^^x elsewhere in the program is
  just treated as x, undecorated.  (Could implement this latter
  semantics by translating these occurrences to their originals after
  the pattern matching pass, as a separate pass.)
- Add record patterns and C patterns; see below.

NOTES

A description of the design I have in mind is at the bottom of this
file (search for DESIGN).  These are notes about the implementation of
said design.

======================================================================

LIMITATIONS

* Scoping is a little busted.  I declare all bound variables at the
outset of the switch statement.  For example, if you had

@local x,z;
x = 5; z = 0;
switch (e) {
case [y] : z = y+x; break;
case [x,y...] : z = x; break;
default: break;
}

In my current implementation, if e == [1] then we'll get an error that
x is not initialized.  You would expect that the result would be z =
6, since we assume that z = y+x amounts to z = 1+5, as x would be the
outer local.  What's happening is that this x is being shadowed by a
declaration for the x bound in the second case of the switch.

The reason for this is that I'm not sure how to define the scope of
the expression list between cases.  Perhaps there could be some pass
prior to this one that gathers up all expressions between cases and
sticks them in a block attached directly to the case.  Then you could
declare the variables at the start of this block.

======================================================================

** Cyclone pattern compilation (v0.8.1):

Workflow:
 tc @ tc.cyc ==>
   tcStmt @ tcstmt.cyc ==>
   case for Switch_s:
     if matching on a non-variable (i.e., switch (foo()) as opposed
       to switch(x)), introduce a temp
     For each arm of the pattern match, in order,
       Call tcPat @ tcpat.cyc ==>
         check pattern; this produces a tc_pat_result which is checked
         by pattern_synth; but I think this is only for type checking
     Call check_switch_exhaustive @ tcpat.cyc ==> 
       fills in the decision tree of the expression, which is used
       later in pattern compilation 
 toc @ toc.cyc ==>
   stmt_to_c @ toc.cyc ==>
     xlate_switc @ toc.cyc ==>
       This is given the expression being switched on, the list of 
       switch clauses, and the decision tree.  Calls
       compile_decision_tree @ toc.cyc.

 Note that this is based on a paper by Peter Sestoft.  Look for
 comment in tcpat.cyc toward the bottom of the file.  Made it up to
 section 4 in this paper.  I can see that the names of functions and
 the basic datastructures used are the same, but they are much more
 complicated in Cyclone!  Probably I should just try to understand
 the Sestoft paper on its own and not look here, for now.

======================================================================

DESIGN: PATTERNS IN SWITCH STATEMENTS

I propose we follow Cyclone's syntax for C-like pattern matching,
which piggybacks on the switch statement.  In particular, the syntax
would be

switch (E) {
 case P1 && E1: S1
 case P2 && E2: S2
 ...
 default: SN
}

where E is an expression; P1, P2, etc. are patterns; E1, E2, etc. are
expressions of type int (interpreted as booleans); and S1, S2, etc are
statements.  Unification variables occurring in Pi are bound in Ei and
Si.  There are some restrictions on this form, e.g., with respect to
falling through the Si.  Otherwise, it seems this is compatible with
Cqct as it stands now (according to the cqctworld.org manual).  Here
is a simple example:

 switch (f()) {
   case 5: return 0;
   case n && n > 1: return n;
   default: return -1;
 }

This code pattern matches the call f(); if the result is 5 it returns
0; if it's a positive integer then it is bound to n and returned;
otherwise, 0 is returned.  

That's the basic idea.  The next interesting question is form of the
patterns Pi and how binding is handled; these are considered below.
Note that patterns are NOT first class in the above; and indeed it
wouldn't necessarily make sense for them to be so, to have the best
possible binding semantics.  Thoughts on first-class patterns for
handling breakpoints at the bottom of the document.

Details on Cyclone pattern matching, and in particular the
restrictions, given here

http://cyclone.thelanguage.org/wiki/Switch%20Statements


BASIC PATTERN FORMS

The pattern language ought to look at least something like this:

P ::= 
      id                  pattern variable
    | _                   wilcard pattern
    | [L]                 nonempty list pattern
    | []                  empty list pattern
    | [T]                 nonempty table pattern
    | [ : ]               empty table pattern
    | e                   any expression

L ::= 
      P                   single element list
   |  P ...               list tail (last pattern must be a variable)
   |  P,L                 multi element list (may include unlimited tail)

T ::=
      e:P                 key/val pair (e must not contain binders)
      e:P,T               more than one k/v pair

Notice that for tables, keys are not permitted to be binders; this
would be too inefficient and ambiguous.  For lists with ellipsis (...)
the last pattern of the list must be a variable, which is bound to the
tail of the list.

Patterns may not contain duplicate variables, though they may contain
more than one wildcard.

Later we can extend patterns to include ordered records:

P ::= 
    | id(P1,...,Pn[,...]) ordered record pattern
    | id(id=P1,...,id=Pn) named record pattern

The ordered record pattern requires a trailing ellipsis if the record
being matched does not have all of the listed fields.  For the named
record pattern we don't need this since listing the names implicitly
projects them, and hopefully is not confusing (whereas matching (X,Y)
for a three-element record is more confusing then (X,Y,...)).

Missing from this syntax is support for vectors separate from lists
(maybe reuse the same syntax?) and file descriptors (maybe just treat
as integers?).  Also missing, and more interesting, is support for
symbols, domains, namespaces, etc.  Will touch on that shortly.

Examples:

@define list_length(x) {
 @local n = 0;
 while (1) {
   switch (x) {
   case []: return n;
   case [_,T ...]: n = n+1; x = T;
   }
 }
}

@define third(x) {
 switch (t) {
 case [_,_,X,_ ...]: return X;
 default: return 0;
 }
}

Example for extensions:

@record myrec { field1, field2, field3 }

@define foo(r) {
 switch (r) {
 case {X,Y,0}: return X+Y;
 case {X,Y,Z}: return (X+Y)/Z; 
 }
}

@define bar(r) {
 switch (r) {
 case { field3 = N } && N > 5 : return 0;
 case { field1 = N1, field3 = N3 } : return N1+N3;
 case { _, N, ... } : return N;
 }
}


CQCT-SPECIAL PATTERN FORMS

The main thing to deal with here is matching C values, and matching
symbols.  For the latter in the simplest case we can extend the
language of constants to include `id and id`id; i.e., we can match
against particular values in their domain.  More interesting would be
to match against a value of C structured type and extract some of its
contents in the pattern.  E.g., suppose I have a C type struct Pair {
int fst; int snd; }, then I might do:

 switch (s) {
 case dom`Pair{.fst = X; .snd = Y;}:
   return X + Y
 }

That is, the pattern projects out the two field values from the object
and adds them up.  Should we have ` on the field names too?

I propose, again, that we follow Cyclone's pattern forms for C syntax,
by and large.  The tricky thing is that we have to make this syntax
relative to namespaces.

Details on Cyclone pattern forms here:

http://cyclone.thelanguage.org/wiki/Pattern%20Forms


FIRST-CLASS PATTERNS

We want first-class patterns for setting breakpoints, e.g., on
the shape of stacks.  Perhaps we'd want something like this:

brk(@pat(P && E)),
   @lambda(X1,...,Xn) {...})

Here, the argument to @pat() is a pattern arm as found in the switch
statement above, such that all pattern variables bound in the pattern
may appear in E.  Then if the stack matches this pattern, the lambda
expression is executed with its variables X1,...,Xn bound to the bound
pattern variables in the pattern.  Tricky here: need clear ordering of
variables to match them up with the lambda.  So maybe not a great
idea.  Perhaps better to tie the names directly and have built in
language support?  Even moreso since I'm not sure @pat() is useful for
anything other than breakpoints.
