<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Debugging with Cinquecento</title>
<link rel="stylesheet" type="text/css" href="reset.css"/>
<link rel="stylesheet" type="text/css" href="styles.css"/>
</head>

<body>

<div id="side1">
<a href="#sec:introduction">Introduction</a><br />
<br />
<a href="#sec:ns">Name spaces</a><br />
<a href="#sec:ctls">Controlling executions</a><br />
<a href="#sec:nsmap">Name space maps</a><br />
<a href="#sec:sctlns">Interface to sctl</a><br />

<br />
<a href="#sec:fnindex">Index</a><br />

</div>

<div id="content">

<div id="title">
<h3>Debugging with Cinquecento</h3>
</div>

<h4 id="sec:introduction">Introduction</h4>

<p>
This manual describes how to use the Cinquecento
<span class="id">debug</span> library to examine
program executables and program executions.
</p>

<p>
The debug library is a client of the services
of <span class="val">sctl</span>, a server for
controlling program executions and accessing symbols
and other debugging information from program binaries.
To use this library you must have
the <span class="val">sctl</span> binary installed in
your path.
<span class="val">Sctl</span> is available
from <span class="val"><a href="http://cqctworld.org">cqctworld.org</a></span>.
Documentation for <span class="val">sctl</span>
accompanies its distribution, and should be read in
conjunction with this manual.
</p>

<p>
Keep in mind that the syntax and core abstractions of
the Cinquecento language are intended to support a
variety of styles for programming a custom debugger.
The libraries described in this manual represent just
one style &mdash; a rather traditional one.
</p>

<h4 id="sec:hello">Concepts</h4>

<p>
The <span class="id">debug</span> library is designed
to support a spectrum of debugging activities &mdash;
from debugging one instance of a single-threaded
program execution, to debugging multiple simultaneously
active instances of one or several multi-threaded
programs.  In all cases, the central abstraction
managed by the library is an object called
a <em>ctl</em>, which represents a thread of execution.
A single-threaded program execution is represented by a
single ctl that corresponds to the process; a
multi-threaded program execution is represented by a
set of ctls, one for each thread in the process.  Ctls
are created by launching a new program execution or
attaching to an existing one; they are also created
when an execution associated with an existing ctl forks
a new process or creates a new thread.  Ctls are
destroyed when the associated thread or process is
terminated.
</p>

<p>
Each ctl provides access to resources associated with
an execution, including its registers, address space,
and name spaces for each binary file (executable or
library) loaded in the address space.
</p>

<p>
Each ctl is also an interface for setting traps on
execution events.  The events that can be trapped
include execution breakpoints, library loading and
unloading, system calls, signals, and termination.
</p>

<p>
The programming model is event-based programming.
Rather than pausing the execution and interactively
inspecting state or adding or removing traps, programs
written with this library are non-interactive programs
that instrument an entire execution of the target
program.  They respond to events as the execution
proceeds, collecting observations, adjusting traps, and
perhaps making changes to program state.  The
interactive model can be convenient for debugging
single-threaded programs, but it quickly becomes
cumbersome when the program is multi-threaded, or when
more than one program is being debugged at a time, or
when incorporating snapshots into the debugging.
</p>

<p>
Like many event-based programming system, the execution
of a program is wrapped in a blocking event loop.
Events from program execution are received and
dispatched to their handlers.  This event processing
loop is encapsulated in an object called a <em>sctlmux</em>.
Most programs have the same structure:
<ol>
<li>Initialize a sctlmux.</li>
<li>Launch or attach to one or more programs, yielding a corresponding ctl for each thread of execution.</li>
<li>Define and install handlers for various events on the ctls.</li>
<li>Start the sctlmux event loop.</li>
</ol>
</p>

<p>
Event handlers typically collect observations about the
program execution.  They can also set or remove event
handlers.  The event loop terminates when all ctls have
exited.
</p>

<p>
<span class="val">Sctl</span> supports execution
snapshots, which represent the state of a program
execution frozen in time.  Snapshots are useful for
retaining access to past states of program execution
for comparison with future states.  A snapshot is
represented by a ctl.
</p>



<h4 id="sec:hello">Getting started</h4>

<p>
In the following sections, we illustrate the main
features of the library through a series of examples.
This requires that we have some sample programs to
debug.  These samples, as well as the Cinquecento
examples, are included in the L1 distribution of
Cinquecento; see the <span class="val">README</span> in
the <span class="val">demo</span> directory for
directions on building and running these examples
yourself.
</p>

<p>
Here is <span class="val">list</span>, our first sample program:
</p>

@@include(../demo/list.c)

<p>
This program features a pointer-based linked list data
type called <span class="val">Node</span>, a function
called <span class="val">insert</span> that appends new
elements to an existing list, a function
called <span class="val">dowork</span> that builds a
list of consecutive values, and
a <span class="val">main</span> function that begins
the work.  It accepts an optional command-line argument
that specifies the number of elements in the final
list.  It has no output.
</p>

<p>
Here is a Cinquecento function that launches this
program and waits for it to exit:
</p>

@@function(../demo/examples.cqct:getstarted)

<p>
The first line loads the debugging library.  We will
omit this line from all subsequent examples, but it is
always implied.
</p>

<p>
The first line of <span class="id">getstarted</span>
(after the <span class="id">@local</span> declaration)
creates a new sctlmux object, binding it to the
variable <span class="id">mux</span>.  <span class="id">Mux</span>
represents a connection to a fresh sctl server that is
launched by <span class="id">mksctlmux</span> on the
same host as the Cinquecento program.
</p>

<p>
The second line of <span class="id">getstarted</span> launches our sample
program.  Ctllaunch directs the sctl associated with
<span class="id">mux</span> to create a new process.
The second argument specifies the command this new
process should execute, in a manner similar to the list
of strings passed to <span class="id">execve</span> on
Unix systems.  In this case, we are launching the list
binary from the current working directory, passing it
no arguments.
</p>

<p>
<span class="id">Ctllaunch</span> returns a ctl
representing the new program execution.  We
conventionally bind this value to a variable named
<span class="id">ctl</span>, but since this example
does not do anything with this value, we have left it
out.
</p>

<p>
<span class="id">Ctllaunch</span> leaves the new program execution in a stopped
state, paused just before execution of its first instruction.
Note that most programs perform many initialization
functions before reaching the first instruction of
main, such as initializing the dynamic loader, loading
and initializing library dependencies, and so on.
<span class="id">Ctllaunch</span> pauses the new
execution truly at the first instruction of this
initialization.
</p>

<p>
The third line of <span class="id">getstarted</span>
starts the execution by starting the sctl mux event
loop.  The run method tells the mux to resume the
program launched by the ctllaunch and to block until it
has exited.  If we had launched more than one program
with additional calls to ctlmux, these would all be
resumed simultaneously, and the call to run would block
until they all exited.  If we had registered any
handlers for executions events, as we will do in all of
the following examples, the mux would dispatch these
events in the context of the call to run.
</p>

<p>
In summary, calling getstarted launches our sample program
and waits for it to exit.  It yields no output.
</p>

@@eval(../demo/examples.cqct:getstarted)

<p>
Many debugging programs focus on the code and data of
the program executable (rather than its libraries).
The <em>exe domain</em> is a domain whose address space
is the process memory and whose name space represents
the symbols and types of the executable.  The exe
method of a ctl object returns an exe domain.
</p>

<p>
To reduce boilerplate code in subsequent examples, we
will use the following function to launch our sample
programs:
</p>

@@function(../demo/examples.cqct:start)

<p>
This function:
<ol>
<li>
receives the argument list to pass to ctlaunch as an argument,
</li>
<li>
binds the ctl returned from ctllaunch to a variable,
</li>
<li>
obtains the exe domain from the ctl, and
</li>
<li>
returns three values: the sctlmux, the ctl, and the exe domain.
</li>
</ol>
</p>


<h4 id="sec:breakpoints">Setting breakpoints</h4>

<p>
Traps are set with the <span class="id">trap</span>
method of the ctl object.  The first argument is a
<a href="man.html#sec:cids">cid</a>
that identifies the kind of trap to set.
Depending on the kind, additional arguments may
follow to specify parameters of the trap.  The final
argument is a handler function to be called when the
event occurs.
</p>

<p>
The identifier for breakpoints
is <span class="id">brk</span>.  There is one argument,
the address at which to set the breakpoint.  Here the
function <span class="id">brkentry</span> sets
breakpoint traps on the entry point of three functions
in <span class="id">list</span>.
</p>

@@function(../demo/examples.cqct:brkentry)

<p>
The expression <span class="val">&exe`main</span> and
the others like it use the exe domain to obtain the
address of functions in the executable.  The handlers
are called as execution reaches these addresses.
</p>

@@eval(../demo/examples.cqct:brkentry)

<p>
As illustrated in the
output, <span class="val">brkentry</span> returns only
after the call to the <span class="val">run</span>
method of <span class="val">mux</span>, which in turn
returns when the target program execution terminates.
</p>

<p>
The function that handles the breakpoint receives as
its argument the ctl representing the execution in
which the event occurred.  Handlers can use this
argument to access the state of the execution at the
moment of the event.
</p>

<h4 id="sec:breakpoints">Accessing registers</h4>

<p>
The current values of the registers are available in an
value called a <em>context</em>, which is returned by
the <span class="id">ctx</span> method of a ctl.
</p>

<p>
A context is a pointer to a value of type
<span class="id">Ctx</span>,
a <span class="id">typedef</span> for a structure type
that defines fields for each machine register, plus
generic aliases for the program counter
(<span class="id">pc</span>), stack pointer
(<span class="id">sp</span>), and frame pointer
(<span class="id">fp</span>) registers.
</p>

@@function(../demo/examples.cqct:ctx1)
@@eval(../demo/examples.cqct:ctx1)

<p>
For each ctl, the debugging library automatically
selects a definition of <span class="id">Ctx</span>
suitable for the target machine, along with other
machine and system dependencies, such as the
mapping from system call number to name.  All of these
dependencies are captured in a record called
the <em>dialect</em> of the ctl, which is returned by
its <span class="id">dialect</span> method.
</p>

<p>
The dialect record includes a convenience function
called <span class="id">dumpctx</span> that prints the
names and values of commonly referenced
machine-specific fields of
a <span class="id">Ctx</span>.  Here is usage on a
64-bit x86 target.
</p>

@@function(../demo/examples.cqct:ctx2)
@@eval(../demo/examples.cqct:ctx2)

<p>
<span class="id">Ctx</span> is just an ordinary ctype.
Its full definition can be revealed with
the <span class="id">printtype</span> library function.
</p>

@@function(../demo/examples.cqct:ctx3)
@@eval(../demo/examples.cqct:ctx3)

<p>
Each context returned by <span class="id">ctx</span> is
stored in a freshly allocated address space large
enough to hold a copy of the register values.  Updates
to these values, made for example by assigning to the
fields of the context structure, are not automatically
written back to the registers in the target execution.
Use the <span class="id">setctx</span> method to
propagate an updated context to the target execution.
</p>

<h4 id="sec:args">Accessing function arguments</h4>

<p>
The debugging library does not know the calling
convention of target program functions.  The primitive
way to access function arguments is to directly apply
knowledge of the convention.
</p>

<p>
A common calling convention</a>
on <a href="http://www.x86-64.org/documentation/abi.pdf">64-bit
x86</a> Unix systems is to place the first six integer
arguments into
registers <span class="id">rdi</span>, <span class="id">rsi</span>, <span class="id">rdx</span>, <span class="id">rcx</span>, <span class="id">r8</span>,
and <span class="id">r9</span>.  Here we print the two
arguments passed to each call
to <span class="id">insert</span> on such a system.
</p>

@@function(../demo/examples.cqct:args1)
@@eval(../demo/examples.cqct:args1)

<p>
The first argument to insert is a pointer to the head
of the list being constructed by dowork; the second is
the value to be inserted.
</p>

<p>
[ Other ways to access function arguments will be
discussed in later sections (brk, rbrk, brbrk, locals).
</p>

<h4 id="sec:data">Examining data structures</h4>

<p>
We can dereference the first argument
of <span class="id">insert</span> to show the contents
of the list.
</p>

@@function(../demo/examples.cqct:args2)
@@eval(../demo/examples.cqct:args2)

<p>
The new function <span class="id">showlist</span> prints
a list given a pointer to the first element.  But the
pointer we passed to this function is not simply the
value of rdi from the context.  Instead, we perform two casting
operations to this pointer before passing it to 
<span class="id">showlist</span>:
</p>

<div class="code">
<pre>
		h = (Node*){exe}ctx->rdi;
		showlist(h);
</pre>
</div>

<p>
Reading right-to-left, the first is a use of the
<a href="man.html#cncpt:xcastdom">extended cast
operator</a> to cast the pointer value into the exe
domain.  Recall that every context is stored in a
freshly allocated address space, never the address
space of the target execution.  We cannot meaningfully
dereference rdi in this address space.  Casting it to
the exe domain allows us to dereference the value in
the address space of the target execution.
</p>

<p>
The second cast is a use of the ordinary C cast operator
to change the type of the rdi value to Node*.
As we saw we ctx3, the type of the register in a context
field is an integer type, not a pointer type.  We need
a pointer type in order to dereference.  In addition,
by casting to Node* type, the pointer type is actually
the right type for examining the fields of the structure.
</p>

<p>
The order of these cast operations is significant.  The
definition of the type Node* that we wanted is the one
from the exe domain.  When performing a type cast,
Cinquecento determines the definition of the type from
the domain of the value.  Had we switched the order of
the cast operations, we would have attempted to look up
the definition of Node* from the domain of the context
value.
</p>

<p>
The above example has what might seem like a redundant
construction of the exe domain.  We already computed
the exe domain from the start call; why not use it the
handler?  While such a usage would work today, we avoid
it as a matter of style.  We view each domain as
representing a moment in time of execution.  The exe
returned from start represents the execution domain at
the start of the execution.  The handler function, in
contrast, is called <em>each time</em> the insert
function is called -- each a different moment of time.
While today the implementation of exe domain does not
reflect this -- each domain backed by a ctl address
space always reflects the latest state of the target,
this may change in future incarnations of programming
libraries.  The snapshot domains described later
already reflect moments in time.  As a matter of style,
we recommend always thinking of domains as moment in
time.
</p>

<h4 id="sec:ret">Trapping function return</h4>

<p>
Trapping the return of a function call is trickier than
trapping the call.  We can tell that a call to a
function has occurred by trapping execution of the
instruction at its entry point, which generally happens
to be the address of the function given by the symbol
table.  However, a given function can potentially
return from any one of multiple return instructions in
its code.  Symbol tables typically do not expose any of
these locations.  How can we tell that a call has
returned?
</p>

<p>
Rather than try to find all of the return instructions
in the function, our approach is to place a single trap
at the address where the call will eventually
return,
<em>i.e.</em>, the return address <em>in the
caller</em>.  We cannot determine this address
statically; it is a dynamic value that depends on the
caller.  A convenient point at which we can determine
this value is at the entry to each call, where we can
apply our knowledge of the calling convention to read
the return address set by the caller.
</p>

<p>
Most x86 programs use the <span class="id">call</span>
instruction to transfer control to the entry point of a
function.  This instruction pushes the return address
onto the stack in conjunction with the control
transfer.  Since the stack pointer points to the most
recently pushed value, we can read the return address
by dereferencing the stack pointer.  We can then trap
the return event by placing a breakpoint on the return
address.  This should be a <em>one-shot</em> breakpoint
that we clear after it fires, since the next return
event may be from a different call site that we will
discover by repeating this process.
</p>

<p>
Here we extend <span class="id">args2</span> to show
how the list changes across each call
to <span class="id">insert</span>.
</p>

@@function(../demo/examples.cqct:brkreturn)
@@eval(../demo/examples.cqct:brkreturn)

<p>
This example demonstrates several techniques that
combine to trap the return of each call
to <span class="id">insert</span>.

We set a trap on the entry
to <span class="id">insert</span>.  The handler reads
the return address by casting the stack pointer into
the exe domain.  Since this dereference should yield an
address, the stack pointer is cast
to <span class="id">void**</span>.
We then set a breakpoint on the return address.
To make this breakpoint a one-shot breakpoint,
we capture the trap identifier returned
by the trap method.  In the handler for the trap,
we clear the trap so that it does not fire again
without a corresponding new call to the function.
Finally, we print the return value of the function,
again by applying our knowledge of the calling convention,
specifically that integer return values are placed
in rax.
</p>

<p>
Unfortunately, this approach is not completely robust.
It can be defeated in at least two scenarios:
</p>

<ol>
<li>Recursion.  If multiple calls to the function occur
from the same call site before any of them return, then
the above technique will accumulate a one-short return
address trap for each of the calls, and trigger all of
them upon the first return.
</li>
<li>Non-standard calling convention.  The technique
assumes that we know where the return address is stored
upon function entry, and that we know where the return
value is stored upon function return.
</li>
</ol>

<p>
Addressing these limitations involves complex
techniques and additional dependencies.  For debugging
scenarios in which these potential limitations are not
realities, the above technique is good enough.
</p>

<h4 id="sec:brbrk">Convenience functions</h4>

<p>
While the preceding examples illustrate fundamental
usage of the debug library, they represent a tedious
and low-level approach to the frequently performed task
of trapping function call and return events.
</p>

<p>
The debug library provides three convenience functions
that simplify function call and return event
programming.  These functions have three advantages
over the previous approach.
</p>

<ol>
<li>
Arguments and return values are made directly
available to handler functions.  They have the correct
type and, for pointer values, may be dereferenced.
</li>
<li>
The user is not required to remember how the calling convention works.
</li>
<li>
For return events, they handle the setting and clearing
of the one-shot breakpoint.
</li>
</ol>

<p>
These functions take advantage of parameter and return
value type information recorded in the name space in
which the function being trapped is described.  If this
type information is not available, these functions will
not expose the arguments or return value of the call
event.  Similarly, these functions assume that the
function observes the commonly used calling convention
for the platform; they will misbehave if it is does
not.
</p>

<p>
The function <span class="id">brk</span> sets a trap
for call events.  Its arguments are the ctl to
instrument, the address of a function, and a handler
function.  When the call event occurs, the arguments
passed to the handler function are the ctl, followed by
a copy of each of the arguments that were passed to the
trapped function, if any.  Each argument has the same
type as the corresponding parameter in the function
prototype, and each argument is cast into the domain of
the execution, allowing it to be directly dereferenced.
The return value of the handler is ignored.
</p>

@@function(../demo/examples.cqct:brkexample)
@@eval(../demo/examples.cqct:brkexample)

<p>
The function <span class="id">rbrk</span> sets a trap
for return events.  Its arguments are the ctl to
instrument, the address of the function, and a handler
function.  When the return event occurs, the arguments
passed to the handler function are the ctl, followed by
a copy of the return value of the trapped function, if
any.  The return value of the handler is ignored.
</p>

@@function(../demo/examples.cqct:rbrkexample)
@@eval(../demo/examples.cqct:rbrkexample)

<p>
The function <span class="id">brbrk</span> combines the
functionality of <span class="id">brk</span>
and <span class="id">rbrk</span>.  Its arguments are
the ctl to instrument, the address of the function, and
a handler function for the <em>call</em> event.  This
handler is called in the same manner as the
<span class="id">brk</span> handler, except that it may
return a return event handler that, when the trapped
function call returns, will be called in the same
manner as the <span class="id">rbrk</span> handler.  If
instead the call event handler returns
<span class="id">nil</span>, then the return event is ignored.
</p>

@@function(../demo/examples.cqct:brbrkexample)
@@eval(../demo/examples.cqct:brbrkexample)

<h4 id="sec:breakpoints">Unwinding the stack</h4>

<p>
The <span class="id">unwind</span> method of a ctl
unwinds the call stack.  It returns a list of contexts,
one for each stack frame, each representing the state
of the registers at the time of the corresponding call.
This state includes the return address, stack pointer,
and frame pointer of the corresponding call.  If
sufficient debugging information is available (such as
DWARF unwind tables), the contexts may also reflect the
other saved registers suitable for recovering the
values of local variables stored in registers.
</p>

<p>
The convenience
function <span class="id">fmtframe</span> convents a
call frame context into a textual representation of the
call site, including the program counter value, the
name of and offset within the caller, and the file name
and line number of the call site in source code.
</p>

@@function(../demo/examples.cqct:unwind)
@@eval(../demo/examples.cqct:unwind)

<h4 id="sec:breakpoints">Accessing local variables</h4>

<p>
Every valid context corresponds to a point in program
execution in which a certain set of local variables are
defined.  Given a valid context, the ctl
method <span class="id">ldom</span> makes available the
names, types, location, and values of its associated
local variables as a dynamically constructed <em>local
domain</em>.  The local domain is like any other
domain, except that its name space is limited to local
variables.
</p>

<p>
The contexts returned by <span class="id">unwind</span>
are each suitable arguments
for <span class="id">ldom</span>.  However, 
<span class="id">ldom</span> depends on the presence of
sufficient debugging information in the binary, both to
ensure that the context includes saved register values,
as well as information about local variable names,
types, and locations.
</p>

@@function(../demo/examples.cqct:locals)
@@eval(../demo/examples.cqct:locals)


<h4 id="sec:breakpoints">Trapping program termination</h4>

<h4 id="sec:breakpoints">Modifying data structures</h4>

<h4 id="sec:breakpoints">Trapping signals</h4>

<h4 id="sec:breakpoints">Trapping system calls</h4>

<h4 id="sec:breakpoints">Trapping fork</h4>

<h4 id="sec:breakpoints">Trapping exec</h4>

<h4 id="sec:breakpoints">Tracing multithreaded execution</h4>

<h4 id="sec:breakpoints">Using snapshots</h4>


<h4 id="sec:ns">Name spaces</h4>

<p>
The debug library defines two functions for constructing
Cinquecento name spaces backed by a sctl server:
</p>

<div class="docitem" id="fn:atnames">
<div class="proto">
<div class="function">
<span class="id">atnames(<span class="arg">path</span>)</span>
</div>
<div class="param">
<span class="arg">path</span>: <span class="type">string</span>
</div>
<div class="returns">
<span class="type">name space</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Returns a name space for the binary
named <span class="arg">path</span>.  The name space is
served by a freshly
launched <span class="val">sctl</span> server on the
calling machine.  The <span class="val">sctl</span>
binary must be in the path of the calling process.
Returns <span class="val">nil</span> if the name space
does not exist.
</div>
</div>

<div class="docitem" id="fn:mksctlns">
<div class="proto">
<div class="function">
<span class="id">mksctlns(<span class="arg">fd</span>,<span class="arg">path</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">path</span>: <span class="type">string</span>
</div>
<div class="returns">
<span class="type">name space</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Returns a name space for the binary
named <span class="arg">path</span>.  The name space is
served by the <span class="val">sctl</span> server
backed by <span class="arg">fd</span>.  The version negotiation
with the sctl server must be performed by calling this function
(see <span class="fnindex"><a href="#fn:sctlversion">sctlversion</a></span>).
Returns <span class="val">nil</span> if the name space
does not exist.
</div>
</div>

<h4 id="sec:ctls">Controlling executions</h4>

<p>
The debug library is designed around a programming
model that is different from the conventional
interactive programming.  It is an event-based
programming model.  It requires an interface for
running the event loop.  This is accomplished
with something called a sctlmux.
</p>

<p>
A ctl represents a thread of execution.
There is an address space, called a mem,
that represents its memory.
There is a notion of its context
that represents the registers
of the system.  Get a pointer
into it.  You can update the context
by changing the values of pointers.
(This needs to be implemented.)
(No setctx method.)
</p>

<div class="docitem" id="fn:mksctlmux">
<div class="proto">
<div class="function">
<span class="id">mksctlmux()</span>
</div>
<div class="returns">
<span class="type">sctlmux</span>
</div>
</div>
<div class="desc">
Returns a new sctlmux backed by a sctl server
freshly launched on the calling machine.
</div>
</div>

<div class="docitem" id="fn:ctllaunch">
<div class="proto">
<div class="function">
<span class="id">ctllaunch(<span class="arg">mux</span>,<span class="val">cmd</span>)</span>
</div>
<div class="param">
<span class="arg">mux</span>: <span class="type">sctlmux</span>
</div>
<div class="param">
<span class="arg">cmd</span>: <span class="type">list of string</span>
</div>
<div class="returns">
<span class="type">ctl</span> or
<span class="type">nil</span> or
</div>
</div>
<div class="desc">
Launches a new program execution, returning
a <span class="val">ctl</span> representing the
execution.  <span class="arg">Cmd</span> is the list
arguments used to run the program; <em>i.e.</em>, on
Unix-based targets these strings are passed
to <span class="id">exec</span>,
with <span class="arg">cmd</span><span class="val">[0]</span>
becoming <span class="val">argv[0]</span>, and so on.
</div>
</div>

<p>
There is currently no way to specify a different environment
to the launched program, or to redirect its I/O.
</p>

<p>
Each ctl is a record that exports the following methods:
</p>


<div class="docitem" id="fn:ctlid">
<div class="proto">
<div class="function">
<span class="id">id()</span>
</div>
<div class="returns">
<span class="type">cvalue</span>
</div>
</div>
<div class="desc">
Returns a numeric identifier for the ctl.
</div>
</div>

<div class="docitem" id="fn:ctlexe">
<div class="proto">
<div class="function">
<span class="id">exe()</span>
</div>
<div class="returns">
<span class="type">domain</span>
</div>
</div>
<div class="desc">
Returns a domain representing the executable of
the ctl.
</div>
</div>

<div class="docitem" id="fn:ctlctx">
<div class="proto">
<div class="function">
<span class="id">ctx()</span>
</div>
<div class="returns">
<span class="type">context</span>
</div>
</div>
<div class="desc">
Returns the current context of the ctl.
The context is represented as a pointer
into a domain that is a buffer backed
by the remote register set.  This weakly
consistent: when the ctl is stopped
(i.e., in a handler affecting the ctl
or in a snapshot) the view is consistent.
</div>
</div>

<div class="docitem" id="fn:ctldetach">
<div class="proto">
<div class="function">
<span class="id">detach()</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Releases control of the target execution.
The execution resumes, but future operations on
the ctl are invalid.
</div>
</div>

<div class="docitem" id="fn:ctlkill">
<div class="proto">
<div class="function">
<span class="id">kill()</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Like detach, but terminates the target execution
instead of resuming it.
</div>
</div>

<div class="docitem" id="fn:ctlstat">
<div class="proto">
<div class="function">
<span class="id">stat()</span>
</div>
<div class="returns">
<span class="type">record</span>
</div>
</div>
<div class="desc">
Returns a record describing status information about the remote target.
This is currently undefined and unimplemented, but should
perhaps include: pid, ppid, other proc stats, maps, dialect.
</div>
</div>

<div class="docitem" id="fn:ctlmem">
<div class="proto">
<div class="function">
<span class="id">mem()</span>
</div>
<div class="returns">
<span class="type">address space</span>
</div>
</div>
<div class="desc">
Returns an address space backed by the target process memory.
</div>
</div>

<div class="docitem" id="fn:ctlnsmap">
<div class="proto">
<div class="function">
<span class="id">nsmap()</span>
</div>
<div class="returns">
<span class="type">nsmap</span>
</div>
</div>
<div class="desc">
Returns an nsmap describing the current mappings in the target address space.
</div>
</div>

<div class="docitem" id="fn:ctlns">
<div class="proto">
<div class="function">
<span class="id">ns([<span class="arg">idx</span>])</span>
</div>
<div class="param">
<span class="arg">idx</span>: <span class="type">cvalue</span> or <span class="type">string</span>
</div>
<div class="returns">
<span class="type">name space</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Queries the current mappings in the target address
space (<em>i.e.</em>, its nsmap), returning a name
space corresponding to one of the mappings.
If <span class="arg">idx</span> is unspecified, a name
space corresponding to the executable is return.
If <span class="arg">idx</span> is a cvalue, it is
treated as an address in the target memory, and the
name space "containing" that address is returned
(as in <span class="fnindex"><a href="#fn:nsmapbyaddr">byaddr</a></span>).
If <span class="arg">idx</span> is a string, it is
treated as a string pattern; the name space whose path
name matches the pattern is returned
(as in <span class="fnindex"><a href="#fn:nsmapbyname">byname</a></span>).
If no name space matches, <span class="val">nil</span>
is returned.
</div>
</div>


<div class="docitem" id="fn:ctldom">
<div class="proto">
<div class="function">
<span class="id">dom([<span class="arg">idx</span>])</span>
</div>
<div class="param">
<span class="arg">idx</span>: <span class="type">cvalue</span> or <span class="type">string</span>
</div>
<div class="returns">
<span class="type">domain</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
The <span class="val">dom</span> method is like
the <span class="fnindex"><a href="#fn:ctlns">ns</a></span>
method, except that a freshly constructed domain is
returned instead of a name space.  The name space is
the name space returned by
the <span class="fnindex"><a href="#fn:ctlns">ns</a></span>
method on argument <span class="arg">idx</span>, and
the address space is the address returned by
the <span class="fnindex"><a href="#fn:ctlmem">mem</a></span>
method (i.e., the current address space of the target).
</div>
</div>

<div class="docitem" id="fn:ctlsnap">
<div class="proto">
<div class="function">
<span class="id">snap()</span>
</div>
<div class="returns">
<span class="type">ctl</span>
</div>
</div>
<div class="desc">
Returns a ctl representing a snapshot of the target process.
</div>
</div>

<div class="docitem" id="fn:ctlldom">
<div class="proto">
<div class="function">
<span class="id">ldom([<span class="arg">ctx</span>])</span>
</div>
<div class="param">
<span class="arg">ctx</span>: <span class="type">context</span>
</div>
<div class="returns">
<span class="type">domain</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Returns a <em>local domain</em> representing the local
variables (including function parameters) defined in
the context <span class="arg">ctx</span> of the target
process.  If <span class="arg">ctx</span> is unspecified,
the current context is used.  The name space of the
local domain includes definitions for all known local
variables.  (But say something about location information --
what kind of accesses work; what kind of casting may or may not work.)
Returns nil if a local domain cannot be constructed
for <span class="arg">ctx</span>.
</div>
</div>

<div class="docitem" id="fn:ctlunwind">
<div class="proto">
<div class="function">
<span class="id">unwind()</span>
</div>
<div class="returns">
<span class="type">list of contexts</span> or
</div>
</div>
<div class="desc">
Unwinds the current call stack of the ctl, returning
a list of contexts corresponding to each call frame.
The current call frame appears first in the list,
followed by its caller, and so on.
</div>
</div>

<div class="docitem" id="fn:ctllooksrc">
<div class="proto">
<div class="function">
<span class="id">looksrc(<span class="arg">addr</span>)</span>
</div>
<div class="param">
<span class="arg">addr</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">source record</span> or
</div>
</div>
<div class="desc">
Returns
a <span class="fnindex"><a href="#rec:srcrec">source
record</a></span> specifying the location in source
code corresponding to <span class="val">addr</span>.
</div>
</div>

<div class="docitem" id="fn:ctllookpc">
<div class="proto">
<div class="function">
<span class="id">lookpc(<span class="arg">file</span>,<span class="arg">line</span>[,<span class="arg">idx</span>])</span>
</div>
<div class="param">
<span class="arg">file</span>: <span class="type">string</span>
</div>
<div class="param">
<span class="arg">line</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">idx</span>: <span class="type">cvalue</span> or <span class="type">string</span>
</div>
<div class="returns">
<span class="type">cvalue</span>
</div>
</div>
<div class="desc">
Returns an address (program counter value)
corresponding to the source
location <span class="arg">file</span>:<span class="arg">line</span>
in the name space determined by
passing <span class="arg">idx</span> to the <span class="fnindex"><a href="#fn:ctlns">ns</a></span> method.
</div>
</div>

<div class="docitem" id="fn:ctltrap">
<div class="proto">
<div class="function">
<span class="id">trap(<span class="arg">kind</span>[,<span class="arg">arg</span>.],<span class="arg">fn</span>)</span>
</div>
<div class="param">
<span class="arg">kind</span>: <span class="type">cid</span>
</div>
<div class="param">
<span class="arg">arg</span>: varies
</div>
<div class="param">
<span class="arg">fn</span>: <span class="type">procedure</span>
</div>
<div class="returns">
<span class="type">cvalue</span>
</div>
</div>
<div class="desc">
<p>
Sets a trap on an event of various forms, specified by
the <span class="arg">kind</span> and possible
event-specific
argument <span class="arg">arg</span>.  <span class="arg">Fn</span>
is a handler to be called in reponse to the event.
Multiple handlers may be registered for the same event;
they are called in registration order.  Regardless of
the kind of event, the first argument passed to the
handler is always the ctl representing the target on
which the event occured.  Additional arguments may be
passed depending on the kind of event.  The return
value of each call to a handler is ignored.
</p>
<p>
The return value of <span class="id">trap</span> is an
unique identifier for the trap.  Passing the identifier to a call
to <span class="fnindex"><a href="#fn:ctlclear">clear</a></span>
deregisters the trap.
</p>

<p>
The available traps are listed below.  Any required
optional arguments to <span class="val">trap</span> are
named following the symbol that identifies trap kind.
</p>

<div class="bolddt-indentdd">

<dl>
<dt><span class="val">brk</span> <span class="arg">addr</span></br> <span class="val">snap</span> <span class="arg">addr</span></dt>
<dd>
Set a breakpoint or snappoint.  The handler is called when the
program counter reaches <span class="arg">addr</span> (a cvalue).
<span class="val">Snap</span> differs
from <span class="val">brk</span> in that a snapshot of
the trapping ctl is created and passed to the handler,
instead of the ctl for the trapping ctl.
On Unix systems, <span class="val">brk</span>
and <span class="val">snap</span> traps are
automatically cleared whenever the target successfully
returns from an exec system call.
</dd>

<dt><span class="val">exit</span></dt>
<dd>
Set a trap on termination.
The handler is called when the target has terminated
but before the address space has been reclaimed by the
host system.  No further execution will occur; the ctl
becomes invalid when the handler returns.
</dd>

<dt><span class="val">load</span></br><span class="val">unload</span></dt>
<dd>
Set a trap on library load or unload.  The handler is
called when the target has updated its address space by
loading or unloading a library.  Along with the ctl,
the handler is passed two additional arguments: the
path name and load address of the affected library.
The nsmap of the ctl is updated prior to calling the
handler.
</dd>

<dt><span class="val">exec</span></dt>
<dd>
Set a trap on new program execution. The
handler is called when the target has
successfully returned from the exec system
call, just before the execution of
the first instruction in the new program
image.
</dd>

<dt><span class="val">syscall</span></dt>
<dd>
Set a trap on system call entry and exit.
The handler is called whenever the target
enters or returns from a system call.
(It is up to the handler to figure out which.)
</dd>

<dt><span class="val">signal</span></dt>
<dd>
Set a trap on signals. 
The handler is called whenever a signal
is about to be posted to the target.
</dd>

<dt><span class="val">clone</span></dt>
<dd>
Set a trap on process creation.  The handler is called
when the target has spawned a new process.  Along with
the ctl that spawned the new process, the handler is
passed a new ctl representing the new process.
</dd>

</dl>
</div>

</div>
</div>


<div class="docitem" id="fn:ctlclear">
<div class="proto">
<div class="function">
<span class="id">clear(<span class="arg">id</span>)</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Clears the trap with identifier <span class="arg">id</span>.
</div>
</div>



<div class="docitem" id="fn:ctltraps">
<div class="proto">
<div class="function">
<span class="id">traps()</span>
</div>
<div class="returns">
<span class="type">list of trap records</span>
</div>
</div>
<div class="desc">
Traps returns a list of trap records describing all
currently registered traps on the ctl.

<div class="code">
<pre>
@record traprec {
	tid,      /* user-visible trap identifier */
	sid,	  /* sctl trap identifier (not for user) */
	type,	  /* type of trap */
	args,	  /* trap configuration arguments */
	fn	  /* trap handler */
};
</pre>
</div>
The system registers traps for its own internal state
management on each ctl.  These traps are revealed by
<span class="id">traps</span>, but they should not be tampered with.
</div>
</div>


<h4 id="sec:sctlns">Interfaces to sctl</h4>

<p>
For lower-level name space programming, the debug
library also provides a set of Cinquecento functions
for performing synchronous name space transactions with
a <span class="val">sctl</span> server.
</p>

<p>
The first argument to each of these functions is a file
descriptor that must be connected to a sctl server.
Generally the remaining arguments are Cinquecento data
to be encoded into the fields of the corresponding sctl
request.  Most functions return a data structure
representing the decoded payload of the corresponding
reply.
</p>

<p>
These procedures assume that the sctl server answers
each request synchronously and that it never
generates <span class="val">Aevent</span> messages.
This behavior is consistent with a sctl server that
being used to serve only name space data.
</p>

<p>
Two of the procedures, sctlenumtype and sctllooktype,
an additional name space argument.  This name space is
used by the underlying type definition decoder
(decodetdef) to resolve two aspects of type definitions
that cannot be determined from the sctl type definition
reply:
</p>

<ul>
<li>
the mapping from enumeration representation to a
corresponding base type, passed to mkctype_enum;
</li>
<li>
the representation of the pointer type, passed
to mkctype_ptr.
</li>
</ul>

<p>
For this argument, it is sufficient to pass a root name
space that is compatible with the base type definitions
of the target name space.  We consider the presence of
this argument to be a bug in the interface.
</p>

<p>
The functions are as follows:
</p>

<div class="docitem" id="fn:sctlping">
<div class="proto">
<div class="function">
<span class="id">sctlping(<span class="arg">fd</span>,<span class="arg">cnt</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">cnt</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">ping</span> transaction with the server,
sending a ping payload of <span class="arg">cnt</span> zero bytes.
An error is raised if the transaction fails.
</div>
</div>

<div class="docitem" id="fn:sctlversion">
<div class="proto">
<div class="function">
<span class="id">sctlversion(<span class="arg">fd</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">version</span> transaction with the server.
The offered version is
<div class="code">
<pre>
"sctl-2010:x86-linux-2010,x86-win-2010"
</pre>
</div>
The negotiated version string is returned.
An error is raised if the version cannot
be negotiated.
</div>
</div>

<div class="docitem" id="fn:sctlnames">
<div class="proto">
<div class="function">
<span class="id">sctlnames(<span class="arg">fd</span>,<span class="arg">path</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">path</span>: <span class="type">string</span>
</div>
<div class="returns">
<span class="type">cvalue</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">names</span> transaction, returning a name space
identifier for the name space corresponding to the binary
named <span class="arg">path</span>.
Returns <span class="val">nil</span> if the name space does not exist.
</div>
</div>

<div class="docitem" id="fn:sctllooktype">
<div class="proto">
<div class="function">
<span class="id">sctllooktype(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">typename</span>,<span class="arg">ns</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">typename</span>: <span class="type">ctype</span>
</div>
<div class="param">
<span class="arg">ns</span>: <span class="type">name space</span>
</div>
<div class="returns">
<span class="type">ctype</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">looktype</span> transaction
on the name space corresponding
to <span class="arg">nsid</span>, returning an
definition of the type
named <span class="val">typename</span>.  The resulting
definition is 
<a href="man.html#cncpt:incompletetype">incomplete</a>.
Returns <span class="val">nil</span> if there is no
matching type definition.
</div>
</div>

<div class="docitem" id="fn:sctlenumtype">
<div class="proto">
<div class="function">
<span class="id">sctlenumtype(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">ns</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">ns</span>: <span class="type">name space</span>
</div>
<div class="returns">
<span class="type">table</span>
</div>
</div>
<div class="desc">
Performs an <span class="id">enumtype</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, returning a
table mapping type names to type definitions.
The type definitions are
<a href="man.html#cncpt:incompletetype">incomplete</a>.
</div>
</div>

<div class="docitem" id="fn:sctllooksym">
<div class="proto">
<div class="function">
<span class="id">sctllooksym(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">id</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">id</span>: <span class="type">cid</span>
</div>
<div class="returns">
<span class="type">symbol</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">looksym</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, obtaining
a definition for the symbol <span class="val">id</span>.
The result is a Cinquecento symbol [reference].
Its attribute table defines <span class="val">"offset"</span>
to the <span class="arg">value</span> returned
in the <span class="id">looksym</span> reply,
<span class="val">"flags"</span> to
the <span class="arg">flags</span>,
and <span class="val">"size"</span> to
the <span class="arg">size</span>.  The symbol type is
<a href="man.html#cncpt:incompletetype">incomplete</a>.
Returns <span class="val">nil</span> if there is no matching symbol.
</div>
</div>

<div class="docitem" id="fn:sctlenumsym">
<div class="proto">
<div class="function">
<span class="id">sctlenumsym(<span class="arg">fd</span>,<span class="arg">nsid</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">table</span>
</div>
</div>
<div class="desc">
Performs an <span class="id">enumsym</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, returning
a table mapping symbol identifiers to symbol definitions.
The symbol definitions are Cinquecento symbols.
</div>
</div>

<div class="docitem" id="fn:sctllookaddr">
<div class="proto">
<div class="function">
<span class="id">sctllookaddr(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">addr</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">addr</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">symbol</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">lookaddr</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, returning
a symbol definition to which <span class="arg">addr</span> maps.
The symbol definition is a Cinquecento symbol.
Returns <span class="val">nil</span> if there is no matching symbol.
</div>
</div>

<div class="docitem" id="fn:sctlunwind1">
<div class="proto">
<div class="function">
<span class="id">sctlunwind1(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">addr</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">addr</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">list of unwind rules</span>
</div>
</div>
<div class="desc">
Performs an <span class="id">unwind1</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, returning
target-dependent stack frame unwinding rules
corresponding to the program counter value <span class="arg">addr</span>.

Each unwind rule is specified in an <span class="val">uwrulerec</span>
that is based on the encoding of the unwind rules specified by DWARF:

<div class="code">
<pre>
@record uwrulerec {
	kind,		/* rule kind */
	r,		/* register operand */
	n		/* number operand */
};
</pre>
</div>

[Reference dwarf functions that interprets these.]

</div>
</div>

<div class="docitem" id="fn:sctllooksrc">
<div class="proto">
<div class="function">
<span class="id">sctllooksrc(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">addr</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">addr</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">source record</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">looksrc</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, returning
a source record corresponding to the program
counter <span class="arg">addr</span>.

The source record is defined as follows:

<div class="code" id="rec:srcrec">
<pre>
@record srcrec {
	file,		/* file name (string) */
	line,		/* line (cvalue) */
	col,		/* column (cvalue) */
};
</pre>
</div>
Returns <span class="val">nil</span> if no source location matches.
</div>
</div>


<div class="docitem" id="fn:sctllookpc">
<div class="proto">
<div class="function">
<span class="id">sctllookpc(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">file</span>,<span class="arg">line</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">file</span>: <span class="type">string</span>
</div>
<div class="param">
<span class="arg">line</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">cvalue</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">lookpc</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, returning
a program counter address at corresponding
to the source location <span class="arg">file</span>:<span class="arg">line</span>.
Returns <span class="val">nil</span> if there is no matching 
source location.
</div>
</div>

<div class="docitem" id="fn:sctlenumloc">
<div class="proto">
<div class="function">
<span class="id">sctlenumloc(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">addr</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">addr</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">list of local variable records</span>
</div>
</div>
<div class="desc">
Performs an <span class="id">enumloc</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, returning
a list of local variable records.
Local variable records are defined as follows:

<div class="code">
<pre>
@record locrec {
	id,		/* name (cid) */
	sz,		/* size (cvalue) (FIXME: always zero!) */
	ltype,		/* kind (parameter or local) (cvalue) */
	loc,		/* location expression (lexprrec) */
	type,		/* type name (ctype) */
};

@record lexprrec {
	kind,		/* kind (cvalue) */
	no,		/* register (cvalue) */
	v,		/* value (cvalue) */
	op1, op2,	/* operands (lexprrec) */
};
</pre>
</div>

Returns <span class="val">nil</span> if no
location information is available. 

</div>
</div>


<p>
This library also defines several undocumented
functions for converting buffers of encoded sctl data
to and from Cinquecento data structures.
</p>

<h4 id="sec:nsmap">Name space maps</h4>

<p>
A name space map (nsmap) is an object that manages name
spaces for the set of binaries (libraries and
executable) mapped within an address space of a running
program.
</p>

<p>
Think of each mapping as a triple comprising 
the path name for the mapped binary,
the base address of the mapping,
and the corresponding Cinquecento name space.
</p>

<p>
A typical address space consists of several library
mappings and exactly one executable mapping.  An nsmap
defines a distinguished mapping, called the executable,
which is intended to represent the executable mapping.
</p>

<p>
The methods of an nsmap support dynamic addition and
removal of mappings, query and update of the executable
mapping, name space lookup by address and name, name
space enumeration, and nsmap cloning.
</p>

<p>
Rather than require the nsmap client to construct
individual name spaces, each nsmap instance
encapsulates a function that maps a path name to a name
space.  Clients add mappings by specifying the binary
path name and base address.
</p>

<p>
To use nsmaps, <span class="val">@include
&lt;nsmap.cqct&gt;</span> in your program.  The library
defines one function:
</p>

<div class="docitem" id="fn:mknsmap">
<div class="proto">
<div class="function">
<span class="id">mknsmap(<span class="arg">fn</span>)</span>
</div>
<div class="param">
<span class="arg">fn</span>: <span class="type">procedure</span>
</div>
<div class="returns">
<span class="type">nsmap</span>
</div>
</div>
<div class="desc">
This is the only constructor for nsmap instances.
<span class="id">Fn</span> is a function that
encapsulates name space construction.  It must accept
one argument, a string naming a program binary, and
return either a name space for that binary mapped at address zero,
or <span class="val">nil</span> if the name space
cannot be constructed.
</div>
</div>

<p>
Each nsmap is a record that exports the following methods:
</p>

<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapadd">
<span class="id">add(<span class="arg">base</span>,<span class="arg">path</span>)
</div>
<div class="param">
<span class="arg">base</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">path</span>: <span class="type">string</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
This method constructs a name space for
the binary named <span class="arg">path</span> mapped at
offset <span class="arg">base</span>, and then adds the
resulting mapping to the nsmap.
The name space is constructed by calling the <span class="arg">fn</span> argument
that was passed to
<span class="fnindex"><a href="#fn:mknsmap">mknsmap</a></span>
when the nsmap was created.
If <span class="arg">base</span> is <span class="val">0</span>
and the nsmap does not already have a defined
executable, then the executable is set
to the new mapping.
</div>
</div>

<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapdel">
<span class="id">del(<span class="arg">base</span>)
</div>
<div class="param">
<span class="arg">base</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
This method removes the name space mapped at
offset <span class="arg">base</span> from the nsmap.
If <span class="arg">base</span> corresponds to the
executable, then the executable is made undefined.
</div>
</div>

<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapexe">
<span class="id">exe()</span>
</div>
<div class="returns">
<span class="type">name space</span> or <span class="type">nil</span>
</div>
</div>
<div class="desc">
This method returns the name space of the executable
of the nsmap,
or <span class="val">nil</span> if it is undefined.
</div>
</div>

<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapsetexe">
<span class="id">setexe(<span class="arg">base</span>)</span>
</div>
<div class="param">
<span class="arg">base</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
This method sets the executable of the nsmap
to be the mapping at offset <span class="arg">base</span>.
It is an error if there is no such mapping.
</div>
</div>


<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapbyaddr">
<span class="id">byaddr(<span class="arg">addr</span>)</span>
</div>
<div class="param">
<span class="arg">addr</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">name space</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Intuitively, this method attempts to return the name space in the nsmap whose mapping "contains" the address <span class="arg">addr</span>.
More precisely, this method returns the name space whose offset
is the greatest address less than or
equal to <span class="arg">addr</span>.
It returns <span class="val">nil</span> if no name space matches.
</div>
</div>


<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapbyname">
<span class="id">byname(<span class="arg">pat</span>)</span>
</div>
<div class="param">
<span class="arg">pat</span>: <span class="type">string</span>
</div>
<div class="returns">
<span class="type">name space</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
This method returns the name space whose path name matches
<span class="arg">pat</span>.
A path name  <span class="arg">path</span>
matches if <span class="val">strstr(<span class="arg">path</span>,<span class="arg">pat</span>)</span> returns non-<span class="val">nil</span>.  The
search is performed in ascending order of mapping offset;
the first match is returned.
<span class="id">Byaddr</span>
returns <span class="val">nil</span> if no name space
matches.
</div>
</div>


<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapeach">
<span class="id">each(<span class="arg">fn</span>)</span>
</div>
<div class="param">
<span class="arg">fn</span>: <span class="type">procedure</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
This method calls <span class="arg">fn</span> for each
mapping in the nsmap, in ascending order of mapping
offset.  <span class="arg">Fn</span> is passed the
three properties of the mapping: the offest, the path
name, and the name space.  The return value
of <span class="id">fn</span> is ignored.
</div>
</div>

<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapcopy">
<span class="id">copy()</span>
</div>
<div class="returns">
<span class="type">nsmap</span>
</div>
</div>
<div class="desc">
This returns a new nsmap that is a copy of the nsmap.
Subsequent updates to either one of the nsmaps has
no effect on the other.
</div>
</div>


<h4 id="sec:fnindex">Function Index</h4>
<div class="id">
<div class="index">
<div class="fnindex">
<a href="#fn:nsmapadd">add</a> (nsmap)<br />
<a href="#fn:atnames">atnames</a> (nsmap)<br />
<a href="#fn:nsmapbyaddr">byaddr</a> (nsmap)<br />
<a href="#fn:nsmapbyname">byname</a> (nsmap)<br />
<a href="#fn:ctlclear">clear</a> (nsmap)<br />
<a href="#fn:nsmapcopy">copy</a> (nsmap)<br />
<a href="#fn:ctlctx">ctx</a> (ctl)<br />
<a href="#fn:nsmapdel">del</a> (nsmap)<br />
<a href="#fn:ctldetach">detach</a> (ctl)<br />
<a href="#fn:ctldom">dom</a> (ctl)<br />
<a href="#fn:nsmapeach">each</a> (nsmap)<br />
<a href="#fn:ctlexe">exe</a> (ctl)<br />
<a href="#fn:nsmapexe">exe</a> (nsmap)<br />
<a href="#fn:ctlid">id</a> (ctl)<br />
<a href="#fn:ctlkill">kill</a> (ctl)<br />
<a href="#fn:ctlldom">ldom</a> (ctl)<br />
<a href="#fn:ctllookpc">lookpc</a> (ctl)<br />
<a href="#fn:ctllooksrc">looksrc</a> (ctl)<br />
<a href="#fn:ctlmem">mem</a> (ctl)<br />
<a href="#fn:mknsmap">mknsmap</a><br />
<a href="#fn:mksctlns">mksctlns</a><br />
<a href="#fn:ctlns">ns</a> (ctl)<br />
<a href="#fn:ctlnsmap">nsmap</a> (ctl)<br />
<a href="#fn:nsmapsetexe">setexe</a> (nsmap)<br />
<a href="#fn:sctlenumloc">sctlenumloc</a><br />
<a href="#fn:sctlenumsym">sctlenumsym</a><br />
<a href="#fn:sctlenumtype">sctlenumtype</a><br />
<a href="#fn:sctllookaddr">sctllookaddr</a><br />
<a href="#fn:sctllookpc">sctllookpc</a><br />
<a href="#fn:sctllooksrc">sctllooksrc</a><br />
<a href="#fn:sctllooksym">sctllooksym</a><br />
<a href="#fn:sctllooktype">sctllooktype</a><br />
<a href="#fn:sctlnames">sctlnames</a><br />
<a href="#fn:sctlping">sctlping</a><br />
<a href="#fn:sctlunwind1">sctlunwind1</a><br />
<a href="#fn:sctlversion">sctlversion</a><br />
<a href="#fn:ctlsnap">snap</a> (ctl)<br />
<a href="#fn:ctlstat">stat</a> (ctl)<br />
<a href="#fn:ctltrap">trap</a> (ctl)<br />
<a href="#fn:ctltraps">traps</a> (ctl)<br />
<a href="#fn:ctlunwind">unwind</a> (ctl)<br />
</div>
</div>
</div>

<br />
<br />


</div>

</body>
</html>
