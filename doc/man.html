<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Cinquecento Manual</title>
<link rel="stylesheet" type="text/css" media="screen" href="reset.css"/>
<link rel="stylesheet" type="text/css" media="screen" href="styles.css"/>
</head>

<body>

<div id="content">

<h3>Introduction</h3>

<p>
The Cinquecento programming language is designed to
help programmers diagnose hard bugs in complex software
by providing flexible, symbolic access to the binary
data in which the state of a program in execution is
encoded.
</p>

<p>
The main features are:

<ul>
<li>
<em>C-like syntax for examining and manipulating
program state.</em>  Nearly every syntactic form in C
works verbatim in Cinquecento, with identical semantics
to C.  This includes all C types, pointers, C
operators, and C control syntax.
</li>

<li>
<em>Multiple simultaneously active target program
contexts.</em>  The state of any number of distinct
program executions can be examined from within a single
Cinquecento program.
</li>

<li>
<em> Multiple, dynamically-specified,
machine-independent symbolic definitions.</em>  The
types and symbols associated with a target program are
specified in an extension of C type and variable
declaration syntax.  These specifications are collected
in first class name spaces, allowing any number of
distinct, potentially conflicting specifications to
exist at any time.  Different name spaces may be based
upon different underlying machine and compiler
characteristics, such as the size and encoding of
integers, none of which need be in common with those of
the machine on which Cinquecento programs execute.
</li>

<li>
<em> Multiple, programatically-defined sources of
program state.</em>  Conventional debuggers can
interface with only a single source of program state,
usually the process control interface of the host
operating system.  In Cinquecento, each source of
program state is encapsulated in a first class address
space that represents a mapping of addresses to bytes.
The standard address space is a wrapper to the local
operating system process control interface, serving
direct access to the state of local processes.  Another
possibility is a interface to a remote server for
process state on a different, possibly running a
different operating system.  Yet another possiblity is
the contents of a file in a local or remote file
system, such as a core dump file representing the image
of a broken process.
</li>

<li>
<em> Scripting

</ul>

<p>
To debug nearly any software bug, programmers need a
way to examine the state of the data structures of a
running program. 
Access to this state usually arises
from some primitive operating system service that can
read and write the bytes stored in another program's
address space.  On top of this service, conventional
debuggers layer a more abstract symbolic interface to
program state, translating references to program
variables contained in user commands into calls that
access the corresponding bytes in the program's address
space.  Over sequences of interactive commands to their
debugger, programmers examine program data structures
in terms of the names and types assigned to data in the
program source code, rarely needing to think about the
underlying byte-level representation of the data.
</p>

<p>

The Cinquecento programming language brings the key
features of the C programming language --- its types,
pointers, operators, and control syntax --- to
situations 
</p>



<h3>Types</h3>

<p>C defines several categories of types, including the
base arithmetic types, pointers, arrays, aggregates,
functions, and enumerations, instances of which are
combined to form the types defined by a C program.
</p>

<p>
Cinquecento distinguishes the name of a C type from its
definition.  Type names are syntactic constructions
that appear in C declarations, such as <tt>int*</tt>.
They determine the C operations, such as pointer
dereference, that may be applied to a value of the
named type.  To evaluate many of these operations,
however, the system must know the layout and encoding
of the value in memory.  Type definitions provide this
additional information.
</p>

<p>
For example, the type name <tt>int*</tt> identifies the
type pointer-to-<tt>int</tt>.  A value of this type may
be dereferenced to yield a value of type <tt>int</tt>,
but evaluation of the dereference operation depends on
knowing the size of the pointer and the size and
encoding of <tt>int</tt>.  This information comes from
the definition of <tt>int*</tt>.  One definition for
<tt>int*</tt> may be a 64-bit address of a 64-bit
integer encoded in big-endian order, while another may
be a 32-bit address of a 32-bit integer encoded in
little-endian order.
</p>

<p>
For each category of C types, several properties
characterize the name and definition of any type of the
category.  In general, the properties that characterize
the type name are a subset of the corresponding type
definition properties:
</p>

<div id="table">
<table>
<tr>
<th>Type category</th>
<th>Name properties</th>
<th>Definition properties</th>
</tr>

<tr>
<td>
Arithmetic
</td>
<td>
Name (<tt>int</tt>, ...)
</td>
<td>
Name (<tt>int</tt>, ...)<br />
Size and encoding
</td>
</tr>

<tr>
<td>
Aggregate
</td>
<td>
Tag
</td>
<td>
Tag (optional)<br />
Size<br />
Fields
</td>
</tr>

<tr>
<td>
Array
</td>
<td>
Element type<br />
Count (optional)
</td>
<td>
Element type<br />
Count (optional)
</td>
</tr>

<tr>
<td>
Function
</td>
<td>
Return type<br />
Parameters
</td>
<td>
Return type<br />
Parameters
</td>
</tr>

<tr>
<td>
Enumeration
</td>
<td>
Tag
</td>
<td>
Tag (optional)<br />
Size and encoding (optional)<br />
Constants (optional)
</td>
</tr>

<tr>
<td>
Typedef
</td>
<td>
Identifier<br />
</td>
<td>
Identifier<br />
Aliased type
</td>
</tr>

<tr>
<td>
Pointer
</td>
<td>
Pointed-to type
</td>
<td>
Pointed-to type<br />
Size and encoding
</td>
</tr>

<tr>
<td>
Void
</td>
<td>
None
</td>
<td>
None
</td>
</tr>

</table>
</div>

<p>
Type names and type definitions are first-class
Cinquecento values represented by the type
<em>ctype</em>.  Whether a ctype value represents a
type name or a type definition depends on its
properties.  Usually it is clear from the context in
which the ctype was produced.
</p>

<p>
There is a ctype constructor for each type category.
For a given category, the same constructor can generate
either a type name or a type definition, depending on
the arguments.  The constructors are:
</p>

<div id="table">
<table>
<tr>
<th>Type category</th>
<th>Name constructor</th>
<th>Definition constructor</th>
</tr>
<tr>
<td>
Arithmetic
</td>
<td>
<div id=symbols>
mkctype_base(<em>base</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_base(<em>base</em>, <em>rep</em>);
</div>
</td>
</tr>

<tr>
<td>
Aggregate
</td>
<td>
<div id=symbols>
mkctype_struct(<em>tag</em>);<br />
mkctype_union(<em>tag</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_struct(<em>tag</em>, <em>fields</em>, <em>sz</em>);<br />
mkctype_union(<em>tag</em>, <em>fields</em>, <em>sz</em>);<br />
</div>
</td>
</tr>

<tr>
<td>
Array
</td>
<td>
<div id=symbols>
mkctype_array(<em>ctype</em>, <em>count</em>);<br />
</div>
</td>
<td>
<div id=symbols>
mkctype_array(<em>ctype</em>, <em>count</em>);<br />
</div>
</td>
</tr>

<tr>
<td>
Function
</td>
<td>
<div id=symbols>
mkctype_fn(<em>ctype</em>, <em>params</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_fn(<em>ctype</em>, <em>params</em>);
</div>
</td>
</tr>

<tr>
<td>
Enumeration
</td>
<td>
<div id=symbols>
mkctype_enum(<em>tag</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_enum(<em>tag</em>, <em>ctype</em>, <em>consts</em>);
</div>
</td>
</tr>

<tr>
<td>
Typedef
</td>
<td>
<div id=symbols>
mkctype_typedef(<em>id</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_typedef(<em>id</em>, <em>ctype</em>);
</div>
</td>
</tr>

<tr>
<td>
Pointer
</td>
<td>
<div id=symbols>
mkctype_ptr(<em>ctype</em>);
</div id=symbols>
</td>
<td>
<div id=symbols>
mkctype_ptr(<em>ctype</em>, <em>rep</em>);
</div>
</td>
</tr>

<tr>
<td>
Void
</td>
<td>
<div id=symbols>
mkctype_void();
</div>
</td>
<td>
<div id=symbols>
mkctype_void();
</div>
</td>
</tr>

</table>
</div>

<p>
Arguments corresponding to optional properties may be
<tt>nil</tt>.

<p>
The <em><tt>fields</tt></em> parameter is a vector of
field definitions.  Each field definition is a vector
of four elements:
</p>

<div id="inset">
<p>
<tt>vector(<em>ctype</em>, <em>id</em>, <em>offset</em>, <em>width</em>);</tt>
</p>
</div>

<div id="noindent">
<p>
where <em><tt>ctype</tt></em> is the type of the field,
and <em><tt>id</tt></em> is the name of the field.  If
the field is a bitfield, then <em><tt>width</tt></em>
is the width in bits of the field and
<em><tt>offset</tt></em> is the bit offset from the
beginning of the aggregate to the start of the
bitfield.  Otherwise, <em><tt>width</tt></em> is
<tt>nil</tt>, and <em><tt>offset</tt></em> is the
<em>byte</em> offset from the beginning of the
aggregate to the start of the field.

</p>
</div>

<p>
The <em><tt>params</tt></em> parameter is a vector of
function parameter definitions, ordered by parameter
position.  Each parameter definition is a vector of two
elements:
</p>

<div id="inset">
<p>
<tt>vector(<em>ctype</em>, <em>id</em>);</tt>
</p>
</div>

<div id="noindent">
<p>
where <em><tt>ctype</tt></em> is the type of the
parameter, and <em><tt>id</tt></em> is the name of the
parameter or <tt>nil</tt>.
</p>
</div>

<p>
The <em><tt>consts</tt></em> parameter is a vector of
enumeration constant definitions.  Each constant
definition is a vector of two elements:
</p>

<div id="inset">
<p>
<tt>vector(<em>id</em>, <em>value</em>);</tt>
</p>
</div>

<div id="noindent">
<p>
The exact behavior of <tt>mkctype_enum</tt> remains a mystery.
</p>
</div>

<p>
Part of the role of a Cinquecento name space is to
define a set of C types.  This is implemented by
defining a function, conventionally
called <tt>looktype</tt>, that maps type names to type
definitions.  The argument to this function is a ctype
that <tt>looktype</tt> treats as a type name.  It
returns the corresponding definition for that name,
or <tt>nil</tt> if there is no definition.
</p>

<p>
Most name spaces are defined by the <tt>@names</tt>
operator, which translates C declarations into a
definition of a name space.  The name space
constructor <tt>mkns</tt> provides an alternate way to
define a name space.  The argument to mkns is a table,
conventionally named <tt>typetab</tt>, that maps type
names to type definitions.
</p>

<p>
Unlike <tt>looktype</tt>, the type names to
which <tt>typetab</tt> maps names do not need to be
fully defined type names.
</p>

<p>
In fact, the current implementation of <tt>@names</tt>
simply translates the C declarations in the body of
the <tt>@names</tt> form into 


<div id="code">
<pre>
Here is some code.
dom`x = @names blah {
	int x;
};
x = "this is a string";
if(x < y){
	printf("all is well\n");
}
</pre>
</div>

<p>
And here is another.
</p>

</div>


</body>
</html>

- prebaked uint32_t, etc.
- for dynamic name spaces, the definitions of base types must be constant;
  idea is that definition of user-defined types is context sensitive,
  but base types is fixed (since the machine model should not be changing).
  this allows the implementation to pre-fetch definitions for all base
  types.
