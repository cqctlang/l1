<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Cinquecento Manual</title>
<link rel="stylesheet" type="text/css" media="screen" href="reset.css"/>
<link rel="stylesheet" type="text/css" media="screen" href="styles.css"/>
</head>

<body>

<div id="content">

<h3>Introduction</h3>

<p>
Cinquecento is a programming language designed to help
programmers examine the state of programs in execution,
particularly C programs.  The central feature of
Cinquecento is a first-class abstraction, called
a <em>domain</em>, that represents a program in
execution.  Cinquecento programs access the program
state represented by domains using types, operators,
and expressions of the C programming language.
</p>

<p>
Cinquecento is designed to be intuitive to programmers
who are already familiar with C and Scheme.  The syntax
and semantics of the Cinquecento types, values, and
expressions used to examine program state are nearly
identical to C; the main differences are
generalizations that allow multiple type and symbol
name spaces and different processor and compiler models
to coexist in a single Cinquecento program.  While the
syntax of Cinquecento in no way resembles Scheme, many
of the central features of Scheme --- dynamic typing,
lexical scope, proper tail recursion, first-class
functions, even continuations --- appear in Cinquecento
with similar generality.  C provides the data model;
Scheme provides the naming and control model.
</p>

<p>
In practice, Cinquecento must be coupled with a
facility for accessing the state of running programs.
A facility for accessing remotely executing Linux
processes accompanies our distribution.  However, the
role of Cinquecento is to provide a uniform,
programmable interface to the program state exposed by
the variety of such facilities.  This manual focuses on
these generic features of the language, which are
necessary for all users, at the expense of concrete
examples on real programs for a specific environment.
A separate document fills in the details for Linux.
</p>

<h3>Preliminaries</h3>

<p>
Here is how to print something:
</p>

<div id="code">
<pre>
; printf("hello, world!");
hello, world
</pre>
</div>

<p>
Our Cinquecento implementation can be used
interactively, like most scripting languages.  In this
manual, <tt>;</tt> is the input prompt at which a
Cinquecento form to be evaluated is entered.  The
result of the evaluation is printed on the following
line.  We will occasionally omit some or all output
when it detracts from the main point.
</p>

<p>
Input can also be read from a file.  Suppose
<tt>filename</tt> contains the line <tt>printf("hello,
world!");</tt>.  Then:
</p>

<div id="code">
<pre>
; @include "filename"
hello, world
</pre>
</div>

<p>
When reading input source, Cinquecento replaces any
occurrence of the <tt>@include</tt> form with the
contents of the named file.  They may appear anywhere
in input.
</p>

<p>
Comment syntax follows C.  Input enclosed in
<tt>/*</tt> <tt>*/</tt> is a comment.  Input between
<tt>//</tt> and the next newline character is also a
comment.
</p>

<h3>Cinquecento Types</h3>

<p>
Cinquecento defines several types of values.  Every
value in Cinquecento has exactly one type.
</p>

<p>
The types special to Cinquecento are <em>cvalue</em>,
<em>ctype</em>, <em>domain</em>, <em>address
space</em>, and <em>name space</em>.  In certain
(usually invisible) contexts, address spaces are
indexed by values of type <em>address</em> and
<em>range</em>.
</p>

<p>
Other basic types include <em>string</em>,
<em>procedure</em>, and <em>file descriptor</em>.

<p>
There are also several container types for storing
values of any type: <em>list</em>, <em>vector</em>, and
<em>table</em>.
</p>

<p>
The special value, <tt>nil</tt>, is not a member of any
other type or equal to any other value.
</p>

<p>
The <em>undefined</em> value uninitialized variables
and containers bindings and containers.  There is no
corresponding literal.
</p>

<p>
For each type there is a predicate to test whether a
value belongs to the type.  The predicates are
<tt>isctype</tt>, <tt>isdom</tt>, <tt>isas</tt>,
<tt>isns</tt>, <tt>isrange</tt>, <tt>isaddr</tt>,
<tt>isstr</tt>, <tt>isprocedure</tt>, <tt>isfd</tt>
(file descriptor), <tt>isnil</tt>, <tt>islist</tt>,
<tt>isvec</tt>, <tt>istable</tt>, <tt>isnil</tt>, and
<tt>isundefined</tt>.
</p>

<p>
There are no explict numeric types.  In Cinquecento,
all arithmetic is performed using C operators over
values of type cvalue.
</p>

<h3>Domains</h3>

<p>
The most important type in Cinquecento is the
<em>domain</em>.  A domain is a representation of the
state of a C program in execution suitable for
examining and modifying program variables and data
structures.  In Cinquecento these interactions are
expressed using ordinary C expressions; a more precise
definition of a domain is that it represents a context
in which C expressions can be evaluated.  This context
includes definitions of the types, variables, and
constants referenced, perhaps implicitly, by a C
expression.  It also includes the storage to which
operations that reference memory are directed.
</p>

<p>
The structure of a Cinquecento domain has two parts,
represented by two Cinquecento values.  First, the
<em>name space</em> is symbolic information about the
program, the names and definitions of types and
variables as defined in the source code of the program.
Second, the <em>address space</em> is the uninterpreted
memory image of a running instance of the program, a
mapping from program addresses to the corresponding
contents of memory.  A Cinquecento domain is a
projection of the symbolic view of memory defined by
the name space over memory image defined by the address
space.
</p>

<p>
Domains, name spaces, and address spaces are
first-class values in Cinquecento.  Syntax forms allow
new name spaces to be defined from extended form of C
declaration syntax.  Both name spaces and address
spaces can also be constructed from user-defined
functions.
</p>

<h3>C Types</h3>

<p>The Cinquecento type <em>ctype</em> represents types
defined in C programs.  Cinquecento subdivides the set
of types that can be defined in C into several
categories.  The main categories are: the <tt>void</tt>
type, the base arithmetic types (<tt>char</tt>,
<tt>int</tt>, <tt>unsigned long</tt>, <em>etc</em>),
pointers, arrays, aggregates (<tt>struct</tt> and
<tt>union</tt>), functions, enumerations, and
<tt>typedef</tt>s.  In addition, Cinquecento also has
separate categories for bitfields, enumeration
constants, and undefined types.
</p>

<p>
Each type used by a C program is represented in
Cinquecento as a combination of instances of these
categories.  Cinquecento has a distinct ctype
constructor for each category, a predicate to test a
ctype instance for membership in the category, and
accessors for category-dependent attributes such as the
fields of an aggregate and the pointed-to type of a
pointer.
</p>

<p>
Cinquecento ctypes represent both C type names and C
type definitions.  Type names are the syntactic
constructions, such as <tt>int*</tt>, that can appear
in C declarations, or as operands to type operations
such as <tt>sizeof</tt> and explicit casts.
Type definitions specify the encoding in memory of the
value of a C type.  For base types, this specification
includes the number of bytes that represent the value
and how the bytes are to be interpreted (e.g., big- or
little-endian order).  For pointer types, it includes
the size and representation of the pointer value
memory.  For aggregates, it includes the offset from
the beginning of the aggregate to each field and
the overall size of the aggregate.
</p>

<p>
The distinction between type name and definition
matters when the same type name different domains have
types with the same name.  For example, the type name
<tt>int*</tt> always corresponds to the type
pointer-to-<tt>int</tt>, but there are many possible
definitions.  One domain can define it to be a 64-bit
address of a 64-bit integer encoded in big-endian
order, while another may be define it be a 32-bit
address of a 32-bit integer encoded in little-endian
order.
</p>

<div id="table">
<table>
<tr>
<th>Type category</th>
<th>Name properties</th>
<th>Definition properties</th>
</tr>

<tr>
<td>
Arithmetic
</td>
<td>
Name (<tt>int</tt>, ...)
</td>
<td>
Name (<tt>int</tt>, ...)<br />
Size and encoding
</td>
</tr>

<tr>
<td>
Aggregate
</td>
<td>
Tag
</td>
<td>
Tag (optional)<br />
Size<br />
Fields
</td>
</tr>

<tr>
<td>
Array
</td>
<td>
Element type<br />
Count (optional)
</td>
<td>
Element type<br />
Count (optional)
</td>
</tr>

<tr>
<td>
Function
</td>
<td>
Return type<br />
Parameters
</td>
<td>
Return type<br />
Parameters
</td>
</tr>

<tr>
<td>
Enumeration
</td>
<td>
Tag
</td>
<td>
Tag (optional)<br />
Size and encoding (optional)<br />
Constants (optional)
</td>
</tr>

<tr>
<td>
Typedef
</td>
<td>
Identifier<br />
</td>
<td>
Identifier<br />
Aliased type
</td>
</tr>

<tr>
<td>
Pointer
</td>
<td>
Pointed-to type
</td>
<td>
Pointed-to type<br />
Size and encoding
</td>
</tr>

<tr>
<td>
Void
</td>
<td>
None
</td>
<td>
None
</td>
</tr>

</table>
</div>

<p>
Type names and type definitions are first-class
Cinquecento values represented by the type
<em>ctype</em>.  Whether a ctype value represents a
type name or a type definition depends on its
properties.  Usually it is clear from the context in
which the ctype was produced.
</p>

<p>
There is a ctype constructor for each type category.
For a given category, the same constructor can generate
either a type name or a type definition, depending on
the arguments.  The constructors are:
</p>

<div id="table">
<table>
<tr>
<th>Type category</th>
<th>Name constructor</th>
<th>Definition constructor</th>
</tr>
<tr>
<td>
Arithmetic
</td>
<td>
<div id=symbols>
mkctype_char()<br />
mkctype_short()<br />
mkctype_int()<br />
mkctype_long()<br />
mkctype_vlong()<br />
mkctype_uchar()<br />
mkctype_ushort()<br />
mkctype_uint()<br />
mkctype_ulong()<br />
mkctype_uvlong()<br />
mkctype_float()<br />
mkctype_double()<br />
mkctype_ldouble()
</div>
</td>
<td>
<div id=symbols>
<em>n/a</em>
</div>
</td>
</tr>

<tr>
<td>
Aggregate
</td>
<td>
<div id=symbols>
mkctype_struct(<em>tag</em>)<br />
mkctype_union(<em>tag</em>)
</div>
</td>
<td>
<div id=symbols>
mkctype_struct(<em>tag</em>, <em>fields</em>, <em>sz</em>)<br />
mkctype_union(<em>tag</em>, <em>fields</em>, <em>sz</em>)<br />
</div>
</td>
</tr>

<tr>
<td>
Array
</td>
<td>
<div id=symbols>
mkctype_array(<em>ctype</em>, <em>count</em>)<br />
</div>
</td>
<td>
<div id=symbols>
mkctype_array(<em>ctype</em>, <em>count</em>)<br />
</div>
</td>
</tr>

<tr>
<td>
Function
</td>
<td>
<div id=symbols>
mkctype_fn(<em>ctype</em>, <em>params</em>)
</div>
</td>
<td>
<div id=symbols>
mkctype_fn(<em>ctype</em>, <em>params</em>)
</div>
</td>
</tr>

<tr>
<td>
Enumeration
</td>
<td>
<div id=symbols>
mkctype_enum(<em>tag</em>)
</div>
</td>
<td>
<div id=symbols>
mkctype_enum(<em>tag</em>, <em>ctype</em>, <em>consts</em>)
</div>
</td>
</tr>

<tr>
<td>
Typedef
</td>
<td>
<div id=symbols>
mkctype_typedef(<em>id</em>)
</div>
</td>
<td>
<div id=symbols>
mkctype_typedef(<em>id</em>, <em>ctype</em>)
</div>
</td>
</tr>

<tr>
<td>
Pointer
</td>
<td>
<div id=symbols>
mkctype_ptr(<em>ctype</em>)
</div id=symbols>
</td>
<td>
<div id=symbols>
mkctype_ptr(<em>ctype</em>, <em>repctype</em>)
</div>
</td>
</tr>

<tr>
<td>
Void
</td>
<td>
<div id=symbols>
mkctype_void()
</div>
</td>
<td>
<div id=symbols>
mkctype_void()
</div>
</td>
</tr>

<tr>
<td>
Typedef
</td>
<td>
<div id=symbols>
mkctype_typedef(<em>id</em>)
</div>
</td>
<td>
<div id=symbols>
mkctype_typedef(<em>id</em>,<em>ctype</em>)
</div>
</td>
</tr>

<tr>
<td>
Bitfield
</td>
<td>
<div id=symbols>
mkctype_bitfield(<em>ctype</em>,<em>width</em>,<em>off</em>)
</div>
</td>
<td>
<div id=symbols>
mkctype_bitfield(<em>ctype</em>,<em>width</em>,<em>off</em>)
</div>
</td>
</tr>

<tr>
<td>
Enum constant
</td>
<td>
<div id=symbols>
mkctype_const(<em>ctype</em>)
</div>
</td>
<td>
<div id=symbols>
mkctype_const(<em>ctype</em>)
</div>
</td>
</tr>


</table>
</div>

<p>
Arguments corresponding to optional properties may be
<tt>nil</tt>.

<p>
The <em><tt>fields</tt></em> parameter is a vector of
field definitions.  Each field definition is a vector
of four elements:
</p>

<div id="inset">
<p>
<tt>vector(<em>ctype</em>, <em>id</em>, <em>offset</em>, <em>width</em>);</tt>
</p>
</div>

<div id="noindent">
<p>
where <em><tt>ctype</tt></em> is the type of the field,
and <em><tt>id</tt></em> is the name of the field.  If
the field is a bitfield, then <em><tt>width</tt></em>
is the width in bits of the field and
<em><tt>offset</tt></em> is the bit offset from the
beginning of the aggregate to the start of the
bitfield.  Otherwise, <em><tt>width</tt></em> is
<tt>nil</tt>, and <em><tt>offset</tt></em> is the
<em>byte</em> offset from the beginning of the
aggregate to the start of the field.

</p>
</div>

<p>
The <em><tt>params</tt></em> parameter is a vector of
function parameter definitions, ordered by parameter
position.  Each parameter definition is a vector of two
elements:
</p>

<div id="inset">
<p>
<tt>vector(<em>ctype</em>, <em>id</em>);</tt>
</p>
</div>

<div id="noindent">
<p>
where <em><tt>ctype</tt></em> is the type of the
parameter, and <em><tt>id</tt></em> is the name of the
parameter or <tt>nil</tt>.
</p>
</div>

<p>
The <em><tt>consts</tt></em> parameter is a vector of
enumeration constant definitions.  Each constant
definition is a vector of two elements:
</p>

<div id="inset">
<p>
<tt>vector(<em>id</em>, <em>value</em>);</tt>
</p>
</div>

<div id="noindent">
<p>
The exact behavior of <tt>mkctype_enum</tt> remains a mystery.
</p>
</div>

<p>
Part of the role of a Cinquecento name space is to
define a set of C types.  This is implemented by
defining a function, conventionally
called <tt>looktype</tt>, that maps type names to type
definitions.  The argument to this function is a ctype
that <tt>looktype</tt> treats as a type name.  It
returns the corresponding definition for that name,
or <tt>nil</tt> if there is no definition.
</p>

<p>
Most name spaces are defined by the <tt>@names</tt>
operator, which translates C declarations into a
definition of a name space.  The name space
constructor <tt>mkns</tt> provides an alternate way to
define a name space.  The argument to mkns is a table,
conventionally named <tt>typetab</tt>, that maps type
names to type definitions.
</p>

<p>
Unlike <tt>looktype</tt>, the type names to
which <tt>typetab</tt> maps names do not need to be
fully defined type names.
</p>

<h3>Standard address spaces</h3>

<p>
An address space represents random access,
byte-addressed storage.  Cinquecento provides functions
to construct address spaces whose underlying backing
storage comes from files, strings, or system-provided
memory.
</p>

<p>
Several built-in functions create new address spaces
with specific forms of backing storage.
</p>

<p>
The function <tt>mknas()</tt> returns a null address
space that has no backing storage.  An attempt to read
or write any location in this address space draws an
error.  This address space is used to construct domains
that act solely as sources for types and symbols; for
example, the literal domain is backed by a null address
space.
</p>

<p>
The function <tt>mksas(<em>str</em>)</tt> creates an
address base backed by the string <em>str</em>.  The
memory associated with the string is shared with the
address space, so that an update made to either the
string or the address space will be reflected in the
other.
</p>

<p>
The function <tt>mapfile(<em>filename</em>)</tt>
returns a string containing the contents of the file
named <tt><em>filename</em></tt>.  The idiom for
constructing a file-backed address space is to compose
this function with <tt>mksas</tt>:
<div id="code">
<pre>
; fileas = mksas(mapfile("/var/log/wtmp"));
</pre>
</div>
</p>

<p>
The function <tt>mkzas(<em>len</em>)</tt> creates a
zero-filled address space backed by
<tt><em>len</em></tt> bytes of unshared, cleared
memory supplied by the system.
</p>

<h3>Custom address spaces</h3>

<p>
Cinquecento allows programs to construct an address space
with a custom implementation of the underlying backing
storage.
</p>

<p>A custom implementation requires the program to
define three functions: <tt><em>map</em></tt>,
<tt><em>get</em></tt>, and <tt><em>put</em></tt>.
</p>

<p>
These functions receive and return values of the
Cinquecento type <em>range</em>.  The range type
represents a contiguous span of locations in an address
space.  A range value is constructed by the function
<tt>mkrange(<em>beg</em>,<em>len</em>)</tt>, where
<tt><em>beg</em></tt> is the non-negative start address
of the range and <tt><em>len</em></tt> is the positive
number of bytes in the range; both are cvalues.  Empty
ranges are invalid.  The functions
<tt>rangebeg(<em>range</em>)</tt> and
<tt>rangelen(<em>range</em>)</tt> return the start
address and byte count from a range as cvalues.
</p>

<p>
<tt><em>Map</em></tt> takes no arguments and returns a
description of the <em>mapped ranges</em> of the
address space as a vector of range values.  Each
element of the vector must be a range describing a
maximal contiguous span of locations backed by the
address space.  The vector must be sorted in ascending
order by start address.  The ranges must not overlap.
</p>

<p>
<tt><em>Get</em></tt> takes a range argument and
returns a string.  The string should contain the
contents of storage corresponding to the range.
</p>

<p>
<tt><em>Put</em></tt> takes two arguments, a range and
a string, and returns <tt>nil</tt>.
<tt><em>Put</em></tt> should replace the contents of
storage corresponding to the range with the contents of
the string, ignoring the trailing portion of the string
if it is longer than the range.
</p>

<p>
A call to <tt>fault()</tt> in the dynamic extent of a
call to <tt><em>get</em></tt> or <tt><em>put</em></tt>
will cause a toplevel memory access fault error to be
raised in the context of the call.  Implementations of
<tt><em>get</em></tt> and <tt><em>put</em></tt> are
expected to call <tt>fault</tt> to signal invalid
arguments and related exceptions.
</p>

<p>
The function <tt>mkas(<em>dispatch</em>)</tt>
constructs a custom address space.  Dispatch is a
program-defined variable arity function that
encapsulates the <tt><em>map</em></tt>,
<tt><em>get</em></tt>, and <tt><em>put</em></tt>
functions.  The first argument to dispatch is a string
whose value is the name of the function to be called;
dispatch must apply the corresponding function to the
remaining arguments.
</p>

<p>
Ordinarily the functions represented by
<em>dispatch</em> are implicitly invoked by the
Cinquecento implementation during evaluation of C
expressions that involve storage access operations
(such as dereferencing a pointer).  However, programs
may directly invoked these functions by name using an
overloaded form of the C binary dot operator:
<div id="code">
<pre>
; as.get(mkrange(0,1024));
</pre>
</div>
</p>

<p>
When the left operand of a dot expression is an address
space, the result of the expression is a variable arity
function that, when called, calls the dispatch function
of the address space.  The arguments it passes to
dispatch are, first, the identifier appearing as the
right operand to the dot expression as a string,
followed by the arguments to the call.
</p>

<p>
In addition, if the right operand is the identifier
<tt>dispatch</tt>, then the result of the expression is
simply the dispatch function of the address space,
instead of the curried version described above.
For example, the above call to <tt>get</tt> is equivalent to:
<div id="code">
<pre>
; as.dispatch("get",mkrange(0,1024));
</pre>
</div>
</p>

<p>
As a syntactic convenience, the left operand to the dot
operator can also be a domain, in which case the same
operation is performed on the underlying address space.
</p>

<p>
The address spaces returned by the standard address
space constructors all implement a dispatch function
that can be accessed with the dot operator in the same
way as a custom address space.
</p>

<p>
The dot operator on address spaces will accept any
valid identifier (not just <tt>map</tt>, <tt>get</tt>,
<tt>put</tt>, and <tt>dispatch</tt>), providing a way
for programs to extend the standard address space
interface with additional custom functions.  This
feature can be used, for example, to associate a
function for setting breakpoints with an address space.
</p>

<p>
The Cinquecento address type exists to support the
implementation of operations like setting a breakpoint
on a solitary address.  The function
<tt>mkaddr(<em>val</em>)</tt> constructs an address
value from the cvalue <tt><em>val</em></tt>.  The
function <tt>addrval(<em>addr</em>)</tt> returns the
cvalue used to construct the address
<tt><em>addr</em></tt>.
</p>


<h3>Address space utilities</h3>

<p>
The function <tt>getbytes(<em>p</em>,<em>len</em>)</tt>
returns selected contents of an address space as a
string.  <tt><em>P</em></tt> is a pointer in some
address space <em>as</em>; <tt><em>len</em></tt> is a
non-negative byte count.  Returns a string containing
the <tt><em>len</em></tt> bytes in <em>as</em>
beginning at <tt><em>p</em></tt>.
</p>

<p>
The function <tt>putbytes(<em>p</em>,
<em>str</em>)</tt> copies bytes into an address space.
<tt><em>P</em></tt> is a pointer in some address space
<em>as</em>.  The bytes of the string
<tt><em>str</em></tt> are copies into <em>as</em>
beginning at <tt><em>p</em></tt>.  Returns
<tt>nil</tt>.
</p>

<h3>Strings</h3>

<p>
The Cinquecento string type represents an array of
bytes.  String instances have a fixed length.  They are
not null terminated.
</p>

<p>
The function <tt>length(<tt><em>val</em></tt>)</tt>,
when <tt><em>val</em></tt> is a string, returns the
number of bytes in the string.
</p>

<p>
The C relational operators are defined over strings.
They compare the bytes of the strings.  (There is no
way to check whether two string instances are the same
object.)
</p>

<h3>I/O</h3>

<p>
Cinquecento supports I/O over regular files and network
connections.  An open file or network connection is
represented by an instance of the file descriptor type.
</p>

<div class=proto>
<div class=function>
<span class=id>open(<span class=arg>filename</span>,<span class=arg>mode</span>)</span>
</div>
<div class=param>
<span class=arg>filename</span>: <span class=type>string</span>
</div>
<div class=param>
<span class=arg>mode</span>: <span class=type>string</span>
</div>
<div class=returns>
<span class=type>file descriptor</span>
</div>
</div>

<p>
Opens the file named <span class=arg>filename</span> and
returns the associated file descriptor.  <span
class=arg>Mode</span> specifies whether the file is to
be opened for reading, writing, or both, and whether
the file is to be created or truncated.  The syntax of
<span class=arg>mode</span> follows that of the C
library stdio <tt>fopen</tt> function.  Common modes
are <span class=lit>"r"</span> (read an existing file)
<span class=lit>"w"</span> (truncate an existing file
for writing), and <span class=lit>"rw"</span> (truncate
an existing file for reading and writing).
</p>

<div class=proto>
<div class=function>
<span class=id>opentcp(<span class=arg>address</span>)</span>
</div>
<div class=param>
<span class=arg>address</span>: <span class=type>string</span>
</div>
<div class=returns>
<span class=type>file descriptor</span>
</div>
</div>

<p>
Opens a TCP connection to <span class=arg>address</span> and
returns the associated file descriptor.
<span class=arg>Address</span> is a string of the form
<tt>"<em>addr</em>:<em>port</em>"</tt>, where
<span class=arg>addr</span> is an IP address or hostname and
<span class=arg>port</span> is a port number or service
name.
</p>

<div class=proto>
<div class=function>
<span class=id>read(<span class=arg>fd</span>,<span class=arg>len</span>)</span>
</div>
<div class=param>
<span class=arg>fd</span>: <span class=type>file descriptor</span>
</div>
<div class=param>
<span class=arg>len</span>: <span class=type>cvalue</span>
</div>
<div class=returns>
<span class=type>string</span> or <span class=type>nil</span>
</div>
</div>

<p>
Reads at most <span class=arg>len</span> bytes from the I/O
resource associated with <span class=arg>fd</span>.  The
call blocks until <span class=arg>len</span> bytes are
read or end of file is encountered.  Returns a string
containing the bytes read, or <tt>nil</tt> if end of
file was encountered and no bytes were read.
</p>

<div class=proto>
<div class=function>
<span class=id>write(<span class=arg>fd</span>,<span class=arg>str</span>)</span>
</div>
<div class=param>
<span class=arg>fd</span>: <span class=type>file descriptor</span>
</div>
<div class=param>
<span class=arg>str</span>: <span class=type>string</span>
</div>
<div class=returns>
<span class=type>nil</span>
</div>
</div>
<p>
Writes the bytes contained in the string
<span class=arg>str</span> to the I/O resource associated
with <span class=arg>fd</span>.
</p>

<div class=proto>
<div class=function>
<span class=id>close(<span class=arg>fd</span>)</span>
</div>
<div class=param>
<span class=arg>fd</span>: <span class=type>file descriptor</span>
</div>
<div class=returns>
<span class=type>nil</span>
</div>
</div>
<p>
Closes the I/O resource associated with <span
class=arg>fd</span>.  Any pending buffered output is
written.  A call to <span class=id>close</span> on an
already closed descriptor has no effect.  A call to
<span class=id>read</span> or <span
class=id>write</span> on a closed descriptor draws an
error.
</p>

<div class=proto>

<div class=function>
<span class=id>fdname(<span class=arg>fd</span>)</span>
</div>

<div class=param>
<span class=arg>fd</span>: <span class=type>file descriptor</span>
</div>

<div class=returns>
<span class=type>string</span>
</div>

</div>

<p>
Returns the name of the I/O resource associated with <span
class=arg>fd</span>.
</p>


</p>
</div>
</body>
</html>
