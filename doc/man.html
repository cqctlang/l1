<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Cinquecento Manual</title>
<link rel="stylesheet" type="text/css" media="screen" href="reset.css"/>
<link rel="stylesheet" type="text/css" media="screen" href="styles.css"/>
</head>

<body>

<div id="content">

<h3>Types</h3>

<p>C defines several categories of types, including the
base arithmetic types, pointers, arrays, aggregates,
functions, and enumerations, instances of which are
combined to form the types defined by a C program.
</p>

<p>
Cinquecento distinguishes the name of a C type from its
definition.  Type names are syntactic constructions
that appear in C declarations, such as <tt>int*</tt>.
They determine the C operations, such as pointer
dereference, that may be applied to a value of the
named type.  To evaluate many of these operations,
however, the system must know the layout and encoding
of the value in memory.  Type definitions provide this
additional information.
</p>

<p>
For example, the type name <tt>int*</tt> identifies the
type pointer-to-<tt>int</tt>.  A value of this type may
be dereferenced to yield a value of type <tt>int</tt>,
but evaluation of the dereference operation depends on
knowing the size of the pointer and the size and
encoding of <tt>int</tt>.  This information comes from
the definition of <tt>int*</tt>.  One definition for
<tt>int*</tt> may be a 64-bit address of a 64-bit
integer encoded in big-endian order, while another may
be a 32-bit address of a 32-bit integer encoded in
little-endian order.
</p>

<p>
For each category of C types, several properties
characterize the name and definition of any type of the
category.  In general, the properties that characterize
the type name are a subset of the corresponding type
definition properties:
</p>

<div id="table">
<table>
<tr>
<th>Type category</th>
<th>Name properties</th>
<th>Definition properties</th>
</tr>

<tr>
<td>
Arithmetic
</td>
<td>
Name (<tt>int</tt>, ...)
</td>
<td>
Name (<tt>int</tt>, ...)<br />
Size and encoding
</td>
</tr>

<tr>
<td>
Aggregate
</td>
<td>
Tag
</td>
<td>
Tag (optional)<br />
Size<br />
Fields
</td>
</tr>

<tr>
<td>
Array
</td>
<td>
Element type<br />
Count (optional)
</td>
<td>
Element type<br />
Count (optional)
</td>
</tr>

<tr>
<td>
Function
</td>
<td>
Return type<br />
Parameters
</td>
<td>
Return type<br />
Parameters
</td>
</tr>

<tr>
<td>
Enumeration
</td>
<td>
Tag
</td>
<td>
Tag (optional)<br />
Size and encoding (optional)<br />
Constants (optional)
</td>
</tr>

<tr>
<td>
Typedef
</td>
<td>
Identifier<br />
</td>
<td>
Identifier<br />
Aliased type
</td>
</tr>

<tr>
<td>
Pointer
</td>
<td>
Pointed-to type
</td>
<td>
Pointed-to type<br />
Size and encoding
</td>
</tr>

<tr>
<td>
Void
</td>
<td>
None
</td>
<td>
None
</td>
</tr>

</table>
</div>

<p>
Type names and type definitions are first-class
Cinquecento values represented by the type
<em>ctype</em>.  Whether a ctype value represents a
type name or a type definition depends on its
properties.  Usually it is clear from the context in
which the ctype was produced.
</p>

<p>
There is a ctype constructor for each type category.
For a given category, the same constructor can generate
either a type name or a type definition, depending on
the arguments.  The constructors are:
</p>

<div id="table">
<table>
<tr>
<th>Type category</th>
<th>Name constructor</th>
<th>Definition constructor</th>
</tr>
<tr>
<td>
Arithmetic
</td>
<td>
<div id=symbols>
mkctype_base(<em>base</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_base(<em>base</em>, <em>rep</em>);
</div>
</td>
</tr>

<tr>
<td>
Aggregate
</td>
<td>
<div id=symbols>
mkctype_struct(<em>tag</em>);<br />
mkctype_union(<em>tag</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_struct(<em>tag</em>, <em>off</em>, <em>fields</em>);<br />
mkctype_union(<em>tag</em>, <em>off</em>, <em>fields</em>);<br />
</div>
</td>
</tr>

<tr>
<td>
Array
</td>
<td>
<div id=symbols>
mkctype_arr(<em>ctype</em>, <em>count</em>);<br />
</div>
</td>
<td>
<div id=symbols>
mkctype_arr(<em>ctype</em>, <em>count</em>);<br />
</div>
</td>
</tr>

<tr>
<td>
Function
</td>
<td>
<div id=symbols>
mkctype_fun(<em>ctype</em>, <em>params</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_fun(<em>ctype</em>, <em>params</em>);
</div>
</td>
</tr>

<tr>
<td>
Enumeration
</td>
<td>
<div id=symbols>
mkctype_enum(<em>tag</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_enum(<em>tag</em>, <em>ctype</em>, <em>consts</em>);
</div>
</td>
</tr>

<tr>
<td>
Typedef
</td>
<td>
<div id=symbols>
mkctype_typedef(<em>id</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_typedef(<em>id</em>, <em>ctype</em>);
</div>
</td>
</tr>

<tr>
<td>
Pointer
</td>
<td>
<div id=symbols>
mkctype_ptr(<em>ctype</em>);
</div id=symbols>
</td>
<td>
<div id=symbols>
mkctype_ptr(<em>ctype</em>, <em>rep</em>);
</div>
</td>
</tr>

<tr>
<td>
Void
</td>
<td>
<div id=symbols>
mkctype_void();
</div>
</td>
<td>
<div id=symbols>
mkctype_void();
</div>
</td>
</tr>

</table>
</div>

<p>
Arguments corresponding to optional properties may be
<tt>nil</tt>.

<p>
The <em><tt>fields</tt></em> parameter is a vector of
field definitions.  Each field definition is a vector
of four elements:
</p>

<div id="inset">
<p>
<tt>vector(<em>ctype</em>, <em>id</em>, <em>offset</em>, <em>width</em>);</tt>
</p>
</div>

<div id="noindent">
<p>
where <em><tt>ctype</tt></em> is the type of the field,
and <em><tt>id</tt></em> is the name of the field.  If
the field is a bitfield, then <em><tt>width</tt></em>
is the width in bits of the field and
<em><tt>offset</tt></em> is the bit offset from the
beginning of the aggregate to the start of the
bitfield.  Otherwise, <em><tt>width</tt></em> is
<tt>nil</tt>, and <em><tt>offset</tt></em> is the
<em>byte</em> offset from the beginning of the
aggregate to the start of the field.

</p>
</div>

<p>
The <em><tt>params</tt></em> parameter is a vector of
function parameter definitions, ordered by parameter
position.  Each parameter definition is a vector of two
elements:
</p>

<div id="inset">
<p>
<tt>vector(<em>ctype</em>, <em>id</em>);</tt>
</p>
</div>

<div id="noindent">
<p>
where <em><tt>ctype</tt></em> is the type of the
parameter, and <em><tt>id</tt></em> is the name of the
parameter or <tt>nil</tt>.
</p>
</div>

<p>
The <em><tt>consts</tt></em> parameter is a vector of
enumeration constant definitions.  Each constant
definition is a vector of two elements:
</p>

<div id="inset">
<p>
<tt>vector(<em>id</em>, <em>value</em>);</tt>
</p>
</div>

<div id="noindent">
<p>
The exact behavior of <tt>mkctype_enum</tt> remains a mystery.
</p>
</div>

<p>
Part of the role of a Cinquecento name space is to
define a set of C types.  This is implemented by
defining a function, conventionally
called <tt>looktype</tt>, that maps type names to type
definitions.  The argument to this function is a ctype
that <tt>looktype</tt> treats as a type name.  It
returns the corresponding definition for that name,
or <tt>nil</tt> if there is no definition.
</p>

<p>
Most name spaces are defined by the <tt>@names</tt>
operator, which translates C declarations into a
definition of a name space.  The name space
constructor <tt>mkns</tt> provides an alternate way to
define a name space.  The argument to mkns is a table,
conventionally named <tt>typetab</tt>, that maps type
names to type definitions.
</p>

<p>
Unlike <tt>looktype</tt>, the type names to
which <tt>typetab</tt> maps names do not need to be
fully defined type names.
</p>

<p>
In fact, the current implementation of <tt>@names</tt>
simply translates the C declarations in the body of
the <tt>@names</tt> form into 


<div id="code">
<pre>
Here is some code.
dom`x = @names blah {
	int x;
};
x = "this is a string";
if(x < y){
	printf("all is well\n");
}
</pre>
</div>

<p>
And here is another.
</p>

</div>


</body>
</html>

- prebaked uint32_t, etc.
- for dynamic name spaces, the definitions of base types must be constant;
  idea is that definition of user-defined types is context sensitive,
  but base types is fixed (since the machine model should not be changing).
  this allows the implementation to pre-fetch definitions for all base
  types.
