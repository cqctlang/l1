<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Cinquecento Manual</title>
<link rel="stylesheet" type="text/css" media="screen" href="reset.css"/>
<link rel="stylesheet" type="text/css" media="screen" href="styles.css"/>
</head>

<body>

<div id="content">

<h3>Introduction</h3>

<p>
This is an informal manual for Cinquecento, a
programming language designed to help programmers
examine the state of programs in execution,
particularly C programs.
</p>

<p>
A single feature distinguishes Cinquecento from other
languages: a first-class abstraction, called a
<em>domain</em>, that represents a program in
execution.  The interface to this abstraction, for both
construction and access, is based on the syntax and
semantics of C.
</p>

<p>
Cinquecento is designed to be intuitive to programmers
who are already familiar with C and Scheme.  The syntax
and semantics of the Cinquecento types, values, and
expressions used to examine program state are nearly
identical to C; the main differences are
generalizations that allow multiple type and symbol
name spaces and different processor and compiler models
to coexist in a single Cinquecento program.  While the
syntax of Cinquecento in no way resembles Scheme, many
of the central features of Scheme --- dynamic typing,
lexical scope, proper tail recursion, first-class
functions, even continuations --- appear in Cinquecento
with similar generality.  C provides the data model;
Scheme provides the naming and control model.
</p>

<p>
In practice, Cinquecento must be coupled with a
facility for accessing the state of running programs.
A facility for accessing remotely executing Linux
processes accompanies our distribution.  However, the
role of Cinquecento is to provide a uniform,
programmable interface to the program state exposed by
the variety of such facilities.  This manual focuses on
these generic features of the language, which are
necessary for all users, at the expense of concrete
examples on real programs for a specific environment.
A separate document fills in the details for Linux.
</p>

<h3>Preliminaries</h3>

<p>
Here is how to print something:
</p>

<div id="code">
<pre>
; printf("hello, world!");
hello, world
</pre>
</div>

<p>
Our Cinquecento implementation can be used
interactively, like most scripting languages.  In this
manual, <tt>;</tt> is the input prompt at which a
Cinquecento form to be evaluated is entered.  The
result of the evaluation is printed on the following
line.  We will occasionally omit some or all output
when it detracts from the main point.
</p>

<p>
Input can also be read from a file.  Suppose
<tt>filename</tt> contains the line <tt>printf("hello,
world!");</tt>.  Then:
</p>

<div id="code">
<pre>
; @include "filename"
hello, world
</pre>
</div>

<p>
When reading input source, Cinquecento replaces any
occurrence of the <tt>@include</tt> form with the
contents of the named file.  They may appear anywhere
in input.
</p>

<p>
Comment syntax follows C.  Input enclosed in
<tt>/*</tt> <tt>*/</tt> is a comment.  Input between
<tt>//</tt> and the next newline character is also a
comment.
</p>

<h3>Cinquecento Types</h3>

<p>
Cinquecento defines several types of values.  Each type
is mutually exclusive to the other types.
</p>

<p>
The types special to Cinquecento are <em>cvalue</em>,
<em>ctype</em>, <em>domain</em>, <em>address
space</em>, and <em>name space</em>.  In certain
(usually invisible) contexts, address spaces are
indexed by values of type <em>address</em> and
<em>range</em>.
</p>

<p>
Other basic types include <em>string</em>,
<em>procedure</em>, and <em>file descriptor</em>.

<p>
There are also several container types for storing
values of any type: <em>list</em>, <em>vector</em>, and
<em>table</em>.
</p>

<p>
The special value, <tt>nil</tt>, is not a member of any
other type or equal to any other value.
</p>

<p>
The <em>undefined</em> value uninitialized variables
and containers bindings and containers.  There is no
corresponding literal.
</p>

<p>
For each type there is a predicate to test whether a
value belongs to the type.  The predicates are
<tt>isctype</tt>, <tt>isdom</tt>, <tt>isas</tt>,
<tt>isns</tt>, <tt>isrange</tt>, <tt>isaddr</tt>,
<tt>isstr</tt>, <tt>isprocedure</tt>, <tt>isfd</tt>
(file descriptor), <tt>isnil</tt>, <tt>islist</tt>,
<tt>isvec</tt>, <tt>istable</tt>, <tt>isnil</tt>, and
<tt>isundefined</tt>.
</p>

<h3>Domains</h3>

<p>
The most important type in Cinquecento is the
<em>domain</em>.  A domain is a representation of a
context in which C expressions can be evaluated, a
model of a C program in execution.  Every C expression
in Cinquecento is evaluated as if it were a fragment of
code in a C program modeled by a particular domain.
</p>

<p>
The domain representation of a C program has two parts.
First, the <em>name space</em> is symbolic information
about the program, the names and definitions of types
and variables as defined in the source code of the
program.  Second, the <em>address space</em> is the
uninterpreted memory image of a running instance of the
program, a mapping from program addresses to the
corresponding contents of memory.  A Cinquecento domain
is a projection of the symbolic view of memory defined
by the name space over memory image defined by the
address space.
</p>

<p>
Domains, name spaces, and address spaces are
first-class values in Cinquecento.  Syntax forms allow
new name spaces to be defined from extended form of C
declaration syntax.  Both name spaces and address
spaces can also be constructed from user-defined
functions.
</p>

<h3>C Types</h3>

<p>The Cinquecento type <em>ctype</em> represents types
defined in C programs.  Cinquecento subdivides the set
of types that can be defined in C into several
categories.  The main categories are: the <tt>void</tt>
type, the base arithmetic types (<tt>char</tt>,
<tt>int</tt>, <tt>unsigned long</tt>, <em>etc</em>),
pointers, arrays, aggregates (<tt>struct</tt> and
<tt>union</tt>), functions, enumerations, and
<tt>typedef</tt>s.  In addition, Cinquecento also has
separate categories for bitfields, enumeration
constants, and undefined types.
</p>

<p>
Each type used by a C program is represented in
Cinquecento as a combination of instances of these
categories.  Cinquecento has a distinct ctype
constructor for each category, a predicate to test a
ctype instance for membership in the category, and
accessors for category-dependent attributes such as the
fields of an aggregate and the pointed-to type of a
pointer.
</p>

<p>
Cinquecento ctypes represent both C type names and C
type definitions.  Type names are the syntactic
constructions, such as <tt>int*</tt>, that can appear
in C declarations, or as operands to type operations
such as <tt>sizeof</tt> and explicit casts.
Type definitions specify the encoding in memory of the
value of a C type.  For base types, this specification
includes the number of bytes that represent the value
and how the bytes are to be interpreted (e.g., big- or
little-endian order).  For pointer types, it includes
the size and representation of the pointer value
memory.  For aggregates, it includes the offset from
the beginning of the aggregate to each field and
the overall size of the aggregate.
</p>

<p>
The distinction between type name and definition
matters when the same type name different domains have
types with the same name.  For example, the type name
<tt>int*</tt> always corresponds to the type
pointer-to-<tt>int</tt>, but there are many possible
definitions.  One domain can define it to be a 64-bit
address of a 64-bit integer encoded in big-endian
order, while another may be define it be a 32-bit
address of a 32-bit integer encoded in little-endian
order.
</p>

<div id="table">
<table>
<tr>
<th>Type category</th>
<th>Name properties</th>
<th>Definition properties</th>
</tr>

<tr>
<td>
Arithmetic
</td>
<td>
Name (<tt>int</tt>, ...)
</td>
<td>
Name (<tt>int</tt>, ...)<br />
Size and encoding
</td>
</tr>

<tr>
<td>
Aggregate
</td>
<td>
Tag
</td>
<td>
Tag (optional)<br />
Size<br />
Fields
</td>
</tr>

<tr>
<td>
Array
</td>
<td>
Element type<br />
Count (optional)
</td>
<td>
Element type<br />
Count (optional)
</td>
</tr>

<tr>
<td>
Function
</td>
<td>
Return type<br />
Parameters
</td>
<td>
Return type<br />
Parameters
</td>
</tr>

<tr>
<td>
Enumeration
</td>
<td>
Tag
</td>
<td>
Tag (optional)<br />
Size and encoding (optional)<br />
Constants (optional)
</td>
</tr>

<tr>
<td>
Typedef
</td>
<td>
Identifier<br />
</td>
<td>
Identifier<br />
Aliased type
</td>
</tr>

<tr>
<td>
Pointer
</td>
<td>
Pointed-to type
</td>
<td>
Pointed-to type<br />
Size and encoding
</td>
</tr>

<tr>
<td>
Void
</td>
<td>
None
</td>
<td>
None
</td>
</tr>

</table>
</div>

<p>
Type names and type definitions are first-class
Cinquecento values represented by the type
<em>ctype</em>.  Whether a ctype value represents a
type name or a type definition depends on its
properties.  Usually it is clear from the context in
which the ctype was produced.
</p>

<p>
There is a ctype constructor for each type category.
For a given category, the same constructor can generate
either a type name or a type definition, depending on
the arguments.  The constructors are:
</p>

<div id="table">
<table>
<tr>
<th>Type category</th>
<th>Name constructor</th>
<th>Definition constructor</th>
</tr>
<tr>
<td>
Arithmetic
</td>
<td>
<div id=symbols>
mkctype_base(<em>base</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_base(<em>base</em>, <em>rep</em>);
</div>
</td>
</tr>

<tr>
<td>
Aggregate
</td>
<td>
<div id=symbols>
mkctype_struct(<em>tag</em>);<br />
mkctype_union(<em>tag</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_struct(<em>tag</em>, <em>fields</em>, <em>sz</em>);<br />
mkctype_union(<em>tag</em>, <em>fields</em>, <em>sz</em>);<br />
</div>
</td>
</tr>

<tr>
<td>
Array
</td>
<td>
<div id=symbols>
mkctype_array(<em>ctype</em>, <em>count</em>);<br />
</div>
</td>
<td>
<div id=symbols>
mkctype_array(<em>ctype</em>, <em>count</em>);<br />
</div>
</td>
</tr>

<tr>
<td>
Function
</td>
<td>
<div id=symbols>
mkctype_fn(<em>ctype</em>, <em>params</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_fn(<em>ctype</em>, <em>params</em>);
</div>
</td>
</tr>

<tr>
<td>
Enumeration
</td>
<td>
<div id=symbols>
mkctype_enum(<em>tag</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_enum(<em>tag</em>, <em>ctype</em>, <em>consts</em>);
</div>
</td>
</tr>

<tr>
<td>
Typedef
</td>
<td>
<div id=symbols>
mkctype_typedef(<em>id</em>);
</div>
</td>
<td>
<div id=symbols>
mkctype_typedef(<em>id</em>, <em>ctype</em>);
</div>
</td>
</tr>

<tr>
<td>
Pointer
</td>
<td>
<div id=symbols>
mkctype_ptr(<em>ctype</em>);
</div id=symbols>
</td>
<td>
<div id=symbols>
mkctype_ptr(<em>ctype</em>, <em>rep</em>);
</div>
</td>
</tr>

<tr>
<td>
Void
</td>
<td>
<div id=symbols>
mkctype_void();
</div>
</td>
<td>
<div id=symbols>
mkctype_void();
</div>
</td>
</tr>

</table>
</div>

<p>
Arguments corresponding to optional properties may be
<tt>nil</tt>.

<p>
The <em><tt>fields</tt></em> parameter is a vector of
field definitions.  Each field definition is a vector
of four elements:
</p>

<div id="inset">
<p>
<tt>vector(<em>ctype</em>, <em>id</em>, <em>offset</em>, <em>width</em>);</tt>
</p>
</div>

<div id="noindent">
<p>
where <em><tt>ctype</tt></em> is the type of the field,
and <em><tt>id</tt></em> is the name of the field.  If
the field is a bitfield, then <em><tt>width</tt></em>
is the width in bits of the field and
<em><tt>offset</tt></em> is the bit offset from the
beginning of the aggregate to the start of the
bitfield.  Otherwise, <em><tt>width</tt></em> is
<tt>nil</tt>, and <em><tt>offset</tt></em> is the
<em>byte</em> offset from the beginning of the
aggregate to the start of the field.

</p>
</div>

<p>
The <em><tt>params</tt></em> parameter is a vector of
function parameter definitions, ordered by parameter
position.  Each parameter definition is a vector of two
elements:
</p>

<div id="inset">
<p>
<tt>vector(<em>ctype</em>, <em>id</em>);</tt>
</p>
</div>

<div id="noindent">
<p>
where <em><tt>ctype</tt></em> is the type of the
parameter, and <em><tt>id</tt></em> is the name of the
parameter or <tt>nil</tt>.
</p>
</div>

<p>
The <em><tt>consts</tt></em> parameter is a vector of
enumeration constant definitions.  Each constant
definition is a vector of two elements:
</p>

<div id="inset">
<p>
<tt>vector(<em>id</em>, <em>value</em>);</tt>
</p>
</div>

<div id="noindent">
<p>
The exact behavior of <tt>mkctype_enum</tt> remains a mystery.
</p>
</div>

<p>
Part of the role of a Cinquecento name space is to
define a set of C types.  This is implemented by
defining a function, conventionally
called <tt>looktype</tt>, that maps type names to type
definitions.  The argument to this function is a ctype
that <tt>looktype</tt> treats as a type name.  It
returns the corresponding definition for that name,
or <tt>nil</tt> if there is no definition.
</p>

<p>
Most name spaces are defined by the <tt>@names</tt>
operator, which translates C declarations into a
definition of a name space.  The name space
constructor <tt>mkns</tt> provides an alternate way to
define a name space.  The argument to mkns is a table,
conventionally named <tt>typetab</tt>, that maps type
names to type definitions.
</p>

<p>
Unlike <tt>looktype</tt>, the type names to
which <tt>typetab</tt> maps names do not need to be
fully defined type names.
</p>

<h3>I/O</h3>

<p>
Cinquecento supports I/O over regular files and network
connections.
</p>

<p>
An open file or network connection is represented by an
instance of the file descriptor type.
</p>

<p>
The function <tt>open(<em>filename</em>,
<em>mode</em>)</tt> opens the file named
<tt><em>filename</em></tt> and returns the associated
file descriptor.  Both <tt><em>filename</em></tt> and
<tt><em>mode</em></tt> are
strings. <tt><em>Mode</em></tt> specifies whether the
file is to be opened for reading, writing, or both, and
whether the file is to be created or truncated.  The
syntax of <tt><em>mode</em></tt> follows that of the C
library stdio <tt>fopen</tt> function.  Common modes
are <tt>"r"</tt> (read an existing file) <tt>"w"</tt>
(truncate an existing file for writing), and "rw"
(truncate an existing file for reading and writing).
</p>

<p>
The function <tt>read(<em>fd</em>,<em>len</em>)</tt>
reads at most <tt><em>len</em></tt> bytes from the I/O
resource associated with <tt><em>fd</em></tt>.  The
result is returned as a string.  <tt>Nil</tt> is
returned if end of the file is encountered and no other
bytes are read.  An error is raised for all I/O
exceptions.
</p>

<p>
The function <tt>write(<em>fd</em>,<em>str</em>)</tt>
writes the bytes contained in the string
<tt><em>str</em></tt> to the I/O resource associated
with <tt><em>fd</em></tt>.  <tt>Nil</tt> is returned
unless an error occurs, in which case an error is
raised.
</p>

<p>
The function <tt>close(<em>fd</em>)</tt> closes the I/O
resource associated with <tt><em>fd</em></tt>.  Any
pending buffered output is written.  A call to close on
already closed descriptor has no effect.  Any other A
call to <tt>read</tt> or <tt>write</tt> on a closed
descriptor draws an error.
</p>

<p>
UNIMPLEMENTED.  The function <tt>fdname</tt> returns
the name of the resource associated with <tt>fd</tt>.
</p>

</p> </div> </body> </html>
