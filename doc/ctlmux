ctlmux is a Cinquecento library for tracing
the execution of running programs.

ctlmux defines two abstractions:

* A ctl represents a traced execution.  An execution
  corresponds to a single-threaded process or one
  thread of a multi-threaded process.  In this manual
  the term "process" generally refers to either form of
  execution.

  Events in the traced execution --- death, signals,
  system calls, creation of a new thread, execution of
  a new program, arrival at a breakpoint --- are
  reflected as ctl events.  Users register handler
  functions to be called in response to ctl events.

  Behind every ctl are two Cinquecento address spaces
  that reflect the current state of the execution's
  memory and its registers.  Ctls for a multi-threaded
  process usually share a memory address space, while
  each ctl has its own register address space.

* A mux is a multiplexor of ctl events over a set of
  concurrently executing ctls.


Include the cltmux library:

	@include <ctlmux.cqct>


Create a fresh mux:

	mux = ctlmux();

This mux can control threads and processes on the local
machine, but not (for now) those on other machines.


Instantiate a ctl, in one of two ways:

1. Launch a new process:

	ctl = mux.launch([cmd, arg, ...], flags);

	[cmd, arg, ...] is the list of arguments used
	to exec the program; i.e., argv[0] = cmd,
	argv[1] = arg, etc.

	flags is any combination of the following flags.

		ctlmux`Fstdin		- redirect target stdin
		ctlmux`Fstdout		- redirect target stdout
		ctlmux`Fstderr		- redirect target stderr

	These redirections allow the stdio of the
	target to be read or written through the ctl.
	If flags is 0 or nil, the target process inherits the
	stdio of the calling process.

	The resulting process is stopped at the return of the
  	(successful) call to exec.


2. Attach to an existing process:

	ctl = mux.attach(pid);

	pid is the process id of the target thread.

	The target process is left running.


Ctls define several methods

	ctl.id()	return process identifier

	ctl.xstop()	pause execution
	ctl.xcont()	resume execution
	ctl.xstep()	single step

	ctl.detach()	discontinue tracing
	ctl.kill()	terminate target

	ctl.mem()	return memory address space
	ctl.reg()	return register address space

	ctl.trace(event, handler)
	
		register a handler to be called when
		events occurs on the ctl.

		the signature of the handler depends on
		the type of the event.

		ctlmux`Esyscall		(ctl)		enter/exit system call
		ctlmux`Eexec		(ctl)		successful exec return 
		ctlmux`Esignal		(ctl)		signal
		ctlmux`Eexit		(ctl)		exit
		
		ctlmux`Efork		(ctl, newctl)	successful fork return
		ctlmux`Eclone		(ctl, newctl)	successful clone return



