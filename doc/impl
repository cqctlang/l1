grammar
-------

why we have a separate tn_type_specifier:
- to force domain-relative ` names when using a typedef name
- ...

@names evaluation
-----------------

why we generate code for @names:
- user should be able to programmatically make any @names.
  by generating code, we ensure completeness and correctness of that support;
- some @names expressions must be evaluated at run time, when @names is eval'd;
  generating code provides natural form to eval and combine those results
- generating code for enum definitions still broken.


garbage collection
------------------

the gc is based on the concurrent gc described in

	l. huelsbergen and p. winterbottom.  very concurrent
	mark-&-sweep garbage collection without fine-grained
	synchronization.  ismm'98.

we want an efficent, simple incremental gc that can
(optionally) run concurrently with low synchronization
overhead.

a key property is how references to objects stored in
mutable data structures (boxes, vecs, dicts) are safely
tracked:

	- new objects (halloc'd) are marked upon creation;
	  they will not be swept until two rounds pass without finding
	  a reference;
	- clobbered objects are marked upon clobber;
	  they will not be swept;
	- new inserted objects either recently halloc'd
	  or are referenced elsewhere -- even in missed, they will
	  survive to next round.

FIXME: rationalize w/ gcrun test

our implementation differs from the paper in several
ways.

the rootset structure records objects to be marked.
the rootset implementation is based on the non-blocking
set data structure given in the appendix.

there are two rootsets:

   roots - root set calculated at beginning of gc epoch by gc;
   stores - objects dynamically replaced during gc by mutator.

the paper defines only the stores root set.  the
function of our roots root set is mantaining the state
of the marker as it traverses reachable heap objects.
in the paper, the inferno implementation instead uses
an additional propagator color to avoid recursion,
implementing marking by repeatedly scanning the heap
until no new propagators are added.  this approach of
requiring many heap scans per gc epoch seems wrong --
it seems we should enable gc epochs to complete as soon
as possible -- but we have not measured.  the sml/nj
implementation uses a fixed size stack; we wish to
avoid arbitrary limits.

the reason the two rootsets cannot be collapsed into a
single one is the semantics of the non-blocking
operators insert and remove.  insert and remove can be
called by different threads without synchronization,
but insert and remove are not reentrant, so two threads
cannot both call insert or remove.  gc calls remove for
both roots and stores; mutator calls insert for stores,
while gc calls insert for roots.

in addition, it is necessary to maintain two link
fields in the heap objects (Heads) because insertion is
not atomic.  insert first checks whether the heap
object is already on a rootset before adding it.
this is a racey check, but it seems the worst case an object
shows up more than once in the same rootset
(however, we have not yet reasoned carefully about the race.)
we could use locked cmpxchg, but that would add global
synchronization on each write barrier.

it is possible for a heap object to be on both root
sets simulataneously.  this is inefficient but not
incorrect (the marker will update its color the first
time it encounters the object, then harmlessly do so
again -- to the same color value -- the second time).
similarly, the same heap object may be inserted in a
root set multiple times within an epoch.  the argument
in the paper (section 2.3) for epoch termination still
holds in our implementation.

explict synchronization between gc and mutator occurs
at (1) the start of epoch, (2) checking for termination
of epoch, and (3) mutator-directed termination of gc.
synchronization is implemented by atomic r/w memory
operations on two shared boolean variables and r/w i/o
operation on a bi-directional pipe.

	  gcpause - set by mutator, read by gc
	  gcrun - set by gc, read by mutator

when not collecting, gc thread blocks on read of its
end of pipe.  mutator is responsible for deciding when
gc should occur.  it signals gc by writing byte GCrun
to its end of pipe, then does blocking read on its end.
gc sets variable gcrun to non-zero, then writes
GCrunning to its end of pipe.

after sweeping gc pauses mutator to allow gc consistent
view of stores root set by setting gcpause non-zero and
then blocking on pipe read.  mutator polls gcpause on
each tick; when it sees it non-zero, mutator writes
GCpaused to pipe, then blocks on pipe read.  after gc
read unblocks, gc checks root set then resumes mutator
by clearing gcpause and writing GCresume to pipe.

after epoch gc clears gcrun and blocks on pipe read.

to signal termination, mutator writes GCdie to pipe
then blocks on read.  gc receives GCdie either at start
of epoch or when pausing to check store set.  at start
of epoch, gc terminates.  at store check pause, gc
schedules termination at end of epoch but finishes
epoch without blocking for subsequent pauses (which is
correct, since mutator is paused waiting for GCdie).

it seems possible to abort gc before end of epoch.
before resuming, rootsets should be flushed.
seems like gcepoch should be kept at value of aborted
gc epoch; what would happen if it were incremented?




compilec
--------

early compiler pass to convert C lvalue operations into calls to
cinquecento operations.

cases:
	&a                       where a is array type
	          (seems equivalent to &(a[0]))

	(any operator)(dom`x)    where x is an enum constant

	(any operator)E          where E is ptr to incomplete type

	bitfield lvalue escapes before being referenced
		 e.g., how do we trap &s.bitfield ?


compile_rvalue(E) :
	match(E):
	- dom`sym
	{
		@local dom, type, addr;
		[ compile_lvalue(dom`sym, < dom, type, addr >); ]
		/*
		 * rvalue magic:
		 *     type is base type     call dom.as.get
		 *     type is ptr           call dom.as.get
                 *     type is array         generate equivalent pointer cval
                 *     type is enum const    generate equivalent enum cval
		 *     type is bitfield	     access as bitfield
		 *     type is aggregate     error
		 */
		rvalue(dom, type, addr);
	}		

	- *E
	{
		@local dom, type, addr;
		[ compile_lvalue(*E, < dom, type, addr >); ]
		rvalue(dom, type, val);
	}

	- E.field
	{
		@local dom, type, addr;
		[ compile_lvalue(E.field, < dom, type, addr >); ]
		rvalue(dom, type, addr);
	}

	- &E
	{
		@local dom, type, addr;
		[ compile_lvalue(E, < dom, type, addr >); ]
		ref(dom, type, addr);
		/* equivalent to rvalue(dom, mkarr(type,0), addr) ? */
	}

	- E1[E2]
	{
		[ compile_rvalue(*(E1+E2)); ]
	}

	- E1->field
	{
		[ compile_rvalue((*E1).field); ]
	}

	- E1 = E2
	{
		@local dom, type, addr, val;
		val = [ compile_rvalue(E2); ];
		[ compile_lvalue(E1); ]
		val = {type}val;
		dom.as.put(addr, sizeof(type), encode(val));
		val;
	}

	- E++
	{
		@local dom, type, addr, val;
		val = [ compile_rvalue(E); ]  /* reuse dom, type, addr */
		dom.as.put(addr, sizeof(type), encode(val+1));
		val;
	}

	- E--
	{
		@local dom, type, addr, val;
		val = [ compile_rvalue(E); ]  /* reuse dom, type, addr */
		dom.as.put(addr, sizeof(type), encode(val-1));
		val;
	}

	- ++E
	{
		@local dom, type, addr, val;
		val = [ compile_rvalue(E); ]  /* reuse dom, type, addr */
		val = val+1;
		dom.as.put(addr, sizeof(type), encode(val));
		val;
	}

	- --E
	{
		@local dom, type, addr, val;
		val = [ compile_rvalue(E); ]  /* reuse dom, type, addr */
		val = val-1;
		dom.as.put(addr, sizeof(type), encode(val));
		val;
	}

	- E1 += E2;
	{
		@local dom, type, addr, u, v;
		u = [ compile_rvalue(E2); ]  /* reuse dom, type, addr */
		v = [ compile_rvalue(E1); ]  /* reuse dom, type, addr */
		v = {type}(v+u);
		dom.as.put(addr, sizeof(type), encode(val));
	}	

	- etc for other x= operators

	- else
	{
		[ E ]
	}


/* always assume this expression is substituted in block with
   < dom, type, addr > bindings. */
/* binds to dom the domain of E, to type its type, and to addr its
   address as a literal cval */
compile_lvalue(E, < dom, type, addr > ) :
	match(E)
	- dom`sym
	{
		@local tmp;
		dom = [ dom ];
		tmp = dom.ns.looksym("[ sym ]");
		if(tmp == nil)
			error("no such symbol %s", "[ sym ]");
		type = vecref(tmp, 0);
		addr = vecref(tmp, 2);
	}

	- *E
	{
		@local tmp;
		tmp = [ compile_rvalue(E) ];
		dom = domainof(tmp);
		type = ptrsub(typeof(tmp));
		addr = {litdom}{nsptr(dom.ns)}tmp;
	}

	- E.field
	{
		[ compile_lvalue(E) ];   /* reuse dom, type, addr bindings */
		tmp = lookfield(type, "[ field ]");
		type = tmp[0];
		addr = addr + tmp[2];
	}

	- E1[E2]
	{
		[ compile_lvalue(*(E1+E2)); ]
	}
	
	- E1->field
	{
		[ compile_lvalue((*E1).field); ]
	}

	- else
	compile_error("bad lvalue");

calling convention
------------------

	fpx
	clx
	pcx
	argn
	...
	arg2
	arg1
fp0->	narg
	local1
	local2
	...
	localn
	temp1
	temp2
	...
sp0->	tempn


frame L:
	sp -= 3
	stack[sp] = L
	stack[sp+1] = cl
	stack[sp+2] = fp

ret:
	let* narg = stack[fp+1]
             sp = fp-(narg+1) in
	    pc = stack[sp]
	    cl = stack[sp+1]
	    fp = stack[sp+2]
	    sp += 3

apply C:
	cl = C
	pc = C.entry
	fp = sp;
		
call sequence looks like:
            frame <ret addr>
            code for args
            call
<ret addr>: ; return value in %ac

why there is both a frame and call insn
     - simplifies stack fixup on tail calls
	- we just slide the arguments up
     - otherwise i don't think it matters



Representation of C types and declarations
------------------------------------------

Decl represents a C declaration.

Type *type

	The type of the declared object.

	Type storage is managed by type tables; ignored by freedecl.

char *id

	The identifier of the declared object.  It is NULL for abstract
	declarators (function parameters).  Tagged types without
	declarators, such as

		struct foo { int x; };

	that are generated by declaration productions are represented
	as Decls with NULL ids.

	Freed by freedecl.

Expr *offs

	Optional offset specifiers occur in toplevel declarations or
	in struct/union declarations.  Offs is the uninterpreted parse
	tree of the expression.

		@<expr> int x;
		struct foo {
			@<expr> int z;
		};

	Freed by freedecl.

Expr *bits

	Optional bitfield size occurs in struct/union declarations.
	Bits is the uninterpreted parse tree.

	Freed by freedecl.

Decl *link

	Pointer to next element in declaration list.  NULL means end
	of list.  Three productions create declaration lists:

	- toplevel declarations, e.g.,

	  int x;
	  int y, z;
	  int a, b, c;

	  yield a list of declarations in left-to-right, top-to-bottom order;

	- a struct and union declaration, e.g.,

	  struct {
	  	int x;
		int y, z;
		int a, b, c;
	  };

	  yields a Type whose field element contains a similarly
	  ordered declaration list;

	- a function declaration, e.g.,

	  int fn(int x, int y, int z, int, int);

	  yields a Type whose param element contains a similarly
	  ordered declaration list.  (Its elements may include
	  abstract declarators.)

	Recursively freed by freedecl.


Type represents a C type.

unsigned kind

	Kind is Tbase, Tstruct, Tunion, Tenum, Tptr, Tarr, or Tfun.

	The system defines a Tbase Type for each primitive base type
	Base type references resolve to them.

char *tag

	Tag identifier for struct, union, and enum type.
	Untagged struct, union, and enum type declarations have NULL tag.
	
	Freed by freetype.

Decl *field

	Declaration list for struct and union types.

	Offsets are associated with the first declarator in a struct/union
	declaration:

	struct foo {
		int x, y;
		@0x8 int z, a, b;
		int c;
	};

	yields a five-element declaration list, the third of which has
	an offset for the expression 0x8 and identifier z.

	struct/union declarations that contain only an offset yield a
	separate element (in order) in the field declaration list:

	struct foo {
		int x, y;
		@0x8;
		int z, a, b;
		int c;
	};

	Field elements (and only field elements) may have bits defined. 

	The element has a defined offs and link field, but is
	otherwise NULL.

	Freed by freetype.

Enum *en;

	List of defined enum constants in lexical definiion order:

	typedef
	struct Enum {
		char *id;
		Expr *val;
		Type *type;
		Enum *link;
	} Enum;

	ID is the identifier for the constant.
	VAL is a symbolic expression for the value of the constant;
	it is present regardless of whether the input enum definition
	supplied a value.
	TYPE is the type defining the enum (i.e., en->type->en == en).
	LINK points to the next constant.

Expr *sz;

	A final offset declaration in a struct/union:

	struct foo {
		int x;
		int y;
		@<expr>;
	};

	is represented like an ordinary offset as an uninterpreted
	expression parse tree in the sz field of the Type, and is not
	included as the final or any other element of the field
	declaration list.

	Freed by freetype.

Decl *param

	Represents the parameters of a function (Tfun) Type.

	NULL if the function has an empty parameter list.

	The parser accepts var arg declarations (containing "...")
	but discards the elipses, e.g.,

		int foo(int x);
		int bar(int x, ...);
	
	have structurally equivalent param lists.

	Decls in param lists may be abstract declarators (NULL id).
	They always have NULL offs and bits.

	Freed by freetype.

Expr *cnt

	Represents that size expression of an array (Tarr) type.

	NULL if the declaration omits a size.

	Freed by freetype.

Type *link

	The Type modified by a pointer (Tptr) or array (Tarr) Type,
	or returned by a function (Tfun) Type.

	Ignored by freetype; type storage is managed by type tables.

unsigned char flags

	Ffwd: set for a Type yielded by parsing a forward declaration
	of struct/union/enum type.  A forward declaration looks like

		struct foo; /* omitting { } */
	
	Struct/unions with no fields are declared as

		struct foo {}; /* omitting { } */

	and do not have Ffwd set.

	Both forms yield NULL fields.


	There are no other flags.
