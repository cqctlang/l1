
Quick Introduction to Cinquecento
---------------------------------

Cinquecento is a programming language designed to help
programmers examine the state of programs in execution,
in particular C programs.

Two implementations of Cinquecento exist.  The original
implementation is called CQCT.  It is written in
Scheme.  You run it in a Scheme environment.  CQCT was
developed for guile, but it works in Chez, SISC, and
probably other Scheme implementations.

The successor to CQCT is called L1.  It is written in
C.  You need gcc, bison, flex, a minimal libc, and
(optionally) pthreads to build it.  L1 runs on Linux
and Mac OSX and probably any recent Unix derivative.
It has a few x86 dependencies.

L1 and CQCT implement slightly different versions of
the Cinquecento language, unfortunately.  The main
differences are that L1 implements several types,
syntax forms, and built-in functions not present in
CQCT; re-defines the representation of Cinquecento
domains; and re-names several built-in functions.

This introduction assumes you are using L1.  L1 is
faster than CQCT and runs with less hassle in more
places.  It has a fairly complete reference manual.


How to build L1
---------------

First, obtain L1.  The tree unpacks into a directory
conventionally named l1.

Then, compile it.

	% cd l1
	% make

By default the Makefile produces an executable called
l1.  This is a standalone interactive Cinquecento
evaluator.  Examples in this introduction can be run in
this evaluator.

Optionally, the Makefile can generate a .so or .o
object.  This is used to embed Cinquecento in other
programs.  This embedding may affect the way you
interact with Cinquecento but does not change the
language; examples in this introduction work unchanged.

To clean up,

	% make clean

removes all binaries created by "make" including the l1
executable.  It also clears any test suite failures
(see below).


How to test L1
--------------

L1 comes with a test suite.  Users need not run the
tests, but would do no harm if they did.  Contributors
of L1 modifications should ensure that the tests
survive their changes; ideally, they should also
provide new tests.

To run the tests from the L1 tree, first build the l1
executable as above.  Then

	% cd test
	% ./test.py

The test suite driver is written in Python.  We use
Python 2.5.2; we don't know how dependent the driver is
on Python version.

The test driver prints a line for each test, then a
summary that looks like

	197 ok 0 new 0 fault 0 fail

This says that all 197 of the tests passed.  You're in
trouble if any of the tests fault (crash or abort l1)
or fail (produce unexpected output).

You can add a new test simply by adding a new file with
the .l1 extension in the test directory.  It will show
up as "new" the first time it is tested; subsequent
runs will check for output identical to the first one.

The command

	% ./valgrind.py

will run the test suite under Valgrind (which must be
separately installed) to find memory errors in the L1
implementation.


Interacting with Cinquecento
----------------------------

The examples presented in this introduction can be
executed interactively with the l1 executable.

To start l1 from the L1 directory, run

	% ./l1
	;

The ';' is the interactive L1 prompt.

	; printf("hello, world\n");
	hello, world

The l1 evaluator has a rudimentary interface that does
support history or readline-like editing.  Some users
run l1 in an emacs subshell or under a program like
rlwrap to gain history and editing support.

While the interactive prompt is fine for simple
one-line expressions, a more convenient way to send
complex input to L1 is to load it from a file:

	; @include "hello.l1"

This reads the file "hello.l1" from the current working
directory of the L1 process and evaluates its contents.

Loading from a file is especially convenient for
multi-line input.


Basic Expressions
-----------------

Cinquecento input consists of a sequence of
expressions.

The core syntax of expressions is based on C.

Expressions include simple C expressions:

	; 3+4;
	7

	; (0x5>>1)&2;
	2

Note that simple expressions must be terminated with a
semicolon.

The binary and unary operators of C
(+,-,*,/,%,&,|,^,>>,<<,!,~) have equivalent semantics
in Cinquecento.

	; ~0;
	-1

Likewise, syntax for integer literals follows that of C.

	; ~0ULL;
	18446744073709551615

(The difference between the previous examples is that 0
by itself is a signed integer literal, while 0ULL is an
unsigned literal.)

Another set of forms of Cinquecento expressions are C
statements.  This expression:

	for(i = 0; i < 5; i++){
		if(i%2 == 0)
			printf("%d\n", i);
	}

prints even integers between 0 and 5:

	0
	2
	4

Note that expressions based on C statement blocks need
not be terminated with a semicolon.

