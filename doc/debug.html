<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Debugging with Cinquecento</title>
<link rel="stylesheet" type="text/css" href="reset.css"/>
<link rel="stylesheet" type="text/css" href="styles.css"/>
</head>

<body>

<div id="side1">
<a href="#sec:introduction">Introduction</a><br />
<br />
<a href="#sec:ns">Name spaces</a><br />
<a href="#sec:ctls">Controlling executions</a><br />
<a href="#sec:nsmap">Name space maps</a><br />
<a href="#sec:sctlns">Interface to sctl</a><br />

<br />
<a href="#sec:fnindex">Index</a><br />

</div>

<div id="content">

<div id="title">
<h3>Debugging with Cinquecento</h3>
</div>

<h4 id="sec:introduction">Introduction</h4>

<p>
This manual describes a set of Cinquecento libraries
that can be used to examine program executables and
debug program executions.
</p>

<p>
To use these libraries the process control
server <span class="val">sctl</span>, which is
available
from <span class="val"><a href="http://cqctworld.org">cqctworld.org</a></span>,
must be installed somewhere in your
path. <span class="val">Sctl</span> provides a network
service for controlling program executions and
accessing symbols and other debugging information from
program binaries.  Documentation
for <span class="val">sctl</span> accompanies its
distribution, and should be read in conjunction with
this manual.  For example, you should refer to the
<span class="val">sctl</span> documentation for details
about the various <span class="val">sctl</span>
transactions referenced in this manual.
</p>

<p>
Keep in mind that the syntax and core abstractions of
the Cinquecento language are intended to support a
variety of styles for programming a custom debugger.
The libraries described in this manual represent just
one style &mdash; a rather traditional one.
</p>

<h4 id="sec:hello">Concepts</h4>

<p>
The library is designed to support a spectrum of
debugging scenarios, from debugging a one instance of a
single-threaded program to debugging multiple
simultaneously active instances of multi-threaded
programs.  Most operations are centered around an
object called a <em>ctl</em>, which represents a thread
of execution in a program execution.  A single-threaded
program is represented by a single ctl; a
multi-threaded program is represented by a set of ctls,
one for each live thread.  Ctls are created by
launching a new program execution or attaching to an
existing one; they are also created when an execution
associated with an existing ctl forks a new process or
creates a new thread.  Ctls are destroyed when the
associated thread or process is terminated.
</p>

<p>
Each ctl is a handle to other resources associated with
an execution, including its registers, address space,
name spaces for each binary (executable or library)
loaded in the address space, and the ability to trap on
execution events.
</p>

<p>
The events that can trapped include execution
breakpoints, library loading and unloading, system
calls, signals, and termination.
</p>

<p>
<span class="val">Sctl</span> supports execution
snapshots, which represent the state of a program
execution frozen in time.  Snapshots are useful for
retaining access to past states of program execution
for comparison with future states.  A snapshot is
represented by a ctl.
</p>

<p>
The programming model is event-based programming.
Rather than pausing the execution and interactively
inspecting state or adding or removing traps, programs
written with this library are non-interactive programs
that instrument an entire execution of the target
program.  They respond to events as the execution
proceeds, collecting observations, adjusting traps, and
perhaps making changes to program state.  The
interactive model can be convenient for debugging
single-threaded programs, but it quickly becomes
cumbersome when the program is multi-threaded, or when
more than one program is being debugged at a time, or
when incorporating snapshots into the debugging.
</p>

<p>
Like many event-based programming system, the execution
of a program is wrapped in a blocking event loop.
Events from program execution are received and
dispatched to their handlers.  This event processing
loop is encapsulated in an object called a <em>sctlmux</em>.
Most programs have the same structure:
<ol>
<li>Initialize a sctlmux.</li>
<li>Launch or attach to one or more programs, yielding a corresponding ctl for each thread of execution.</li>
<li>Define and install handlers for various events on the ctls.</li>
<li>Start the sctlmux event loop.</li>
</ol>
</p>

<p>
Event handlers typically collect observations about the
program execution.  They can also set or remove event
handlers.  The event loop terminates when all ctls have
exited.
</p>


<h4 id="sec:hello">Getting started</h4>

<p>
In the following sections, we illustrate the main
features of the library through a series of examples.
This requires that we have some sample programs to
debug.  These samples, as well as the Cinquecento
examples, are included in the L1 distribution of
Cinquecento; see the <span class="val">README</span> in
the <span class="val">demo</span> directory for
directions on building and running these examples
yourself.
</p>

<p>
Here is <span class="val">list</span>, our first sample program:
</p>

<div class="code">
<pre>
#include &lt;stdlib.h&gt;

typedef struct Node Node;
struct Node {
	int v;
	Node *next;
};

static Node*
insert(Node *h, int v)
{
	Node *p, *q;
	p = malloc(sizeof(Node));
	p->v = v;
	p->next = 0;
	if(!h)
		return p;
	q = h;
	while(q->next)
		q = q->next;
	q->next = p;
	return h;
}

static void
dowork(int n)
{
	int i;
	Node *head;
	head = 0;
	for(i = 0; i < n; i++)
		head = insert(head, i);
}

int
main(int argc, char *argv[])
{
	int m;
	m = 5;
	if(argc > 1)
		m = atoi(argv[1]);
	dowork(m);
	return 0;
}
</pre>
</div>

<p>
This program features a pointer-based linked list data
type called <span class="val">Node</span>, a function
called <span class="val">insert</span> that appends new
elements to an existing list, a function
called <span class="val">dowork</span> that builds a
list of consecutive values, and
a <span class="val">main</span> function that kicks off
the work.  It accepts an optional work size input as a
command-line argument.  It has no output.
</p>

<p>
Here is a Cinquecento function that launches this
program and waits for it to exit:
</p>

<div class="code">
<pre>
@include &lt;debug.cqct&gt;

@define getstarted()
{
	@local mux;
	mux = mksctlmux();
	ctllaunch(mux, ["./list"]);
	mux.run();
}
</pre>
</div>

<p>
The first line loads the debugging library.  We will
omit this line from all subsequent examples, but it is
always implied.
</p>


<p>
The first line of getstarted (after the @local
declaration) creates a new sctlmux object, binding it
to the variable mux.  Mux represents a connection to a
fresh sctl server that is launched by mksctlmux on the
same host as the Cinquecento program.
</p>

<p>
The second line of getstarted launches our sample
program.  Ctllaunch directs the sctl associated with
mux to create a new process.  The second argument
specifies the program this new process should execute:
in Unix environments, for example, it is a list of
strings that will be passed to execve.  In this case,
we are launching the list binary from the current
working directory, passing it no arguments.
</p>

<p>
Ctllaunch returns a ctl representing the new program
execution.  We conventionally bind this value to a
variable named ctl, but since this example does not do
anything with this value, we leave it out to avoid
drawing an unused variable warning.
</p>

<p>
Ctllaunch leaves the new program execution in a stopped
state, paused just before execution of its first instruction.
Note that most programs perform many initialization
functions before reaching the first instruction of
main, such as initializing the dynamic loader, loading
and initializing library dependencies, and so on.
Ctllaunch pauses the new execution at truly the first
instruction.
</p>

<p>
The third line of getstarted starts the execution.  The
run method tells the mux to resume the program launched
by the ctllaunch and to block until it has exited.  If
we had launched more than one program with additional
calls to ctlmux, these would all be resumed
simultaneously, and the call to run would block until
they all exited.  If we had registered any handlers for
executions events, as we will do in all of the
following examples, the mux would dispatch these events
in the context of the call to run.
</p>

<p>
In summary, calling getstarted launches our sample program
and waits for it to exit.  It yields no output.
</p>

<div class="code">
<pre>
; getstarted();
;
</pre>
</div>

<p>
To reduce boilerplate code in subsequent examples, we
will use the following function to launch our sample
programs:
</p>

<div class="code">
<pre>
@define start(cmd)
{
	@local mux, ctl, exe;
	mux = mksctlmux();
	ctl = ctllaunch(mux, cmd);
	exe = ctl.exe();
	return [mux, ctl, exe];
}
</pre>
</div>



<h4 id="sec:breakpoints">Setting breakpoints</h4>

<h4 id="sec:breakpoints">Accessing state</h4>

<h4 id="sec:breakpoints">Unwinding the stack</h4>

<h4 id="sec:breakpoints">Accessing function arguments</h4>

<h4 id="sec:breakpoints">Accessing local variables</h4>

<h4 id="sec:breakpoints">Examining data structures</h4>

<h4 id="sec:breakpoints">Trapping function return</h4>

Example: test invariant that head is sorted upon return
from doinsert.

<h4 id="sec:breakpoints">Trapping program termination</h4>

<h4 id="sec:breakpoints">Modifying data structures</h4>

<h4 id="sec:breakpoints">Trapping signals</h4>

<h4 id="sec:breakpoints">Trapping system calls</h4>

<h4 id="sec:breakpoints">Trapping fork</h4>

<h4 id="sec:breakpoints">Trapping exec</h4>

<h4 id="sec:breakpoints">Tracing multithreaded execution</h4>

<h4 id="sec:breakpoints">Using snapshots</h4>


<h4 id="sec:ns">Name spaces</h4>

<p>
The debug library defines two functions for constructing
Cinquecento name spaces backed by a sctl server:
</p>

<div class="docitem" id="fn:atnames">
<div class="proto">
<div class="function">
<span class="id">atnames(<span class="arg">path</span>)</span>
</div>
<div class="param">
<span class="arg">path</span>: <span class="type">string</span>
</div>
<div class="returns">
<span class="type">name space</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Returns a name space for the binary
named <span class="arg">path</span>.  The name space is
served by a freshly
launched <span class="val">sctl</span> server on the
calling machine.  The <span class="val">sctl</span>
binary must be in the path of the calling process.
Returns <span class="val">nil</span> if the name space
does not exist.
</div>
</div>

<div class="docitem" id="fn:mksctlns">
<div class="proto">
<div class="function">
<span class="id">mksctlns(<span class="arg">fd</span>,<span class="arg">path</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">path</span>: <span class="type">string</span>
</div>
<div class="returns">
<span class="type">name space</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Returns a name space for the binary
named <span class="arg">path</span>.  The name space is
served by the <span class="val">sctl</span> server
backed by <span class="arg">fd</span>.  The version negotiation
with the sctl server must be performed by calling this function
(see <span class="fnindex"><a href="#fn:sctlversion">sctlversion</a></span>).
Returns <span class="val">nil</span> if the name space
does not exist.
</div>
</div>

<h4 id="sec:ctls">Controlling executions</h4>

<p>
The debug library is designed around a programming
model that is different from the conventional
interactive programming.  It is an event-based
programming model.  It requires an interface for
running the event loop.  This is accomplished
with something called a sctlmux.
</p>

<p>
A ctl represents a thread of execution.
There is an address space, called a mem,
that represents its memory.
There is a notion of its context
that represents the registers
of the system.  Get a pointer
into it.  You can update the context
by changing the values of pointers.
(This needs to be implemented.)
(No setctx method.)
</p>

<div class="docitem" id="fn:mksctlmux">
<div class="proto">
<div class="function">
<span class="id">mksctlmux()</span>
</div>
<div class="returns">
<span class="type">sctlmux</span>
</div>
</div>
<div class="desc">
Returns a new sctlmux backed by a sctl server
freshly launched on the calling machine.
</div>
</div>

<div class="docitem" id="fn:ctllaunch">
<div class="proto">
<div class="function">
<span class="id">ctllaunch(<span class="arg">mux</span>,<span class="val">cmd</span>)</span>
</div>
<div class="param">
<span class="arg">mux</span>: <span class="type">sctlmux</span>
</div>
<div class="param">
<span class="arg">cmd</span>: <span class="type">list of string</span>
</div>
<div class="returns">
<span class="type">ctl</span> or
<span class="type">nil</span> or
</div>
</div>
<div class="desc">
Launches a new program execution, returning
a <span class="val">ctl</span> representing the
execution.  <span class="arg">Cmd</span> is the list
arguments used to run the program; <em>i.e.</em>, on
Unix-based targets these strings are passed
to <span class="id">exec</span>,
with <span class="arg">cmd</span><span class="val">[0]</span>
becoming <span class="val">argv[0]</span>, and so on.
</div>
</div>

<p>
There is currently no way to specify a different environment
to the launched program, or to redirect its I/O.
</p>

<p>
Each ctl is a record that exports the following methods:
</p>


<div class="docitem" id="fn:ctlid">
<div class="proto">
<div class="function">
<span class="id">id()</span>
</div>
<div class="returns">
<span class="type">cvalue</span>
</div>
</div>
<div class="desc">
Returns a numeric identifier for the ctl.
</div>
</div>

<div class="docitem" id="fn:ctlexe">
<div class="proto">
<div class="function">
<span class="id">exe()</span>
</div>
<div class="returns">
<span class="type">domain</span>
</div>
</div>
<div class="desc">
Returns a domain representing the executable of
the ctl.
</div>
</div>

<div class="docitem" id="fn:ctlctx">
<div class="proto">
<div class="function">
<span class="id">ctx()</span>
</div>
<div class="returns">
<span class="type">context</span>
</div>
</div>
<div class="desc">
Returns the current context of the ctl.
The context is represented as a pointer
into a domain that is a buffer backed
by the remote register set.  This weakly
consistent: when the ctl is stopped
(i.e., in a handler affecting the ctl
or in a snapshot) the view is consistent.
</div>
</div>

<div class="docitem" id="fn:ctldetach">
<div class="proto">
<div class="function">
<span class="id">detach()</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Releases control of the target execution.
The execution resumes, but future operations on
the ctl are invalid.
</div>
</div>

<div class="docitem" id="fn:ctlkill">
<div class="proto">
<div class="function">
<span class="id">kill()</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Like detach, but terminates the target execution
instead of resuming it.
</div>
</div>

<div class="docitem" id="fn:ctlstat">
<div class="proto">
<div class="function">
<span class="id">stat()</span>
</div>
<div class="returns">
<span class="type">record</span>
</div>
</div>
<div class="desc">
Returns a record describing status information about the remote target.
This is currently undefined and unimplemented, but should
perhaps include: pid, ppid, other proc stats, maps, dialect.
</div>
</div>

<div class="docitem" id="fn:ctlmem">
<div class="proto">
<div class="function">
<span class="id">mem()</span>
</div>
<div class="returns">
<span class="type">address space</span>
</div>
</div>
<div class="desc">
Returns an address space backed by the target process memory.
</div>
</div>

<div class="docitem" id="fn:ctlnsmap">
<div class="proto">
<div class="function">
<span class="id">nsmap()</span>
</div>
<div class="returns">
<span class="type">nsmap</span>
</div>
</div>
<div class="desc">
Returns an nsmap describing the current mappings in the target address space.
</div>
</div>

<div class="docitem" id="fn:ctlns">
<div class="proto">
<div class="function">
<span class="id">ns([<span class="arg">idx</span>])</span>
</div>
<div class="param">
<span class="arg">idx</span>: <span class="type">cvalue</span> or <span class="type">string</span>
</div>
<div class="returns">
<span class="type">name space</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Queries the current mappings in the target address
space (<em>i.e.</em>, its nsmap), returning a name
space corresponding to one of the mappings.
If <span class="arg">idx</span> is unspecified, a name
space corresponding to the executable is return.
If <span class="arg">idx</span> is a cvalue, it is
treated as an address in the target memory, and the
name space "containing" that address is returned
(as in <span class="fnindex"><a href="#fn:nsmapbyaddr">byaddr</a></span>).
If <span class="arg">idx</span> is a string, it is
treated as a string pattern; the name space whose path
name matches the pattern is returned
(as in <span class="fnindex"><a href="#fn:nsmapbyname">byname</a></span>).
If no name space matches, <span class="val">nil</span>
is returned.
</div>
</div>


<div class="docitem" id="fn:ctldom">
<div class="proto">
<div class="function">
<span class="id">dom([<span class="arg">idx</span>])</span>
</div>
<div class="param">
<span class="arg">idx</span>: <span class="type">cvalue</span> or <span class="type">string</span>
</div>
<div class="returns">
<span class="type">domain</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
The <span class="val">dom</span> method is like
the <span class="fnindex"><a href="#fn:ctlns">ns</a></span>
method, except that a freshly constructed domain is
returned instead of a name space.  The name space is
the name space returned by
the <span class="fnindex"><a href="#fn:ctlns">ns</a></span>
method on argument <span class="arg">idx</span>, and
the address space is the address returned by
the <span class="fnindex"><a href="#fn:ctlmem">mem</a></span>
method (i.e., the current address space of the target).
</div>
</div>

<div class="docitem" id="fn:ctlsnap">
<div class="proto">
<div class="function">
<span class="id">snap()</span>
</div>
<div class="returns">
<span class="type">ctl</span>
</div>
</div>
<div class="desc">
Returns a ctl representing a snapshot of the target process.
</div>
</div>

<div class="docitem" id="fn:ctlldom">
<div class="proto">
<div class="function">
<span class="id">ldom([<span class="arg">ctx</span>])</span>
</div>
<div class="param">
<span class="arg">ctx</span>: <span class="type">context</span>
</div>
<div class="returns">
<span class="type">domain</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Returns a <em>local domain</em> representing the local
variables (including function parameters) defined in
the context <span class="arg">ctx</span> of the target
process.  If <span class="arg">ctx</span> is unspecified,
the current context is used.  The name space of the
local domain includes definitions for all known local
variables.  (But say something about location information --
what kind of accesses work; what kind of casting may or may not work.)
Returns nil if a local domain cannot be constructed
for <span class="arg">ctx</span>.
</div>
</div>

<div class="docitem" id="fn:ctlunwind">
<div class="proto">
<div class="function">
<span class="id">unwind()</span>
</div>
<div class="returns">
<span class="type">list of contexts</span> or
</div>
</div>
<div class="desc">
Unwinds the current call stack of the ctl, returning
a list of contexts corresponding to each call frame.
The current call frame appears first in the list,
followed by its caller, and so on.
</div>
</div>

<div class="docitem" id="fn:ctllooksrc">
<div class="proto">
<div class="function">
<span class="id">looksrc(<span class="arg">addr</span>)</span>
</div>
<div class="param">
<span class="arg">addr</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">source record</span> or
</div>
</div>
<div class="desc">
Returns
a <span class="fnindex"><a href="#rec:srcrec">source
record</a></span> specifying the location in source
code corresponding to <span class="val">addr</span>.
</div>
</div>

<div class="docitem" id="fn:ctllookpc">
<div class="proto">
<div class="function">
<span class="id">lookpc(<span class="arg">file</span>,<span class="arg">line</span>[,<span class="arg">idx</span>])</span>
</div>
<div class="param">
<span class="arg">file</span>: <span class="type">string</span>
</div>
<div class="param">
<span class="arg">line</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">idx</span>: <span class="type">cvalue</span> or <span class="type">string</span>
</div>
<div class="returns">
<span class="type">cvalue</span>
</div>
</div>
<div class="desc">
Returns an address (program counter value)
corresponding to the source
location <span class="arg">file</span>:<span class="arg">line</span>
in the name space determined by
passing <span class="arg">idx</span> to the <span class="fnindex"><a href="#fn:ctlns">ns</a></span> method.
</div>
</div>

<div class="docitem" id="fn:ctltrap">
<div class="proto">
<div class="function">
<span class="id">trap(<span class="arg">kind</span>[,<span class="arg">arg</span>.],<span class="arg">fn</span>)</span>
</div>
<div class="param">
<span class="arg">kind</span>: <span class="type">cid</span>
</div>
<div class="param">
<span class="arg">arg</span>: varies
</div>
<div class="param">
<span class="arg">fn</span>: <span class="type">procedure</span>
</div>
<div class="returns">
<span class="type">cvalue</span>
</div>
</div>
<div class="desc">
<p>
Sets a trap on an event of various forms, specified by
the <span class="arg">kind</span> and possible
event-specific
argument <span class="arg">arg</span>.  <span class="arg">Fn</span>
is a handler to be called in reponse to the event.
Multiple handlers may be registered for the same event;
they are called in registration order.  Regardless of
the kind of event, the first argument passed to the
handler is always the ctl representing the target on
which the event occured.  Additional arguments may be
passed depending on the kind of event.  The return
value of each call to a handler is ignored.
</p>
<p>
The return value of <span class="id">trap</span> is an
unique identifier for the trap.  Passing the identifier to a call
to <span class="fnindex"><a href="#fn:ctlclear">clear</a></span>
deregisters the trap.
</p>

<p>
The available traps are listed below.  Any required
optional arguments to <span class="val">trap</span> are
named following the symbol that identifies trap kind.
</p>

<div class="bolddt-indentdd">

<dl>
<dt><span class="val">brk</span> <span class="arg">addr</span></br> <span class="val">snap</span> <span class="arg">addr</span></dt>
<dd>
Set a breakpoint or snappoint.  The handler is called when the
program counter reaches <span class="arg">addr</span> (a cvalue).
<span class="val">Snap</span> differs
from <span class="val">brk</span> in that a snapshot of
the trapping ctl is created and passed to the handler,
instead of the ctl for the trapping ctl.
On Unix systems, <span class="val">brk</span>
and <span class="val">snap</span> traps are
automatically cleared whenever the target successfully
returns from an exec system call.
</dd>

<dt><span class="val">exit</span></dt>
<dd>
Set a trap on termination.
The handler is called when the target has terminated
but before the address space has been reclaimed by the
host system.  No further execution will occur; the ctl
becomes invalid when the handler returns.
</dd>

<dt><span class="val">load</span></br><span class="val">unload</span></dt>
<dd>
Set a trap on library load or unload.  The handler is
called when the target has updated its address space by
loading or unloading a library.  Along with the ctl,
the handler is passed two additional arguments: the
path name and load address of the affected library.
The nsmap of the ctl is updated prior to calling the
handler.
</dd>

<dt><span class="val">exec</span></dt>
<dd>
Set a trap on new program execution. The
handler is called when the target has
successfully returned from the exec system
call, just before the execution of
the first instruction in the new program
image.
</dd>

<dt><span class="val">syscall</span></dt>
<dd>
Set a trap on system call entry and exit.
The handler is called whenever the target
enters or returns from a system call.
(It is up to the handler to figure out which.)
</dd>

<dt><span class="val">signal</span></dt>
<dd>
Set a trap on signals. 
The handler is called whenever a signal
is about to be posted to the target.
</dd>

<dt><span class="val">clone</span></dt>
<dd>
Set a trap on process creation.  The handler is called
when the target has spawned a new process.  Along with
the ctl that spawned the new process, the handler is
passed a new ctl representing the new process.
</dd>

</dl>
</div>

</div>
</div>


<div class="docitem" id="fn:ctlclear">
<div class="proto">
<div class="function">
<span class="id">clear(<span class="arg">id</span>)</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Clears the trap with identifier <span class="arg">id</span>.
</div>
</div>



<div class="docitem" id="fn:ctltraps">
<div class="proto">
<div class="function">
<span class="id">traps()</span>
</div>
<div class="returns">
<span class="type">list of trap records</span>
</div>
</div>
<div class="desc">
Traps returns a list of trap records describing all
currently registered traps on the ctl.

<div class="code">
<pre>
@record traprec {
	tid,      /* user-visible trap identifier */
	sid,	  /* sctl trap identifier (not for user) */
	type,	  /* type of trap */
	args,	  /* trap configuration arguments */
	fn	  /* trap handler */
};
</pre>
</div>
The system registers traps for its own internal state
management on each ctl.  These traps are revealed by
<span class="id">traps</span>, but they should not be tampered with.
</div>
</div>


<h4 id="sec:sctlns">Interfaces to sctl</h4>

<p>
For lower-level name space programming, the debug
library also provides a set of Cinquecento functions
for performing synchronous name space transactions with
a <span class="val">sctl</span> server.
</p>

<p>
The first argument to each of these functions is a file
descriptor that must be connected to a sctl server.
Generally the remaining arguments are Cinquecento data
to be encoded into the fields of the corresponding sctl
request.  Most functions return a data structure
representing the decoded payload of the corresponding
reply.
</p>

<p>
These procedures assume that the sctl server answers
each request synchronously and that it never
generates <span class="val">Aevent</span> messages.
This behavior is consistent with a sctl server that
being used to serve only name space data.
</p>

<p>
Two of the procedures, sctlenumtype and sctllooktype,
an additional name space argument.  This name space is
used by the underlying type definition decoder
(decodetdef) to resolve two aspects of type definitions
that cannot be determined from the sctl type definition
reply:
</p>

<ul>
<li>
the mapping from enumeration representation to a
corresponding base type, passed to mkctype_enum;
</li>
<li>
the representation of the pointer type, passed
to mkctype_ptr.
</li>
</ul>

<p>
For this argument, it is sufficient to pass a root name
space that is compatible with the base type definitions
of the target name space.  We consider the presence of
this argument to be a bug in the interface.
</p>

<p>
The functions are as follows:
</p>

<div class="docitem" id="fn:sctlping">
<div class="proto">
<div class="function">
<span class="id">sctlping(<span class="arg">fd</span>,<span class="arg">cnt</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">cnt</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">ping</span> transaction with the server,
sending a ping payload of <span class="arg">cnt</span> zero bytes.
An error is raised if the transaction fails.
</div>
</div>

<div class="docitem" id="fn:sctlversion">
<div class="proto">
<div class="function">
<span class="id">sctlversion(<span class="arg">fd</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">version</span> transaction with the server.
The offered version is
<div class="code">
<pre>
"sctl-2010:x86-linux-2010,x86-win-2010"
</pre>
</div>
The negotiated version string is returned.
An error is raised if the version cannot
be negotiated.
</div>
</div>

<div class="docitem" id="fn:sctlnames">
<div class="proto">
<div class="function">
<span class="id">sctlnames(<span class="arg">fd</span>,<span class="arg">path</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">path</span>: <span class="type">string</span>
</div>
<div class="returns">
<span class="type">cvalue</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">names</span> transaction, returning a name space
identifier for the name space corresponding to the binary
named <span class="arg">path</span>.
Returns <span class="val">nil</span> if the name space does not exist.
</div>
</div>

<div class="docitem" id="fn:sctllooktype">
<div class="proto">
<div class="function">
<span class="id">sctllooktype(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">typename</span>,<span class="arg">ns</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">typename</span>: <span class="type">ctype</span>
</div>
<div class="param">
<span class="arg">ns</span>: <span class="type">name space</span>
</div>
<div class="returns">
<span class="type">ctype</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">looktype</span> transaction
on the name space corresponding
to <span class="arg">nsid</span>, returning an
definition of the type
named <span class="val">typename</span>.  The resulting
definition is 
<a href="man.html#cncpt:incompletetype">incomplete</a>.
Returns <span class="val">nil</span> if there is no
matching type definition.
</div>
</div>

<div class="docitem" id="fn:sctlenumtype">
<div class="proto">
<div class="function">
<span class="id">sctlenumtype(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">ns</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">ns</span>: <span class="type">name space</span>
</div>
<div class="returns">
<span class="type">table</span>
</div>
</div>
<div class="desc">
Performs an <span class="id">enumtype</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, returning a
table mapping type names to type definitions.
The type definitions are
<a href="man.html#cncpt:incompletetype">incomplete</a>.
</div>
</div>

<div class="docitem" id="fn:sctllooksym">
<div class="proto">
<div class="function">
<span class="id">sctllooksym(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">id</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">id</span>: <span class="type">cid</span>
</div>
<div class="returns">
<span class="type">symbol</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">looksym</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, obtaining
a definition for the symbol <span class="val">id</span>.
The result is a Cinquecento symbol [reference].
Its attribute table defines <span class="val">"offset"</span>
to the <span class="arg">value</span> returned
in the <span class="id">looksym</span> reply,
<span class="val">"flags"</span> to
the <span class="arg">flags</span>,
and <span class="val">"size"</span> to
the <span class="arg">size</span>.  The symbol type is
<a href="man.html#cncpt:incompletetype">incomplete</a>.
Returns <span class="val">nil</span> if there is no matching symbol.
</div>
</div>

<div class="docitem" id="fn:sctlenumsym">
<div class="proto">
<div class="function">
<span class="id">sctlenumsym(<span class="arg">fd</span>,<span class="arg">nsid</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">table</span>
</div>
</div>
<div class="desc">
Performs an <span class="id">enumsym</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, returning
a table mapping symbol identifiers to symbol definitions.
The symbol definitions are Cinquecento symbols.
</div>
</div>

<div class="docitem" id="fn:sctllookaddr">
<div class="proto">
<div class="function">
<span class="id">sctllookaddr(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">addr</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">addr</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">symbol</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">lookaddr</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, returning
a symbol definition to which <span class="arg">addr</span> maps.
The symbol definition is a Cinquecento symbol.
Returns <span class="val">nil</span> if there is no matching symbol.
</div>
</div>

<div class="docitem" id="fn:sctlunwind1">
<div class="proto">
<div class="function">
<span class="id">sctlunwind1(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">addr</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">addr</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">list of unwind rules</span>
</div>
</div>
<div class="desc">
Performs an <span class="id">unwind1</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, returning
target-dependent stack frame unwinding rules
corresponding to the program counter value <span class="arg">addr</span>.

Each unwind rule is specified in an <span class="val">uwrulerec</span>
that is based on the encoding of the unwind rules specified by DWARF:

<div class="code">
<pre>
@record uwrulerec {
	kind,		/* rule kind */
	r,		/* register operand */
	n		/* number operand */
};
</pre>
</div>

[Reference dwarf functions that interprets these.]

</div>
</div>

<div class="docitem" id="fn:sctllooksrc">
<div class="proto">
<div class="function">
<span class="id">sctllooksrc(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">addr</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">addr</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">source record</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">looksrc</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, returning
a source record corresponding to the program
counter <span class="arg">addr</span>.

The source record is defined as follows:

<div class="code" id="rec:srcrec">
<pre>
@record srcrec {
	file,		/* file name (string) */
	line,		/* line (cvalue) */
	col,		/* column (cvalue) */
};
</pre>
</div>
Returns <span class="val">nil</span> if no source location matches.
</div>
</div>


<div class="docitem" id="fn:sctllookpc">
<div class="proto">
<div class="function">
<span class="id">sctllookpc(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">file</span>,<span class="arg">line</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">file</span>: <span class="type">string</span>
</div>
<div class="param">
<span class="arg">line</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">cvalue</span>
</div>
</div>
<div class="desc">
Performs a <span class="id">lookpc</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, returning
a program counter address at corresponding
to the source location <span class="arg">file</span>:<span class="arg">line</span>.
Returns <span class="val">nil</span> if there is no matching 
source location.
</div>
</div>

<div class="docitem" id="fn:sctlenumloc">
<div class="proto">
<div class="function">
<span class="id">sctlenumloc(<span class="arg">fd</span>,<span class="arg">nsid</span>,<span class="arg">addr</span>)</span>
</div>
<div class="param">
<span class="arg">fd</span>: <span class="type">file descriptor</span>
</div>
<div class="param">
<span class="arg">nsid</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">addr</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">list of local variable records</span>
</div>
</div>
<div class="desc">
Performs an <span class="id">enumloc</span>
transaction on the name space corresponding
to <span class="arg">nsid</span>, returning
a list of local variable records.
Local variable records are defined as follows:

<div class="code">
<pre>
@record locrec {
	id,		/* name (cid) */
	sz,		/* size (cvalue) (FIXME: always zero!) */
	ltype,		/* kind (parameter or local) (cvalue) */
	loc,		/* location expression (lexprrec) */
	type,		/* type name (ctype) */
};

@record lexprrec {
	kind,		/* kind (cvalue) */
	no,		/* register (cvalue) */
	v,		/* value (cvalue) */
	op1, op2,	/* operands (lexprrec) */
};
</pre>
</div>

Returns <span class="val">nil</span> if no
location information is available. 

</div>
</div>


<p>
This library also defines several undocumented
functions for converting buffers of encoded sctl data
to and from Cinquecento data structures.
</p>

<h4 id="sec:nsmap">Name space maps</h4>

<p>
A name space map (nsmap) is an object that manages name
spaces for the set of binaries (libraries and
executable) mapped within an address space of a running
program.
</p>

<p>
Think of each mapping as a triple comprising 
the path name for the mapped binary,
the base address of the mapping,
and the corresponding Cinquecento name space.
</p>

<p>
A typical address space consists of several library
mappings and exactly one executable mapping.  An nsmap
defines a distinguished mapping, called the executable,
which is intended to represent the executable mapping.
</p>

<p>
The methods of an nsmap support dynamic addition and
removal of mappings, query and update of the executable
mapping, name space lookup by address and name, name
space enumeration, and nsmap cloning.
</p>

<p>
Rather than require the nsmap client to construct
individual name spaces, each nsmap instance
encapsulates a function that maps a path name to a name
space.  Clients add mappings by specifying the binary
path name and base address.
</p>

<p>
To use nsmaps, <span class="val">@include
&lt;nsmap.cqct&gt;</span> in your program.  The library
defines one function:
</p>

<div class="docitem" id="fn:mknsmap">
<div class="proto">
<div class="function">
<span class="id">mknsmap(<span class="arg">fn</span>)</span>
</div>
<div class="param">
<span class="arg">fn</span>: <span class="type">procedure</span>
</div>
<div class="returns">
<span class="type">nsmap</span>
</div>
</div>
<div class="desc">
This is the only constructor for nsmap instances.
<span class="id">Fn</span> is a function that
encapsulates name space construction.  It must accept
one argument, a string naming a program binary, and
return either a name space for that binary mapped at address zero,
or <span class="val">nil</span> if the name space
cannot be constructed.
</div>
</div>

<p>
Each nsmap is a record that exports the following methods:
</p>

<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapadd">
<span class="id">add(<span class="arg">base</span>,<span class="arg">path</span>)
</div>
<div class="param">
<span class="arg">base</span>: <span class="type">cvalue</span>
</div>
<div class="param">
<span class="arg">path</span>: <span class="type">string</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
This method constructs a name space for
the binary named <span class="arg">path</span> mapped at
offset <span class="arg">base</span>, and then adds the
resulting mapping to the nsmap.
The name space is constructed by calling the <span class="arg">fn</span> argument
that was passed to
<span class="fnindex"><a href="#fn:mknsmap">mknsmap</a></span>
when the nsmap was created.
If <span class="arg">base</span> is <span class="val">0</span>
and the nsmap does not already have a defined
executable, then the executable is set
to the new mapping.
</div>
</div>

<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapdel">
<span class="id">del(<span class="arg">base</span>)
</div>
<div class="param">
<span class="arg">base</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
This method removes the name space mapped at
offset <span class="arg">base</span> from the nsmap.
If <span class="arg">base</span> corresponds to the
executable, then the executable is made undefined.
</div>
</div>

<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapexe">
<span class="id">exe()</span>
</div>
<div class="returns">
<span class="type">name space</span> or <span class="type">nil</span>
</div>
</div>
<div class="desc">
This method returns the name space of the executable
of the nsmap,
or <span class="val">nil</span> if it is undefined.
</div>
</div>

<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapsetexe">
<span class="id">setexe(<span class="arg">base</span>)</span>
</div>
<div class="param">
<span class="arg">base</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
This method sets the executable of the nsmap
to be the mapping at offset <span class="arg">base</span>.
It is an error if there is no such mapping.
</div>
</div>


<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapbyaddr">
<span class="id">byaddr(<span class="arg">addr</span>)</span>
</div>
<div class="param">
<span class="arg">addr</span>: <span class="type">cvalue</span>
</div>
<div class="returns">
<span class="type">name space</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
Intuitively, this method attempts to return the name space in the nsmap whose mapping "contains" the address <span class="arg">addr</span>.
More precisely, this method returns the name space whose offset
is the greatest address less than or
equal to <span class="arg">addr</span>.
It returns <span class="val">nil</span> if no name space matches.
</div>
</div>


<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapbyname">
<span class="id">byname(<span class="arg">pat</span>)</span>
</div>
<div class="param">
<span class="arg">pat</span>: <span class="type">string</span>
</div>
<div class="returns">
<span class="type">name space</span> or
<span class="type">nil</span>
</div>
</div>
<div class="desc">
This method returns the name space whose path name matches
<span class="arg">pat</span>.
A path name  <span class="arg">path</span>
matches if <span class="val">strstr(<span class="arg">path</span>,<span class="arg">pat</span>)</span> returns non-<span class="val">nil</span>.  The
search is performed in ascending order of mapping offset;
the first match is returned.
<span class="id">Byaddr</span>
returns <span class="val">nil</span> if no name space
matches.
</div>
</div>


<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapeach">
<span class="id">each(<span class="arg">fn</span>)</span>
</div>
<div class="param">
<span class="arg">fn</span>: <span class="type">procedure</span>
</div>
<div class="returns">
<span class="type">nil</span>
</div>
</div>
<div class="desc">
This method calls <span class="arg">fn</span> for each
mapping in the nsmap, in ascending order of mapping
offset.  <span class="arg">Fn</span> is passed the
three properties of the mapping: the offest, the path
name, and the name space.  The return value
of <span class="id">fn</span> is ignored.
</div>
</div>

<div class="docitem">
<div class="proto">
<div class="function"  id="fn:nsmapcopy">
<span class="id">copy()</span>
</div>
<div class="returns">
<span class="type">nsmap</span>
</div>
</div>
<div class="desc">
This returns a new nsmap that is a copy of the nsmap.
Subsequent updates to either one of the nsmaps has
no effect on the other.
</div>
</div>


<h4 id="sec:fnindex">Function Index</h4>
<div class="id">
<div class="index">
<div class="fnindex">
<a href="#fn:nsmapadd">add</a> (nsmap)<br />
<a href="#fn:atnames">atnames</a> (nsmap)<br />
<a href="#fn:nsmapbyaddr">byaddr</a> (nsmap)<br />
<a href="#fn:nsmapbyname">byname</a> (nsmap)<br />
<a href="#fn:ctlclear">clear</a> (nsmap)<br />
<a href="#fn:nsmapcopy">copy</a> (nsmap)<br />
<a href="#fn:ctlctx">ctx</a> (ctl)<br />
<a href="#fn:nsmapdel">del</a> (nsmap)<br />
<a href="#fn:ctldetach">detach</a> (ctl)<br />
<a href="#fn:ctldom">dom</a> (ctl)<br />
<a href="#fn:nsmapeach">each</a> (nsmap)<br />
<a href="#fn:ctlexe">exe</a> (ctl)<br />
<a href="#fn:nsmapexe">exe</a> (nsmap)<br />
<a href="#fn:ctlid">id</a> (ctl)<br />
<a href="#fn:ctlkill">kill</a> (ctl)<br />
<a href="#fn:ctlldom">ldom</a> (ctl)<br />
<a href="#fn:ctllookpc">lookpc</a> (ctl)<br />
<a href="#fn:ctllooksrc">looksrc</a> (ctl)<br />
<a href="#fn:ctlmem">mem</a> (ctl)<br />
<a href="#fn:mknsmap">mknsmap</a><br />
<a href="#fn:mksctlns">mksctlns</a><br />
<a href="#fn:ctlns">ns</a> (ctl)<br />
<a href="#fn:ctlnsmap">nsmap</a> (ctl)<br />
<a href="#fn:nsmapsetexe">setexe</a> (nsmap)<br />
<a href="#fn:sctlenumloc">sctlenumloc</a><br />
<a href="#fn:sctlenumsym">sctlenumsym</a><br />
<a href="#fn:sctlenumtype">sctlenumtype</a><br />
<a href="#fn:sctllookaddr">sctllookaddr</a><br />
<a href="#fn:sctllookpc">sctllookpc</a><br />
<a href="#fn:sctllooksrc">sctllooksrc</a><br />
<a href="#fn:sctllooksym">sctllooksym</a><br />
<a href="#fn:sctllooktype">sctllooktype</a><br />
<a href="#fn:sctlnames">sctlnames</a><br />
<a href="#fn:sctlping">sctlping</a><br />
<a href="#fn:sctlunwind1">sctlunwind1</a><br />
<a href="#fn:sctlversion">sctlversion</a><br />
<a href="#fn:ctlsnap">snap</a> (ctl)<br />
<a href="#fn:ctlstat">stat</a> (ctl)<br />
<a href="#fn:ctltrap">trap</a> (ctl)<br />
<a href="#fn:ctltraps">traps</a> (ctl)<br />
<a href="#fn:ctlunwind">unwind</a> (ctl)<br />
</div>
</div>
</div>

<br />
<br />


</div>

</body>
</html>
