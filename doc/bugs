****

running this program shows the error on the wrong line.

if(1)
	error("1");
else
	error("2");
nil;

% ../l1 -o /tmp/y.l1 
	/tmp/y.l1:4	   0	entry	vargc 0
	/tmp/y.l1:4	   1		subsp 1
	/tmp/y.l1:4	   2		list 0 0 -1(%fp)
	/tmp/y.l1:1	   3		mov 1 %ac
	/tmp/y.l1:1	   4		jz %ac L5
	/tmp/y.l1:2	   5		frame L3
	/tmp/y.l1:2	   6		push "1"
	/tmp/y.l1:2	   7		pushi 1
	/tmp/y.l1:2	   8		call <error>
	/tmp/y.l1:2	   9		jmp L3
	/tmp/y.l1:4	  10	L5	frame L3
	/tmp/y.l1:4	  11		push "2"
	/tmp/y.l1:4	  12		pushi 1
	/tmp/y.l1:4	  13		call <error>
	/tmp/y.l1:5	  14	L3	mov <nil> <$$>
	/tmp/y.l1:4	  15		mov <$$> %ac
	/tmp/y.l1:4	  16		ret
	/tmp/y.l1:4	  17		ret
error: 1
fp=04081 pc=00000000                error	(builtin function)
fp=04087 pc=00000013                entry	(/tmp/y.l1:4)


the correct call to error occurs.
the problem is that the code pushes L3 on the stack
as the return address, which is not the address
that follows the call instruction (as it usually the case).

the stackwalk code assumes that the pc for a call is
the insn following the call.

*****

# None of this is good (f26547b585a2bcfe58701e54191247d3e67233d3)
% ./l1
; { @local x; x; } 
error: reference to undefined variable: $$
               entry    (no source information)
; { @local x; y = x; }
error: reference to undefined variable: $$
               entry    (<stdin>:1)
; { @local x; printf("%d\n", x); }
error: wrong type to %d conversion
              printf    (builtin function)
               entry    (no source information)
; { @local x; printf("%a\n", x); }

; 


