Cinquecento allows you to interpret the contents of an
array of raw, untyped bytes using symbolic expressions
based on the C programming language.

This symbolic interpretation starts with the definition
of a name space, which defines the types and symbols
that occur in your C expressions.

In C, types and symbols  


A Cinquecento name space  represents a set of C variable
and type declarations, plus information describing the
layout of these objects in an address space.

C defines several categories of types.  They include:

* arithmetic types (integers and floats)
* pointers
* structures
* unions
* arrays
* functions

* base C types (int, unsigned long, etc.)
* aggregate types (struct, union)
* enumeration types (enum)
* type aliases defined by typedef
* symbols

Each definition maps the name of an object to its
representation in an address space.

Base C Types
------------

These are the base C types:

	char
	short
	int
	long
	long long

	pointer

	float
	double
	long double

The key feature of Cinquecento name spaces is that as
part of the definition of a name, they include explicit
specification of the layout of the defined object in an
address space, information that in C is determined
implicitly by the compiler.  For symbols, the
information includes the location of the symbol; for
types, it includes the encoding and layout in memory,
down to the bit, of the values represented by the type.

Every new name space inherits definitions from a
previously defined name space.  The built-in {\em root
name spaces\/} from which all others are derived define
base C types for several common machine models.  They
are bound to the Cinquecento variables {\tt c32le},
{\tt c32be}, {\tt c64le}, {\tt c64be}, {\tt clp64le},
and {\tt clp64be}.  Each root name space defines the
representation of C base types, including the number of
bytes in the type and the encoding of the type in
memory.  It also defines the size of pointers; for
example, {\tt c64le} and {\tt clp64le} define the same
commonly used definitions of C types on 64-bit
machines, except that the size of pointers is 32-bits
in {\tt c64le} and 64-bits (``long pointer'') in {\tt
clp64le}.

New name spaces are constructed with the {\tt @names} form:


\begin{verbatimtab}[4]
	@names <expr> {
		<definition> ...
	};
\end{verbatimtab}

\noindent The {\tt <expr>} is any Cinquecento
expression that evaluates to a name space value.  Each
{\tt <definition>} defines either a type or a symbol.
The syntax of these definitions is like the usual C
variable and type declaration syntax, but slightly
modified to support layout specification.  The
evaluation of an {\tt @names} expression yields a new
name space that contains the definitions in the name
space yielded by evaluating {\tt <expr>} plus those
specified in the {\tt <definition>}.  It is an error to
redefine a previously defined name.

There are four forms of name definition: a C aggregate
type specification, a symbol corresponding to a C
variable, a {\tt typedef}, and an {\tt enum} type
specification.  Each closely resembles its C
counterpart in syntax and semantics.  The next four
sections describe their use in Cinquecento.

\subsection{Aggregate Types}

The most interesting type definitions are those for
aggregate types ({\tt struct} and {\tt union}).  The
syntax is like an ordinary C aggregate declaration
except that:

\begin{itemize}
\item each field declaration includes an offset
         expression, which specifies the offset of the
          field relative to the beginning of the
          aggregate;
\item the declaration must end with a final offset
          expression (not associated with any field)
          that specifies the size of the aggregate.
\end{itemize}

The offset expression has two variants: one ({\tt
@<expr>}) to specify the offset in {\em bytes\/}, and
one ({\tt @@<expr>}) to specify the offset in {\em
bits\/}.  The bit offset variant is typically used to
define fields corresponding to C bitfields, which can
begin at non-byte-aligned bit offsets from the start of
the aggregate.  For the common case of fields that are
not bitfields, bytes are usually the more natural unit
for expressing offsets.




mkns(ns, typetab, symtab)

mkbase({Vint, ...}) -> typename

mkstruct(tag) -> typename
mkunion(tag) -> typename
mkptr(typename) -> typename
mkfn(typename, < <typename,id> ... >) -> typename
mkarr(typename, cnt) -> typename
mktypedef(tid) -> typename

typetab[mkstruct(tag)] -> < mkstruct(id), fields, sz >
	where fields is a vector: < <typename, id, off> ... >
typetab[mktypedef(id)] -> typename

symtab[id] -> < typename, id, off >

off := integer-expression | nil


C Types in Cinquecento
----------------------

Type name: syntactic construction that defines a C type.
	int, int*, int(*)(int x), struct foo, ...

Type representation: how a C type is encoded in memory.

Different domains may have different representations for the same type
name.

Depending on context, a type in Cinquecento is treated as a type name
or as a name+representation.


To understand how types work in Cinquecento, we first need some
terminology for C types.

A type specifier is any one of the following:

Base type

	(un)signed char
	(un)signed short
	(un)signed int
	(un)signed long
	(un)signed long long
	float
	double
	long double

	Other names are aliases for these types (e.g., "unsigned" is
	"unsigned int").

Tagged type

	Any struct, union, or enum.

Typedef type

	Any type created by typedef.


