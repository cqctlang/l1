Attaching L1 to a linux process with prctl
------------------------------------------

1.  get prctl from cqctworld.org and untar it.

2.  build it.

    % cd prctl
    % make

    NOTE: the Makefile contains an optional -DX86_64 flag for 64-bit
          builds.  be sure it is set appropriately for the machine on
          which you will run prctl.

3.  start prctl

    % prctl --

    NOTE: prctl exits after 60 seconds have elapsed since the
          the most recent client connection.  so you may need
          start it again later

4.  start l1

    % ./l1
    ;

5.  construct a process address space

    ; pras = mkpras("localhost:30000", "command", "arg0", ...);

    the first argument to mkpras is the host:port address where prctl
    is listening.  by default, prctl listens on port 30000; the -p
    option to prctl selects a different port.

    the remaining arguments are the elements of argv for the program
    to be executed.  the first argument (argv[0]) must be the
    pathname of an executable.

    e.g.,

    ; pras = mkpras("localhost:30000", "/bin/ls", "/etc");

6.  construct a process domain

    ; prdom = mkdom(prns, pras);

    you must provide the name space; there is no support for
    automatically extracting types and symbols from the target
    program.

    one way to populate a name space is to run dwarf2cqct on the
    executable.

7.  have at it!

    the process represented by prdom is initially stopped at its first
    instruction.

    ordinary domain memory access operations on prdom will read and
    write the process memory.

    in addition, the process domain supports several operators:

    prdom.xcont();

	resume execution of the process.
        returns nil.

        breakpoints set by bpset will NOT be serviced; instead,
        they will cause the process to stop.

    prdom.xbreak();

	suspend execution of the process.
        return nil.

    prdom.xtrap(addr, fn);

        trap execution of the address ADDR by calling the handler
	function FN.  returns ID, an integer identifier for the trap.

        when execution reaches ADDR, FN is called with
    	two arguments, ID and ADDR.

	FN must return either 0 or 1.  0 resumes execution
	of the target process; 1 requests that the process break.

	if more than one trap is set for the same ADDR,
	the handlers are all called but in undefined
	order.  if all handlers return 0, execution
	resumes.  if some handler returns 1, then
	execution breaks but it is undefined whether
	and when the remaining handlers are called.

    prdom.traplist();

        return a list of the currently registered traps.

    prdom.trapdel(id);

        clear the trap associated with identifier ID.
	returns nil.

    prdom.trapreset();

        clear all traps.  returns nil.

    prdom.geteax()          prdom.getrax()          prdom.geteflags()
    prdom.getebx()	    prdom.getrbx()
    prdom.getecx()	    prdom.getrcx()
    prdom.getedx()	    prdom.getrdx()
    prdom.getesi()	    prdom.getrsi()
    prdom.getedi()	    prdom.getrdi()
    prdom.getebp()	    prdom.getrbp()
    prdom.geteax()	    prdom.getrax()
    prdom.geteip()	    prdom.getrip()
    prdom.getesp()	    prdom.getrsp()

	returns the current value of the named register.
	the value is in the literal domain (this will change).

    prdom.seteax(x)         prdom.setrax(x)          prdom.seteflags(x)
    prdom.setebx(x)	    prdom.setrbx(x)
    prdom.setecx(x)	    prdom.setrcx(x)
    prdom.setedx(x)	    prdom.setrdx(x)
    prdom.setesi(x)	    prdom.setrsi(x)
    prdom.setedi(x)	    prdom.setrdi(x)
    prdom.setebp(x)	    prdom.setrbp(x)
    prdom.seteax(x)	    prdom.setrax(x)
    prdom.seteip(x)	    prdom.setrip(x)
    prdom.setesp(x)	    prdom.setrsp(x)

	sets the named register to X.
        returns nil.

    prdom.xcontwait()

	resume execution of the process and block until it exits or
	stops again.

        breakpoints set by bpset will be serviced by the system as
        they occur.  they are serviced by (1) suspending execution of
        the process, (2) calling the associated breakpoint handler,
        then (3) resuming execution.

        if a breakpoint handler returns 1, then the system will leave
        the process stopped and xcontwait will return.

	returns nil.
