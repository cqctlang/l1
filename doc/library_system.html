<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Cinquecento Libraries</title>
<link rel="stylesheet" type="text/css" href="reset.css"/>
<link rel="stylesheet" type="text/css" href="styles.css"/>
</head>

<body>

<div id="side1">
</div>

<div id="content">

<div id="title">
<h3>Cinquecento Libraries</h3>
</div>

<p>
Cinquecento provides a prototype syntax-based mechanism for modularizing code.
The primary goals of this system are both to allow the creation of libraries
that do not assign global variables, and to allow easy swapping of different
implementations for the same set of symbols into a given piece of code. 
</p>

<p>
In its most basic instantiation, a library is a file containing
definitions for various functions and variables. There is currently
no mechanism for putting macros (i.e. <em>@defstx</em> definitions)
in a library -- any macros appearing in a library currently get bound
at the top level. Future versions of the library system will remedy the
macro limitations.
</p>

<p>
Cinquecento library files have the <b>.cql</b> extension. 
An example library file might look this file, named <b>lib1.cql</b>:
<div class="code">
<pre>
//variables local to the library must be declared 
//at the top of the file
@local helper_func2; 

//only functions may be exported from a library
@export( func1, func2 );

//the library's contents look like normal cqct code
@define func1() { ... }
@define helper_func2() { ... }
@define func2() { ... }

</pre>
</div>
That code defines and exports two symbols: func1 and func2. 
It also defines a local variable helper_func2 that is visible only
within the library. 
Assuming lib1.cql is in the load path, one can 
load and run lib1's exports. For instance:
</p>
<div class="code">
<pre>
lib1 = @import_object( lib1 ); //loads lib1 with no parameters
//lib1 is a normal cqct variable, it can be local or global
lib1.func1(); //runs the function func1 exported by lib1
lib1.func2(); //runs the function func2 exported by lib1

//lib1 will not be re-parsed and re-compiled by the below line
//because it was already loaded above.
lib1_v2 = @import_object( lib1 ); //loads lib1 
lib1_v2.func2(); //runs the same code as lib1.func2 above.
</pre>
</div>
The <em>@import_object</em> macro checks that lib1.cql has been loaded,
loading it only if necessary, and
creates an object through which any of the library's exported functions
can be called. The second load of lib1 will not re-load lib1, but will use
the same code as was alredy loaded. Any private state in lib1 will be
shared between the two instances.
Since lib1.cql exports <em>func1</em> and <em>func2</em>,
both symbols will be available in both objects. 
</p>

<p>
When writing a library one can also use <em>@import</em> syntax,
which will make all of the exported symbols from the associated
library visible within the given library definition. 
Consider for example <b>lib2.cql</b>
<div class="code">
<pre>

@export( something, somethingelse );
@import( lib1 );

@define something() { 
  ... 
  func1(); //calls func1 from lib1
  ...
}
@define somethingelse() { ... }
</pre>
</div>
The <em>@import</em> macro only works inside a library file -- at the top
level <em>@import_object</em>, <em>@import_globals</em> or
<em>@with_imports</em> must be used instead. 
</p>


<h5 id=import_spec>Import Specification</h5>
<p>
<em>@import</em>, <em>@with_imports</em>, and <em>@import_globals</em> are 
variable argument macros which support the same import specification.
There are three valid import speicifcation forms, all of which use 
the same library name specification. 
</p>

<b>Library name specification</b>: 
Libraries are specified by a name that maps to their
actual file name. The name is path-like to allow for the organization
of libraries into modules and to help organize the libraries in the file
system. Further, the library name is allowed to be
given arguments (similar to a function call). This allows one to initialize
libraries with parameters specific to the given run. Formally, a library
name is:
<div class="code">
<pre>
[&lt;path1&gt;/[&lt;path2&gt;/ [...]]]&lt;name&gt;[( )]
</pre>
</div>
For instance, consider the library name:
<div class="code">
<pre>
path1/path2/name
</pre>
</div>
This will attempt to find the file path1/path2/name.cql in the current load
path.
</p>

<p>
Library names may be specified with an optional '()'. The '()' signals to
the loader that the user desires the library be reloaded, even if it had
been previously loaded. This feature should be used only in developement code:
it may go away or be replaced by another mechanism in the future.
</p>

<p>
The three <b>import specification</b> forms are:
</p>
<p>
<em>library_name</em>: This will import all functions exported by
  that library directly into the local scope before evaluating the local
  scope. 
<div class="code">
<pre>
@with_imports( lib1 ) {
  func1(); //this will call lib1's func1.
  @defloc func2() { ... } 
  func2(); // will call the local func2 even though lib1 exports func2 
}
</pre>
</div>

</p>
<p>
<em>(object_name, library_name)</em>: This will create an object
named <em>object_name</em> that exports access to the functions in
the given library via dot syntax. So if the library contains
a function <em>fn1</em>, one can call that function with the statment
<em>object_name.fn1()</em>. For instance
<div class="code">
<pre>
@with_imports( (l,lib1) ) {
  l.fn1(); //if lib1 exports a function fn1, this will call that function
}
</pre>
</div>
</p>

<p>
<em>(binding, library_name.export)</em>: This will create a local 
binding with the given name to the given library export. For instance:
<div class="code">
<pre>
@import_globals( (lib1_fn1, lib1.fn1) );
lib1_fn1(); //this will call function fn1 exported by library lib1
</pre>
</div>
</p>

<p>
Imported libraries must be present in the load path. That is, when importing
from <em>lib1</em>, there must be a lib1.cql present in the load path at
compile time. 
</p>

<p>
Recursive or mutually recursive libraries are currently not supported.
Any <em>@defstx</em> statements in any library are 
bound globally during compilation. 
</p>

<h3 id="dynamic">Dynamically determined imports</h3>

<p>The above macros allow one to specify at compile time which library
to import and what function renaming to do. 
If one wants to decide on the library that will be imported at runtime,
one can use the <em>dynamic_imports</em> macro. This macro is just like
the <em>with_imports</em> macro, except that it evaluates its arguments at
runtime and treats the resulting strings as an <em>import specification</em>. 
For instance:
<div class="code">
<pre>

lib = "dir1"; // dir1/somthing.cql defines fn1
lib2 = "dir2"; // dir2/something.cql also defines fn1
foreach(@lambda(dir) {
  @dynamic_imports( sprintfa("(f, %s/something.fn1)",dir) ) {
    f();
  }
}, [lib,lib2]);
</pre>
</div>
It is an error to provide a non-string argument to <em>dynamic_imports</em>.
</p>

<h3>Cinquecento Library Macros</h3>

This section describes all of the macros associated with the library system.

<div class="docitem" id="fn:@add_loadpath">
  <div class="proto">
    <div class="function">
      <span class="id">@add_loadpath(path))</span>
    </div>
    <div class="param">
      <span class="arg">path</span>: 
      <span class="type">string</span> 
    </div>
    <div class="returns">
      <span class="type">nothing</span>
    </div>
  </div>
  <div class="desc">
    This function adds the given path to the load path at compile time.
    Note that if path is computed using an expression, the expression will
    be evaluated at compile time before any compiled code has been run.
    Because of this, one can only use simple, self-contained expressions
    to compute path. For instance:
    <div class="code">
      <pre>
@add_loadpath("/"); //legal
@add_loadpath(loadpath()[0]+"../something"); //legal
path = compute_path(); //this statement does not execute until run time
@add_loadpath(path); //error: path is unbound until runtime
@add_loadpath(compute_path()); //error: compute_path is also unbound until runtime
      </pre>
    </div>
  </div>
</div>

<div class="docitem" id="fn:@dynamic_imports">
  <div class="proto">
    <div class="function">
      <span class="id">@dynamic_imports( expression [,expression...] ) 
                            { body }</span>
    </div>
    <div class="param">
      <span class="arg">expression</span>: 
      <span class="type">cqct expressions</span> 
    </div>
  </div>
  <div class="desc">
    Macro that allows one to decide at runtime which libraries are to be 
    imported. The expressions will be evaluated at runtime and should 
    produce string representations of 
    the import_spec statements described <a href=#import_spec>here</a>.
    The macro body will be run with symbols from libraries bound just like the
    <a href=#import_spec>@with_imports</a> macro.
  </div>
</div>

<div class="docitem" id="fn:@export">
  <div class="proto">
    <div class="function">
      <span class="id">@export( sym1 [, sym2 [,...]] )</span>
    </div>
    <div class="param">
      <span class="arg">sym1</span>: 
      <span class="type">symbol name</span> 
    </div>
    <div class="returns">
      <span class="type">nothing</span>
    </div>
  </div>
  <div class="desc">
    Can only be used inside a library file. 
    Exports the named symbols. Only symbols named in this way will
    be exported from the library.
  </div>
</div>

<div class="docitem" id="fn:@import">
<div class="proto">
<div class="function">
<span class="id">@import( import_spec [, import_spec [,...]] )</span>
</div>
<div class="param">
<span class="arg">import_spec</span>
</div>
<div class="returns">
<span class="type">nothing</span>
</div>
</div>
<div class="desc">
  Can only be used inside a library file. 
  Imports the named libraries and symbols. 
  See <a href=#import_spec>import specification</a> for a list of
  valid import specifications.
</div>
</div>

<div class="docitem" id="fn:@import_globals">
  <div class="proto">
    <div class="function">
      <span class="id">@import_globals( import_spec [, import_spec [,...]] )
      </span>
    </div>
    <div class="param">
      <span class="arg">import_spec</span>: 
      <span class="type">import specification</span> 
    </div>
    <div class="returns">
      <span class="type">nothing</span>
    </div>
  </div>
  <div class="desc">
    Imports the named libraries and symbols to the global scope. 
    For use in top-level execution. 
    See <a href=#import_spec>import specification</a> for a list of
    valid import specifications.
  </div>
</div>

<div class="docitem" id="fn:@import_object">
  <div class="proto">
    <div class="function">
      <span class="id">@import_object( library )
      </span>
    </div>
    <div class="param">
      <span class="type">library specification</span>
    </div>
    <div class="returns">
      <span class="type">cqct object</span>
    </div>
  </div>
  <div class="desc">
    Imports the named library into a cqct object and returns that
    object. Only bare library names are allowed, i.e.:
    <div class="code">
<pre>
lib = @import_object( subdir/sublib );
lib.fn(); //calls function fn exported by sublib
</pre>
    </div>
  </div>
</div>

<div class="docitem" id="fn:@with_exports">
  <div class="proto">
    <div class="function">
      <span class="id">@with_exports(name, sym [, sym [,...]] ) { body }</span>
    </div>
    <div class="param">
      <span class="arg">name</span>: 
      <span class="type">library name</span> 
    </div>
    <div class="param">
      <span class="arg">sym1</span>: 
      <span class="type">symbol names</span> 
    </div>
    <div class="param">
      <span class="arg">body</span>: 
      <span class="type">cqct code</span> 
    </div>
  </div>
  <div class="desc">
    Mainly for internal use. 
    This macro exports the given symbols that are 
    <a href=#fn:@export>exported</a> in its body
    as though they were associated with the given library name.
  </div>
</div>

<div class="docitem" id="fn:@with_imports">
  <div class="proto">
    <div class="function">
      <span class="id">@with_imports( import_spec [, import_spec [,...]] ) { body }</span>
    </div>
    <div class="param">
      <span class="arg">import_spec</span>: 
      <span class="type">import_spec</span> 
    </div>
    <div class="param">
      <span class="arg">body</span>: 
      <span class="type">cqct code</span> 
    </div>
  </div>
  <div class="desc">
    Used to import code from libraries. 
    All imported symbols will only be visible inside the provided body.
    See <a href=#import_spec>import specification</a> for a list of
    valid import specifications.
  </div>
</div>



</div>
</body>
</html>
