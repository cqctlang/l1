<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Cinquecento Libraries</title>
<link rel="stylesheet" type="text/css" href="reset.css"/>
<link rel="stylesheet" type="text/css" href="styles.css"/>
</head>

<body>

<div id="side1">
</div>

<div id="content">

<div id="title">
<h3>Cinquecento Libraries</h3>
</div>

<p>
Cinquecento provides a prototype syntax-based mechanism for modularizing code.
The primary goals of this system are both to allow the creation of libraries
that do not assign global variables, and to allow easy swapping of different
implementations for the same set of symbols into a given piece of code. 
</p>

<p>
In its most basic instantiation, a library is a file containing
definitions for various functions and variables. There is currently
no mechanism for putting macros (i.e. <em>@defstx</em> definitions)
in a library -- any macros appearing in a library currently get bound
at the top level. Future version of the library system will remedy the
macro limitations.
</p>

<p>
An example library file might look this file, named <b>lib1.cqct</b>:
<div class="code">
<pre>
//variables local to the library must be declared 
//at the top of the file
@local helper_func2; 

//only functions may be exported from a library
@export( func1, func2 );

//the library's contents look like normal cqct code
@define func1() { ... }
@define helper_func2() { ... }
//libraries are loaded with a special variable, "args"
//that is bound to parameters associated set by the
//person loading the library
@define func2() { printf("%a\n",args); }

</pre>
</div>
That code defines and exports two symbols: func1 and func2. 
It also defines a local variable helper_func2 that is visible only
within the library. 
Assuming lib1.cqct is in the load path, Another bit of code can 
then run using those symbols as follows:
</p>
<div class="code">
<pre>
lib1 = @import_object( lib1 ); //loads lib1 with no parameters
lib1.func1(); //runs the function func1 exported by lib1
lib1.func2(); //prints "nil"

lib1_v2 = @import_object( lib1(10,"abc") ); //loads lib1 with a parameter
lib1_v2.func2(); //prints "[ 10, "abc" ]"
</pre>
</div>
The <em>@import_object</em> macro checks that lib1.cqct has been loaded,
loading it only if necessary, and
creates an object through which any of the library's exported functions
can be called. The second load of lib1 loads it with the parameter 10.
Since lib1.cqct exports both <em>func1</em> and <em>func2</em>
both symbols will be available in both objects. 
</p>

<p id=compile_time_problems>
The library arguments are calculated
<b>at compile time</b>, so one may not use any runtime state in a library
argument list. For instance:
<div class="code">
<pre>
a = 10; //a is set to 10 at run time
//this next line is compiled before any line is run
//so the variable a is not bound on library load
lib1 = @import_object( lib1(a,"abc") ); //error! 
</pre>
</div>
</p>

<p>
When writing a library one can also use <em>@import</em> syntax,
which will make all of the exported symbols from the associated
library visible without an associated object (as above). 
Consider for example <b>lib2.cqct</b>
<div class="code">
<pre>

@export( something, somethingelse );
@import( lib1 );

@define something() { 
  ... 
  func1(); //calls func1 from lib1
  ...
}
@define somethingelse() { ... }
</pre>
</div>
The <em>@import</em> macro only works inside a library file -- at the top
level <em>@import_object</em>, <em>@import_globals</em> or
<em>@with_imports</em> must be used instead. 
</p>


<h5 id=import_spec>Import Specification</h5>
<p>
<em>@import</em>, <em>@with_imports</em>, and <em>@import_globals</em> are 
variable argument macros which support the same import specification.
There are three valid import speicifcation forms, all of which use 
the same library name specification. 
</p>

<b>Library name specification</b>: 
Libraries are specified by a name that maps to their
actual file name. The name is path-like to allow for the organization
of libraries into modules and to help organize the libraries in the file
system. Further, the library name is allowed to be
given arguments (similar to a function call). This allows one to initialize
libraries with parameters specific to the given run. Formally, a library
name is:
<div class="code">
<pre>
[&lt;path1&gt;/[&lt;path2&gt;/ [...]]]&lt;name&gt;[( [arg1 [, arg2 [, ...]]] )]
</pre>
</div>
For instance, consider the library name:
<div class="code">
<pre>
path1/path2/name(1,2)
</pre>
</div>
This will attempt to find the file path1/path2/name.cqct in the current load
path, and then initialize that library with <em>args</em> set to [1,2]
</p>

<p>
The three import specification forms are:
</p>
<p>
<em>library_name</em>: This will import all functions exported by
  that library directly into the local scope before evaluating the local
  scope. 
<div class="code">
<pre>
@with_imports( lib1 ) {
  fn1(); //if lib1 exports a function fn1, this will call that function
  @defloc fn2() { ... } 
  fn2(); // will call the local fn2 even if lib1 exports fn2
}
</pre>
</div>

</p>
<p>
<em>(object_name, library_name)</em>: This will create an object
named <em>object_name</em> that exports access to the functions in
the given library via its "dispatch" function. So if the library contains
a function <em>fn1</em>, one can call that function with the statment
<em>object_name.fn1()</em>. For instance
<div class="code">
<pre>
@with_imports( (l,lib1) ) {
  l.fn1(); //if lib1 exports a function fn1, this will call that function
}
</pre>
</div>
</p>

<p>
<em>(binding, library_name.export)</em>: This will create a local 
binding with the given name to the given library export. For instance:
<div class="code">
<pre>
@import_globals( (lib1_fn1, lib1.fn1) );
lib1_fn1(); //this will call function fn1 exported by library lib1
</pre>
</div>
</p>

<p>
Library names are allowed to include the "/" character to specify
subdirectories inside of the load path. 
If one wants to import a library <em>lib</em> 
that is in a directory <em>dir1/dir2</em> 
that is in the load path, one may use the following constructions:
<div class="code">
<pre>

@import( dir1/dir2/lib, (f1, dir1/dir2/lib.func1) );

@with_imports( dir1/dir2/lib, (f1, dir1/dir2/lib.func1) ) { ... }
</pre>
</div>
</p>

<p>
Imported libraries must be present in the load path. That is, when importing
from <em>lib1</em>, there must be a lib1.cqct present in the load path at
compile time. 
</p>

<p>
Recursive or mutually recursive libraries are currently not supported.
Any <em>@defstx</em> statements in any library are 
bound globally during compilation. 
</p>

<h3>Dynamically determined imports</h3>

<p>The above macros allow one to specify at compile time which library
to import and what function renaming to do. 
If one wants to decide on the library that will be imported at runtime,
one can use the <em>dynamic_imports</em> macro. This macro is just like
the <em>with_imports</em> macro, except that it evaluates its arguments at
runtime and imports libraries specified by the resulting strings. 
For instance:
<div class="code">
<pre>

lib = "dir1"; // dir1/somthing.cqct defines fn1
lib2 = "dir2"; // dir2/something.cqct also defines fn1
foreach(@lambda(dir) {
  @dynamic_imports( sprintfa("(f, %s/something.fn1)",dir) ) {
    f();
  }
}, [lib,lib2]);
</pre>
</div>
</p>

<h3>Cinquecento Library Macros</h3>

<div class="docitem" id="fn:@add_loadpath">
  <div class="proto">
    <div class="function">
      <span class="id">@add_loadpath(path))</span>
    </div>
    <div class="param">
      <span class="arg">path</span>: 
      <span class="type">string</span> 
    </div>
    <div class="returns">
      <span class="type">nothing</span>
    </div>
  </div>
  <div class="desc">
    This function adds the given path to the load path at compile time.
    Note that if path is computed using an expression, the expression will
    be evaluated at compile time before any compiled code has been run.
    Because of this, one can only use simple, self-contained expressions
    to compute path. For instance:
    <div class="code">
      <pre>
@add_loadpath("/"); //legal
@add_loadpath(loadpath()[0]+"../something"); //legal
path = compute_path(); //this statement does not execute until run time
@add_loadpath(path); //error: path is unbound until runtime
@add_loadpath(compute_path()); //error: compute_path is also unbound until runtime
      </pre>
    </div>
  </div>
</div>

<div class="docitem" id="fn:@dynamic_imports">
  <div class="proto">
    <div class="function">
      <span class="id">@dynamic_imports( expression [,expression...] ) 
                            { body }</span>
    </div>
    <div class="param">
      <span class="arg">expression</span>: 
      <span class="type">cqct expressions</span> 
    </div>
  </div>
  <div class="desc">
    Macro that allows one to decide at runtime which libraries are to be 
    imported. The expressions will be evaluated at runtime and should 
    produce string representations of 
    the import_spec statements described in <a href=#fn:@import>@import</a>.
    The macro body will be run with symbols from libraries bound just like an
    <a href=#fn:@with_imports>@with_imports</a> macro.
  </div>
</div>

<div class="docitem" id="fn:@export">
  <div class="proto">
    <div class="function">
      <span class="id">@export( sym1 [, sym2 [,...]] )</span>
    </div>
    <div class="param">
      <span class="arg">sym1</span>: 
      <span class="type">symbol name</span> 
    </div>
    <div class="returns">
      <span class="type">nothing</span>
    </div>
  </div>
  <div class="desc">
    Can only be used inside a library file. 
    Exports the named symbols. Only symbols named in this way will
    be exported from the library.
  </div>
</div>

<div class="docitem" id="fn:@import">
<div class="proto">
<div class="function">
<span class="id">@import( import_spec [, import_spec [,...]] )</span>
</div>
<div class="param">
<span class="arg">import_spec</span>
</div>
<div class="returns">
<span class="type">nothing</span>
</div>
</div>
<div class="desc">
  Can only be used inside a library file. 
  Imports the named libraries and symbols. 
  See <a href=#import_spec>import specification</a> for a list of
  valid import specifications.
</div>
</div>

<div class="docitem" id="fn:@import_globals">
  <div class="proto">
    <div class="function">
      <span class="id">@import_globals( import_spec [, import_spec [,...]] )
      </span>
    </div>
    <div class="param">
      <span class="arg">import_spec</span>: 
      <span class="type">import specification</span> 
    </div>
    <div class="returns">
      <span class="type">nothing</span>
    </div>
  </div>
  <div class="desc">
    Imports the named libraries and symbols to the global scope. 
    For use in top-level execution. Unlike the other library import
    techniques, this will re-load the library from disk every time
    (though it will not re-load the library's dependencies).
    See <a href=#import_spec>import specification</a> for a list of
    valid import specifications.
  </div>
</div>

<div class="docitem" id="fn:@import_object">
  <div class="proto">
    <div class="function">
      <span class="id">@import_object( library )
      </span>
    </div>
    <div class="param">
      <span class="type">library specification</span>
    </div>
    <div class="returns">
      <span class="type">cqct object</span>
    </div>
  </div>
  <div class="desc">
    Imports the named library into a cqct object and returns that
    object. Only bare library names are allowed, i.e.:
    <div class="code">
<pre>
lib = @import_object( subdir/sublib );
lib.fn(); //calls function fn exported by sublib
</pre>
    </div>
  </div>
</div>

<div class="docitem" id="fn:@library">
  <div class="proto">
    <div class="function">
      <span class="id">@library(name) { body }</span>
    </div>
    <div class="param">
      <span class="arg">name</span>: 
      <span class="type">library name</span> 
    </div>
    <div class="param">
      <span class="arg">body</span>: 
      <span class="type">cqct code</span> 
    </div>
  </div>
  <div class="desc">
    This macro parses its containing body as library code with the
    given library name. In the body, the @import and @export macros
    work as though they were in the file associated with the named library.
    This macro can be used to create new libraries or to add to existing
    libraries. 
  </div>
</div>

<div class="docitem" id="fn:@with_exports">
  <div class="proto">
    <div class="function">
      <span class="id">@with_exports(name, sym [, sym [,...]] ) { body }</span>
    </div>
    <div class="param">
      <span class="arg">name</span>: 
      <span class="type">library name</span> 
    </div>
    <div class="param">
      <span class="arg">sym1</span>: 
      <span class="type">symbol names</span> 
    </div>
    <div class="param">
      <span class="arg">body</span>: 
      <span class="type">cqct code</span> 
    </div>
  </div>
  <div class="desc">
    Mainly for internal use. 
    This macro exports the given symbols that are defined in its body
    as though they were associated with the given library name.
  </div>
</div>

<div class="docitem" id="fn:@with_imports">
  <div class="proto">
    <div class="function">
      <span class="id">@with_imports( import_spec [, import_spec [,...]] ) { body }</span>
    </div>
    <div class="param">
      <span class="arg">import_spec</span>: 
      <span class="type">import_spec</span> 
    </div>
    <div class="param">
      <span class="arg">body</span>: 
      <span class="type">cqct code</span> 
    </div>
  </div>
  <div class="desc">
    Used to import code from libraries. 
    All imported symbols will only be visible inside the provided body.
    See <a href=#import_spec>import specification</a> for a list of
    valid import specifications.
  </div>
</div>



</div>
</body>
</html>
