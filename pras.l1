@include <fdas.l1>

protns = @names c32le {
	enum Mkind {
		Rerror = 0,
		Tlaunch,
		Rlaunch,
		Tcont,
		Rcont,

		Tstop,
		Rstop,
		Tkill,
		Rkill,
		Tsetbrk,

		Rsetbrk,
		Tclrbrk,
		Rclrbrk,
		Tread,
		Rread,

		Abrk,
		Aobit,
		Aack,
		Tcleave,
		Rcleave,

		Twrite,
		Rwrite,
		Tsetregs,
		Rsetregs,
		Tsetsnap,

		Rsetsnap,
		Asnap,
		Tattach,
		Rattach,
		Ttest,

		Rtest
	};

	typedef
	struct Reg {
		@0	uint64 ebx;
		@8	uint64 ecx;
		@16	uint64 edx;
		@24	uint64 esi;
		@32	uint64 edi;
		@40	uint64 ebp;
		@48	uint64 eax;
		@56	uint64 eip;
		@64	uint64 esp;
		@72	uint64 eflags;
		@80;
	} Reg;

	struct Rerror{
		@0	uint8 op;
		@1	uint64 id;
		@9	char err[0];
		@9	char bytes[0];
		@9;
	};
	typedef struct Rerror Rerror;
	typedef struct Rerror Rread;

	struct Tlaunch{
		@0	uint8 op;
		@1	uint64 narg;
		@9;
	};
	typedef struct Tlaunch Tlaunch;

	struct Rlaunch{
		@0	uint8 op;
		@1	uint64 id;
		@9	Reg reg;
		@89;
	};
	typedef struct Rlaunch Rlaunch;
	typedef struct Rlaunch Rlaunch;

	struct Rcont{
		@0	uint8 op;
		@1	uint64 id;
		@1	uint64 cnt;
		@9;
	};
	typedef struct Rcont Tcont;
	typedef struct Rcont Rcont;
	typedef struct Rcont Rwrite;
	typedef struct Rcont Rattach;
	typedef struct Rcont Rclrbrk;
	typedef struct Rcont Rkill;
	typedef struct Rcont Rsetregs;
	typedef struct Rcont Aobit;
	typedef struct Rcont Aack;
	typedef struct Rcont Rtest;

	struct Tsetbrk{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@9	uint64 addr;
		@9	uint64 cid;
		@17;
	};
	typedef struct Tsetbrk Tsetbrk;
	typedef struct Tsetbrk Tclrbrk;
	typedef struct Tsetbrk Rsetbrk;
	typedef struct Tsetbrk Rsetsnap;
	typedef struct Tsetbrk Rcleave;

	struct Abrk{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@17	Reg reg;
		@97;
	};
	typedef struct Abrk Abrk;

	struct Asnap{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@17	uint64 cid;
		@25;
	};
	typedef struct Asnap Asnap;
};

define mkpras arg {
	@local addr, fd, cmd, as, protdom, l;
	@local indom, outdom, ip, op, narg, argvlen, i, id, read1;

	define press(t){
		ip = {t}ip;
		return ip++;
	}

	define xwr(v){
		if(iscvalue(v)){
			op = {mkctype_ptr(typeof(v),nsptr(domof(v)))}op;
			*op++ = v;
		}else if(isstring(v)){
			op = (char*)op;
			putbytes(op, v);
			op += strlen(v);
		}else
			error("bad argument to xwr: %a", v);
	}

	define xwp(t){
		...
	}

	define read1() {
		@local sz;

		if(indom.iseof())
			return nil;

		sz = *press(#indom`uint64*#);
		printf("received %u byte reply\n", sz);
		ip = (`uint8*)ip;
		switch((enum Mkind)*ip){
		case indom`Rlaunch:
			return press(#indom`Rlaunch*#);
		case indom`Rcont:
			return press(#indom`Rcont*#);
		case indom`Aobit:
			return press(#indom`Aobit*#);
		case indom`Rstop:
		case indom`Rkill:
		case indom`Rsetbrk:
		case indom`Rclrbrk:
		case indom`Rread:
		case indom`Abrk:
		case indom`Rcleave:
		case indom`Rwrite:
		case indom`Rsetregs:
		case indom`Rsetsnap:
		case indom`Asnap:
		case indom`Rattach:
		case indom`Rtest:
		default:
			error("received unhandled message: %e", *ip);
		}
	}

	addr = listref(arg, 0);
	pop(arg);
	narg = length(arg);
	if(narg == 0)
		error("mkpras: empty command");

	printf("connecting to %s\n", addr);
	fd = opentcp(addr);
	l = mkfdas(fd, nil);
	indom = mkdom(protns, listref(l, 0));
	outdom = mkdom(protns, listref(l, 1));

	printf("sizeof(indom`Tcont) is %d\n", sizeof(indom`Tcont));

	ip = {indom}0;
	op = {outdom}0;

	/* format Tlaunch message */
	argvlen = 0;
	for(i = 0; i < narg; i++)
		argvlen += strlen(listref(arg, i))+1;
	printf("%u bytes in message header\n", sizeof(outdom`Tlaunch));
	printf("%u bytes in argument list\n", argvlen);
	xwr((`uint64)(sizeof(outdom`Tlaunch)+argvlen));
	xwr((`uint8)outdom`Tlaunch);
	xwr((`uint64)narg);
	for(i = 0; i < narg; i++){
		xwr(listref(arg, i));
		xwr((`uint8)0);
	}
	/* send it */
	outdom.flush();

	/* receive Rlaunch reply */
	reply = read1();
	printf("op is %e\n", (enum Mkind)reply->op);
	id = reply->id;
	printf("id is %u\n", id);
	printf("eip is %x\n", reply->reg.eip);
	indom.flush();

	/* continue proc */
	xwr((`uint64)sizeof(outdom`Tcont));
	xwr((`uint8)outdom`Tcont);	
	xwr(id);
	outdom.flush();

	/* receive Rcont reply */
	reply = read1();
	printf("op is %e\n", (enum Mkind)reply->op);
	printf("id is %u\n", reply->id);
	indom.flush();

	/* receive Aobit */
	reply = read1();
	printf("op is %e\n", (enum Mkind)reply->op);
	printf("id is %u\n", reply->id);
	indom.flush();
	
	/* send Aack */
	xwr((`uint64)sizeof(outdom`Aack));
	xwr((`uint8)outdom`Aack);	
	xwr(id);
	outdom.flush();
}
