@include <fdas.l1>

protns = @names c32le {
	enum Mkind {
		Rerror = 0,
		Tlaunch,
		Rlaunch,
		Tcont,
		Rcont,

		Tstop,
		Rstop,
		Tkill,
		Rkill,
		Tsetbrk,

		Rsetbrk,
		Tclrbrk,
		Rclrbrk,
		Tread,
		Rread,

		Abrk,
		Aobit,
		Aack,
		Tcleave,
		Rcleave,

		Twrite,
		Rwrite,
		Tsetregs,
		Rsetregs,
		Tsetsnap,

		Rsetsnap,
		Asnap,
		Tattach,
		Rattach,
		Ttest,

		Rtest
	};

	enum State {
		Running,
		Stopped,
		Dead,
	};

	typedef
	struct Reg {
		@0	uint64 ebx;
		@8	uint64 ecx;
		@16	uint64 edx;
		@24	uint64 esi;
		@32	uint64 edi;
		@40	uint64 ebp;
		@48	uint64 eax;
		@56	uint64 eip;
		@64	uint64 esp;
		@72	uint64 eflags;
		@80;
	} Reg;

	struct Rerror{
		@0	uint8 op;
		@1	uint64 id;
		@9	char err[0];
		@9	char bytes[0];
		@9;
	};
	typedef struct Rerror Rerror;
	typedef struct Rerror Rread;

	struct Tlaunch{
		@0	uint8 op;
		@1	uint64 narg;
		@9;
	};
	typedef struct Tlaunch Tlaunch;

	struct Rlaunch{
		@0	uint8 op;
		@1	uint64 id;
		@9	Reg reg;
		@89;
	};
	typedef struct Rlaunch Rlaunch;
	typedef struct Rlaunch Rstop;
	typedef struct Rlaunch Tsetregs;

	struct Rcont{
		@0	uint8 op;
		@1	uint64 id;
		@1	uint64 cnt;
		@9;
	};
	typedef struct Rcont Tcont;
	typedef struct Rcont Tstop;
	typedef struct Rcont Rcont;
	typedef struct Rcont Rwrite;
	typedef struct Rcont Rattach;
	typedef struct Rcont Rclrbrk;
	typedef struct Rcont Rkill;
	typedef struct Rcont Rsetregs;
	typedef struct Rcont Aobit;
	typedef struct Rcont Aack;
	typedef struct Rcont Rtest;

	struct Tsetbrk{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@9	uint64 addr;
		@9	uint64 cid;
		@17;
	};
	typedef struct Tsetbrk Tsetbrk;
	typedef struct Tsetbrk Tclrbrk;
	typedef struct Tsetbrk Rsetbrk;
	typedef struct Tsetbrk Rsetsnap;
	typedef struct Tsetbrk Rcleave;

	struct Abrk{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@17	Reg reg;
		@97;
	};
	typedef struct Abrk Abrk;

	struct Asnap{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@9	uint64 addr;
		@17	uint64 cid;
		@17	uint64 cnt;
		@25	char bytes[0];
		@25;
	};
	typedef struct Asnap Asnap;
	typedef struct Asnap Tread;
	typedef struct Asnap Twrite;
};

define mkpras arg {
	@local addr, fd, cmd, as, protdom, l;
	@local indom, outdom, ip, op, p;
	@local read1, ipress, opress, xwr, copydata, checkreply;
	@local launch, cont, brk, ack, xread, xwrite, setbrk, clrbrk, sync;
	@local dispatch, get, put;
	@local id, state, reg;
	@local brktab, dtab;
	@local logsend, logrecv, verbose;

	verbose = 0;

	define logsend(s){
		if(verbose)
			printf("%s <-- %s\n", addr, s);
	}

	define logrecv(s){
		if(verbose)
			printf("%s --> %s\n", addr, s);
	}

	/* read n-1th byte ahead in input stream,
	   thereby extending window to include it and preceding bytes. */
	define ifetch(n){
		@local p;
		p = (char*)ip;
		p += n-1;
		p = *p;
	}

	define ipress(t){
		ip = {t}ip;
		return ip++;
	}

	define opress(t){
		op = {t}op;
		return op++;
	}

	define copydata(p){
		@local dom;
		dom = mkdom(nsof(p), mksas(getbytes(p)));
		return {typeof(p)}{dom}0;
	}

	define xwr(v){
		if(iscvalue(v)){
			op = {mkctype_ptr(typeof(v),nsptr(domof(v)))}op;
			*op++ = v;
		}else if(isstring(v)){
			op = (char*)op;
			putbytes(op, v);
			op += strlen(v);
		}else
			error("bad argument to xwr: %a", v);
	}

	define xrds(cnt){
		@local s;
		ip = (char*)ip;
		s = getbytes(ip, cnt);
		ip += cnt;
		return s;
	}

	define read1() {
		@local sz;

		if(indom.iseof())
			return nil;

		sz = *ipress(#indom`uint64*#);
		ifetch(sz);
		ip = (`uint8*)ip;
		switch((enum Mkind)*ip){
		case indom`Rerror:
			return ipress(#indom`Rerror*#);
		case indom`Rlaunch:
			return ipress(#indom`Rlaunch*#);
		case indom`Rcont:
			return ipress(#indom`Rcont*#);
		case indom`Aobit:
			return ipress(#indom`Aobit*#);
		case indom`Rstop:
			return ipress(#indom`Rstop*#);
		case indom`Rsetbrk:
			return ipress(#indom`Rsetbrk*#);
		case indom`Rclrbrk:
			return ipress(#indom`Rclrbrk*#);
		case indom`Rread:
			return ipress(#indom`Rread*#);
		case indom`Abrk:
			return ipress(#indom`Abrk*#);
		case indom`Rwrite:
			return ipress(#indom`Rwrite*#);
		case indom`Rsetregs:
			return ipress(#indom`Rsetregs*#);
		case indom`Rcleave:
		case indom`Rsetsnap:
		case indom`Asnap:
		case indom`Rattach:
		case indom`Rtest:
		case indom`Rkill:
		default:
			error("received unhandled message: %e", *ip);
		}
	}

	define checkreply(op, reply){
		if(reply == nil)
			error("unexpected end of file from prctl");
		if(reply->op == indom`Rerror)
			error("pras: while waiting for %e: %s",
			      op, reply->bytes);
		if(reply->op != op)
			error("pras: while waiting for %e: received %e",
			      op, (enum Mkind)reply->op);
	}

	define launch(arg){
		@local argvlen, narg, i;

		narg = length(arg);
		if(narg == 0)
			error("mkpras: launch: empty command");

		/* format Tlaunch message */
		argvlen = 0;
		for(i = 0; i < narg; i++)
			argvlen += strlen(listref(arg, i))+1;
		xwr((`uint64)(sizeof(outdom`Tlaunch)+argvlen));
		p = opress(#outdom`Tlaunch*#);
		p->op = outdom`Tlaunch;
		p->narg = narg;
		for(i = 0; i < narg; i++){
			xwr(listref(arg, i));
			xwr((`uint8)0);
		}
		outdom.flush();
		logsend("Tlaunch");

		/* receive Rlaunch reply */
		reply = read1();
		checkreply(indom`Rlaunch, reply);
		id = reply->id;
		reg = copydata(&reply->reg);
		indom.flush();
		logrecv("Rlaunch");

		state = indom`Stopped;
	}

	define cont(){
		if(state != indom`Stopped)
			return;

		xwr((`uint64)sizeof(outdom`Tcont));
		p = opress(#outdom`Tcont*#);
		p->op = outdom`Tcont;
		p->id = id;
		outdom.flush();
		logsend("Tcont");

		reply = read1();
		checkreply(indom`Rcont, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		indom.flush();
		logrecv("Rcont");

		state = indom`Running;
	}

	define brk(){
		if(state != indom`Running)
			return;

		xwr((`uint64)sizeof(outdom`Tstop));
		p = opress(#outdom`Tstop*#);
		p->op = outdom`Tstop;
		p->id = id;
		outdom.flush();
		logsend("Tstop");

		reply = read1();
		checkreply(indom`Rstop, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		reg = copydata(reply->reg);
		indom.flush();
		logrecv("Rstop");

		state = indom`Stopped;
	}

	define ack(){
		xwr((`uint64)sizeof(outdom`Aack));
		p = opress(#outdom`Aack*#);
		p->op = outdom`Aack;
		p->id = id;
		outdom.flush();
		logsend("Aack");
	}

	define xread(addr, cnt){
		@local s;

		xwr((`uint64)sizeof(outdom`Tread));
		p = opress(#outdom`Tread*#);
		p->op = outdom`Tread;
		p->id = id;
		p->addr = addr;
		p->cnt = cnt;
		outdom.flush();
		logsend("Tread");

		reply = read1();
		checkreply(indom`Rread, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		s = xrds(cnt);
		indom.flush();
		logrecv("Rread");

		return s;
	}

	define xwrite(addr, cnt, bytes){
		xwr((`uint64)(sizeof(outdom`Twrite)+cnt));
		p = opress(#outdom`Twrite*#);
		p->op = outdom`Twrite;
		p->id = id;
		p->addr = addr;
		p->cnt = cnt;
		xwr(bytes);
		outdom.flush();
		logsend("Twrite");

		reply = read1();
		checkreply(indom`Rwrite, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		indom.flush();
		logrecv("Rwrite");
	}

	define setbrk(addr, fn){
		@local bp;

		xwr((`uint64)sizeof(outdom`Tsetbrk));
		p = opress(#outdom`Tsetbrk*#);
		p->op = outdom`Tsetbrk;
		p->id = id;
		p->addr = addr;
		outdom.flush();
		logsend("Tsetbrk");

		reply = read1();
		checkreply(indom`Rsetbrk, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		bp = reply->bp;
		tabinsert(brktab, bp, [addr, fn]);
		indom.flush();
		logrecv("Rsetbrk");

		return bp;
	}

	define clrbrk(bp){
		xwr((`uint64)sizeof(outdom`Tclrbrk));
		p = opress(#outdom`Tclrbrk*#);
		p->op = outdom`Tclrbrk;
		p->id = id;
		p->bp = bp;
		outdom.flush();
		logsend("Tclrbrk");

		reply = read1();
		checkreply(indom`Rclrbrk, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		tabdelete(brktab, bp);
		indom.flush();
		logrecv("Rclrbrk");
	}

	define setregs(){
		xwr((`uint64)sizeof(outdom`Tsetregs));
		p = opress(#outdom`Tsetregs*#);
		p->op = outdom`Tsetregs;
		p->id = id;
		putbytes(&p->reg, getbytes(reg));
		outdom.flush();
		logsend("Tsetregs");

		reply = read1();
		checkreply(indom`Rsetregs, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		indom.flush();
		logrecv("Rsetregs");
	}

	define sync(){
		@local bp, rv;

		reply = read1();
		switch(reply->op){
		case indom`Aobit:
			logrecv("Aobit");
			ack();
			if(reply->id != id)
				error("pras: got obituary for unknown task");
			indom.flush();
			state = indom`Dead;
			break;
		case indom`Abrk:
			logrecv("Abrk");
			ack();
			if(reply->id != id)
				error("pras: got %e for unknown task",
				      (enum Mkind)reply->op);
			reg = copydata(&reply->reg);
			state = indom`Stopped;
			bp = tablook(brktab, reply->bp);
			if(bp == nil)
				error("unregistered breakpoint: %d",
				      reply->bp);
			indom.flush();
			rv = listref(bp, 1)(listref(bp, 0));
			if(rv != 1)
				cont();
			break;
		case indom`Asnap:
			logrecv("Asnap");
			error("pras: sync: unhandled message: %e",
			      (enum Mkind)reply->op);
		default:
			error("pras: sync: unexpected message: %e",
			      (enum Mkind)reply->op);
		}
	}

	define contwait(){
		cont();
		while(state == indom`Running)
			sync();
	}

	define get(r){
		return xread(rangebeg(r), rangelen(r));
	}

	define put(r, s){
		return xwrite(rangebeg(r), rangelen(r), s);
	}

	define map(){
		return vector(mkrange(0, (uint64)-1));
	}

	define getebx() { return {litdom}reg->ebx; }
	define getecx() { return {litdom}reg->ecx; }
	define getedx() { return {litdom}reg->edx; }
	define getesi() { return {litdom}reg->esi; }
	define getedi() { return {litdom}reg->edi; }
	define getebp() { return {litdom}reg->ebp; }
	define geteax() { return {litdom}reg->eax; }
	define geteip() { return {litdom}reg->eip; }
	define getesp() { return {litdom}reg->esp; }
	define geteflags() { return {litdom}reg->eflags; }

	define setebx(x) { reg->ebx = x; setregs(); }
	define setecx(x) { reg->ecx = x; setregs(); }
	define setedx(x) { reg->edx = x; setregs(); }
	define setesi(x) { reg->esi = x; setregs(); }
	define setedi(x) { reg->edi = x; setregs(); }
	define setebp(x) { reg->ebp = x; setregs(); }
	define seteax(x) { reg->eax = x; setregs(); }
	define seteip(x) { reg->eip = x; setregs(); }
	define setesp(x) { reg->esp = x; setregs(); }
	define seteflags(x) { reg->eflags = x; setregs(); }

	dtab = mktab();
	tabinsert(dtab, "get",		get);
	tabinsert(dtab, "put",		put);
	tabinsert(dtab, "map",		map);

	tabinsert(dtab, "getebx",	getebx);
	tabinsert(dtab, "getecx",	getecx);
	tabinsert(dtab, "getedx",	getedx);
	tabinsert(dtab, "getesi",	getesi);
	tabinsert(dtab, "getedi",	getedi);
	tabinsert(dtab, "getebp",	getebp);
	tabinsert(dtab, "geteax",	geteax);
	tabinsert(dtab, "geteip",	geteip);
	tabinsert(dtab, "getesp",	getesp);

	tabinsert(dtab, "setebx",	setebx);
	tabinsert(dtab, "setecx",	setecx);
	tabinsert(dtab, "setedx",	setedx);
	tabinsert(dtab, "setesi",	setesi);
	tabinsert(dtab, "setedi",	setedi);
	tabinsert(dtab, "setebp",	setebp);
	tabinsert(dtab, "seteax",	seteax);
	tabinsert(dtab, "seteip",	seteip);
	tabinsert(dtab, "setesp",	setesp);

	tabinsert(dtab, "getrbx",	getebx);
	tabinsert(dtab, "getrcx",	getecx);
	tabinsert(dtab, "getrdx",	getedx);
	tabinsert(dtab, "getrsi",	getesi);
	tabinsert(dtab, "getrdi",	getedi);
	tabinsert(dtab, "getrbp",	getebp);
	tabinsert(dtab, "getrax",	geteax);
	tabinsert(dtab, "getrip",	geteip);
	tabinsert(dtab, "getrsp",	getesp);

	tabinsert(dtab, "setrbx",	setebx);
	tabinsert(dtab, "setrcx",	setecx);
	tabinsert(dtab, "setrdx",	setedx);
	tabinsert(dtab, "setrsi",	setesi);
	tabinsert(dtab, "setrdi",	setedi);
	tabinsert(dtab, "setrbp",	setebp);
	tabinsert(dtab, "setrax",	seteax);
	tabinsert(dtab, "setrip",	seteip);
	tabinsert(dtab, "setrsp",	setesp);

	tabinsert(dtab, "geteflags",	geteflags);
	tabinsert(dtab, "seteflags",	seteflags);

	tabinsert(dtab, "bpset",	setbrk);
	tabinsert(dtab, "bpdel",	clrbrk);
	tabinsert(dtab, "xcont",	cont);
	tabinsert(dtab, "xcontwait",	contwait);
	tabinsert(dtab, "xbreak",	brk);

	define dispatch arg {
		cmd = pop(arg);
		fn = tablook(dtab, cmd);
		if(fn == nil)
			error("call to undefined pras operator: %s", cmd);
		return apply(fn, arg);
	}

	addr = listref(arg, 0);
	pop(arg);
	fd = opentcp(addr);
	l = mkfdas(fd, nil);
	indom = mkdom(protns, listref(l, 0));
	outdom = mkdom(protns, listref(l, 1));
	ip = {indom}0;
	op = {outdom}0;
	brktab = mktab();

	launch(arg);
	return mkas(dispatch);
}

define testpras()
{
	return mkpras("localhost:30000", "/home/vczandy/src/l1/test/aqsort");
}
