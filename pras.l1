@include <fdas.l1>

protns = @names c32le {
	enum Mkind {
		Rerror = 0,
		Tlaunch,
		Rlaunch,
		Tcont,
		Rcont,

		Tstop,
		Rstop,
		Tkill,
		Rkill,
		Tsetbrk,

		Rsetbrk,
		Tclrbrk,
		Rclrbrk,
		Tread,
		Rread,

		Abrk,
		Aobit,
		Aack,
		Tcleave,
		Rcleave,

		Twrite,
		Rwrite,
		Tsetregs,
		Rsetregs,
		Tsetsnap,

		Rsetsnap,
		Asnap,
		Tattach,
		Rattach,

		Ttest,
		Rtest
	};

	struct Msg {
		@0	unsigned char op;
		@4	uint64 id;	/* all except Tlaunch */
		@12	uint64 addr;	/* Tread, Twrite, Tsetbrk, Tsetsnap */
		@20	uint64 bp;	/* Rsetbrk, Rsetsnap, Tclrbrk,
					   Abrk, Asnap */
		@28	uint64 cnt;	/* Tread, Twrite */
		@36	uint64 cid;	/* Rcleave, Asnap */
		@44	Reg reg;	/* Abrk, Rstop, Rlaunch */
		@124	char *bytes;	/* Rread, Twrite */
		@128	char **argv;	/* Tlaunch */
		@132	char *err;	/* Rerror */
		@136;
	};

	struct Reg {
		@0	uint64 ebx;
		@8	uint64 ecx;
		@16	uint64 edx;
		@24	uint64 esi;
		@32	uint64 edi;
		@40	uint64 ebp;
		@48	uint64 eax;
		@56	uint64 eip;
		@64	uint64 esp;
		@72	uint64 eflags;
		@80;
	};
	typedef struct Reg Reg;

	struct Hdr {
		@0	uint64	len;
		@8	unsigned char op;
		@12;
	};

	struct Ttest {
		@0	uint64	len;
		@8	unsigned char op;
		@9	uint64 cnt;
		@17	char bytes[0];
		@17;
	};

	struct Rtest {
		@0	uint64	len;
		@8	unsigned char op;
		@9	uint64 cnt;
		@17	char bytes[0];
		@17;
	};

	struct Tlaunch{
		@0	uint8 op;
		@1	uint64 narg;
		@9;
	};

	struct Rlaunch{
		@0	uint8 op;
		@1	uint64 id;
		@9	struct Reg reg;
		@89;
	};

	struct Tcont{
		@0	uint8 op;
		@1	uint64 id;
		@9;
	};

	struct Rcont{
		@0	uint8 op;
		@1	uint64 id;
		@9;
	};

	struct Aobit{
		@0	uint8 op;
		@1	uint64 id;
		@9;
	};
	
	struct Aack{
		@0	uint8 op;
		@1	uint64 id;
		@9;
	};
};

define mkpras arg {
	@local addr, fd, cmd, as, protdom, l;
	@local indom, outdom, ip, op, narg, argvlen, i, id;

	addr = listref(arg, 0);
	pop(arg);
	narg = length(arg);
	if(narg == 0)
		error("mkpras: empty command");

	printf("connecting to %s\n", addr);
	fd = opentcp(addr);
	l = mkfdas(fd, nil);
	indom = mkdom(protns, listref(l, 0));
	outdom = mkdom(protns, listref(l, 1));

	/* format Tlaunch message */
	op = (`uint64*){outdom}0;
	argvlen = 0;
	for(i = 0; i < narg; i++)
		argvlen += strlen(listref(arg, i))+1;
	printf("%u bytes in argument list\n", argvlen);
	*op++ = sizeof(struct outdom`Tlaunch)+argvlen;
	printf("after len, op: %p\n", op);
	op = (struct Tlaunch*)op;
	op->op = outdom`Tlaunch;
	op->narg = narg;
	printf("before ++, op: %p (sizeof *op is %u)\n", op, sizeof(*op));
	op++;
	printf("after ++, op: %p (sizeof *op is %u)\n", op, sizeof(*op));
	op = (char*)op;
	for(i = 0; i < narg; i++){
		printf("arg %u, op: %p\n", i, op);
		putbytes(op, listref(arg, i));
		op += strlen(listref(arg, i));
		*op++ = 0;
	}

	/* send it */
	outdom.flush();

	/* receive Rlaunch reply */
	ip = (`uint64*){indom}0;
	printf("received %u byte reply\n", *ip);
	ip++;
	ip = (struct Rlaunch*)ip;
	printf("op is %u\n", ip->op);
	id = ip->id;
	printf("id is %u\n", id);
	printf("eip is %x\n", ip->reg.eip);
	ip++;

	/* continue proc */
	op = (`uint64*)op;
	*op++ = sizeof(struct outdom`Tcont);
	op = (struct Tcont*)op;
	op->op = outdom`Tcont;
	op->id = id;
	op++;
	outdom.flush();

	/* receive Rcont reply */
	ip = (`uint64*)ip;
	printf("received %u byte reply\n", *ip);
	ip++;
	ip = (struct Rcont*)ip;
	printf("op is %u\n", ip->op);
	printf("id is %u\n", ip->id);
	ip++;

	/* receive Aobit */
	ip = (`uint64*)ip;
	printf("received %u byte msg\n", *ip);
	ip++;
	ip = (struct Aobit*)ip;
	printf("op is %u\n", ip->op);
	printf("id is %u\n", ip->id);
	ip++;
	
	/* send Aack */
	op = (`uint64*)op;
	*op++ = sizeof(struct outdom`Aack);
	op = (struct Tcont*)op;
	op->op = outdom`Aack;
	op->id = id;
	op++;
	outdom.flush();

}

