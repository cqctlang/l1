@include <fdas.l1>

protns = @names c32le {
	enum Mkind {
		Rerror = 0,
		Tlaunch,
		Rlaunch,
		Tcont,
		Rcont,

		Tstop,
		Rstop,
		Tkill,
		Rkill,
		Tsetbrk,

		Rsetbrk,
		Tclrbrk,
		Rclrbrk,
		Tread,
		Rread,

		Abrk,
		Aobit,
		Aack,
		Tcleave,
		Rcleave,

		Twrite,
		Rwrite,
		Tsetregs,
		Rsetregs,
		Tsetsnap,

		Rsetsnap,
		Asnap,
		Tattach,
		Rattach,
		Ttest,

		Rtest
	};

	enum State {
		Running,
		Stopped,
		Dead,
	};

	typedef
	struct Reg {
		@0	uint64 ebx;
		@8	uint64 ecx;
		@16	uint64 edx;
		@24	uint64 esi;
		@32	uint64 edi;
		@40	uint64 ebp;
		@48	uint64 eax;
		@56	uint64 eip;
		@64	uint64 esp;
		@72	uint64 eflags;
		@80;
	} Reg;

	struct Rerror{
		@0	uint8 op;
		@1	uint64 id;
		@9	char err[0];
		@9	char bytes[0];
		@9;
	};
	typedef struct Rerror Rerror;
	typedef struct Rerror Rread;

	struct Tlaunch{
		@0	uint8 op;
		@1	uint64 narg;
		@9;
	};
	typedef struct Tlaunch Tlaunch;

	struct Rlaunch{
		@0	uint8 op;
		@1	uint64 id;
		@9	Reg reg;
		@89;
	};
	typedef struct Rlaunch Rlaunch;
	typedef struct Rlaunch Rstop;

	struct Rcont{
		@0	uint8 op;
		@1	uint64 id;
		@1	uint64 cnt;
		@9;
	};
	typedef struct Rcont Tcont;
	typedef struct Rcont Tstop;
	typedef struct Rcont Rcont;
	typedef struct Rcont Rwrite;
	typedef struct Rcont Rattach;
	typedef struct Rcont Rclrbrk;
	typedef struct Rcont Rkill;
	typedef struct Rcont Rsetregs;
	typedef struct Rcont Aobit;
	typedef struct Rcont Aack;
	typedef struct Rcont Rtest;

	struct Tsetbrk{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@9	uint64 addr;
		@9	uint64 cid;
		@17;
	};
	typedef struct Tsetbrk Tsetbrk;
	typedef struct Tsetbrk Tclrbrk;
	typedef struct Tsetbrk Rsetbrk;
	typedef struct Tsetbrk Rsetsnap;
	typedef struct Tsetbrk Rcleave;

	struct Abrk{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@17	Reg reg;
		@97;
	};
	typedef struct Abrk Abrk;

	struct Asnap{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@17	uint64 cid;
		@25;
	};
	typedef struct Asnap Asnap;
};

define mkpras arg {
	@local addr, fd, cmd, as, protdom, l;
	@local indom, outdom, ip, op, p;
	@local read1, ipress, opress, xwr, launch; 
	@local id, state, reg;

	define ipress(t){
		ip = {t}ip;
		return ip++;
	}

	define opress(t){
		op = {t}op;
		return op++;
	}

	define copydata(p){
		@local dom;
		dom = mkdom(nsof(p), mksas(getbytes(p)));
		return {typeof(p)}{dom}0;
	}

	define xwr(v){
		if(iscvalue(v)){
			op = {mkctype_ptr(typeof(v),nsptr(domof(v)))}op;
			*op++ = v;
		}else if(isstring(v)){
			op = (char*)op;
			putbytes(op, v);
			op += strlen(v);
		}else
			error("bad argument to xwr: %a", v);
	}

	define read1() {
		@local sz;

		if(indom.iseof())
			return nil;

		sz = *ipress(#indom`uint64*#);
		printf("received %u byte reply\n", sz);
		ip = (`uint8*)ip;
		switch((enum Mkind)*ip){
		case indom`Rlaunch:
			return ipress(#indom`Rlaunch*#);
		case indom`Rcont:
			return ipress(#indom`Rcont*#);
		case indom`Aobit:
			return ipress(#indom`Aobit*#);
		case indom`Rstop:
		case indom`Rkill:
		case indom`Rsetbrk:
		case indom`Rclrbrk:
		case indom`Rread:
		case indom`Abrk:
		case indom`Rcleave:
		case indom`Rwrite:
		case indom`Rsetregs:
		case indom`Rsetsnap:
		case indom`Asnap:
		case indom`Rattach:
		case indom`Rtest:
		default:
			error("received unhandled message: %e", *ip);
		}
	}

	define checkreply(op, reply){
		if(reply->op == indom`Rerror)
			error("pras: while waiting for %e: %s",
			      op, reply->bytes);
		if(reply->op != op)
			error("pras: while waiting for %e: received %e",
			      op, (enum Mkind)reply->op);
	}

	define launch(arg){
		@local argvlen, narg, i;

		narg = length(arg);
		if(narg == 0)
			error("mkpras: launch: empty command");

		/* format Tlaunch message */
		argvlen = 0;
		for(i = 0; i < narg; i++)
			argvlen += strlen(listref(arg, i))+1;
		xwr((`uint64)(sizeof(outdom`Tlaunch)+argvlen));
		p = opress(#outdom`Tlaunch*#);
		p->op = outdom`Tlaunch;
		p->narg = narg;
		for(i = 0; i < narg; i++){
			xwr(listref(arg, i));
			xwr((`uint8)0);
		}
		outdom.flush();

		/* receive Rlaunch reply */
		reply = read1();
		checkreply(indom`Rlaunch, reply);
		id = reply->id;
		printf("about to copydata\n");
		reg = copydata(&reply->reg);
		printf("did copydata\n");
		indom.flush();

		state = indom`Stopped;
	}

	define cont(){
		if(state != indom`Stopped)
			return;

		xwr((`uint64)sizeof(outdom`Tcont));
		p = opress(#outdom`Tcont*#);
		p->op = outdom`Tcont;
		p->id = id;
		outdom.flush();

		reply = read1();
		checkreply(indom`Rcont, reply);
		indom.flush();

		state = indom`Running;
	}

	define brk(){
		if(state != indom`Running)
			return;

		xwr((`uint64)sizeof(outdom`Tstop));
		p = opress(#outdom`Tstop*#);
		p->op = outdom`Tstop;
		p->id = id;
		outdom.flush();

		reply = read1();
		checkreply(indom`Rstop, reply);
		reg = copydata(reply->reg);
		indom.flush();

		state = indom`Stopped;
	}

	define ack(){
		xwr((`uint64)sizeof(outdom`Aack));
		p = opress(#outdom`Aack*#);
		p->op = outdom`Aack;
		p->id = id;
		outdom.flush();
	}

	define sync(){
		reply = read1();
		switch(reply->op){
		case indom`Aobit:
			ack();
			if(reply->id != id)
				error("pras: got obituary for unknown task");
			state = indom`Dead;
			break;
		case indom`Abrk:
		case indom`Asnap:
			error("pras: sync: unhandled message: %e",
			      (enum Mkind)reply->op);
		default:
			error("pras: sync: unexpected message: %e",
			      (enum Mkind)reply->op);
		}
	}

	addr = listref(arg, 0);
	pop(arg);
	printf("connecting to %s\n", addr);
	fd = opentcp(addr);
	l = mkfdas(fd, nil);
	indom = mkdom(protns, listref(l, 0));
	outdom = mkdom(protns, listref(l, 1));
	ip = {indom}0;
	op = {outdom}0;
	launch(arg);

	cont();
	sync();
}

define testpras()
{
	mkpras("localhost:30000", "/bin/ls", "/");
}
