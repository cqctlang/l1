@define typenamecmp(t1, t2)
{
	@local k1, k2, b1, b2, s1, s2;
	k1 = typekind(t1);
	k2 = typekind(t2);
	if(k1 != k2){
		if(k1 < k2)
			return -1;
		else
			return 1;
	}
	switch(k1){
	case cqct`Tvoid:
		return 0;
	case cqct`Tbase:
		b1 = basebase(t1);
		b2 = basebase(t2);
		if(b1 == b2)
			return 0;
		else if(b1 < b2)
			return -1;
		else
			return 1;
		break;
	case cqct`Tstruct:
	case cqct`Tunion:
	case cqct`Tenum:
		s1 = cid2str(suetag(t1));
		s2 = cid2str(suetag(t2));
		return strcmp(s1, s2);
	case cqct`Ttypedef:
		s1 = cid2str(typedefid(t1));
		s2 = cid2str(typedefid(t2));
		return strcmp(s1, s2);
	default:
		/* arbitrary */
		return 0;
	}
}

@define encodes(p, s)
{
	@local m;
	m = strlen(s);
	p = (`uint64*)p;
	*p++ = m;
	p = (char*)p;
	putbytes(p, s);
	p += m;
	return p;
}

@define decodes(p)
{
	@local sz, s;
	p = (`uint64*)p;
	sz = *p++;
	s = getbytes(p, sz);
	p = (`uint8*)((char*)p+sz);
	return [s, p];
}

@define encodetname(p, t)
{
	@local m;

	@defloc loop(t)
	{
		@local id;
		p = (`uint8*)p;
		if(isbase(t)){
			*p++ = cqct`Tbase;
			*p++ = (`uint8)basebase(t);
			return p;
		}else if(issu(t) || isenum(t)){
			if(isstruct(t))
				*p++ = cqct`Tstruct;
			else if(isunion(t))
				*p++ = cqct`Tunion;
			else if(isenum(t))
				*p++ = cqct`Tenum;
			else
				error("bug");
			return encodes(p, cid2str(suetag(t)));
		}else if(istypedef(t)){
			*p++ = cqct`Ttypedef;
			return encodes(p, cid2str(typedefid(t)));
		}else if(isptr(t)){
			*p++ = cqct`Tptr;
			return loop(subtype(t));
		}else if(isarray(t)){
			*p++ = cqct`Tarr;
			p = (`uint64*)p;
			m = arraynelm(t);
			if(m == nil)
				*p++ = 0; /* FIXME: maybe want escape */
			else
				*p++ = m;
			return loop(subtype(t));
		}else if(isfunc(t)){
			*p++ = cqct`Tfun;
			p = loop(rettype(t));
			p = (`uint64*)p;
			*p++ = length(params(t));
			p = (`uint8*)p;
			foreach(@lambda(par){
					id = paramid(par);
					if(id == nil)
						p = encodes(p, "");
					else
						p = encodes(p, cid2str(id));
					p = loop(paramtype(par));
				}, params(t));
			return p;
		}else if(isvoid(t)){
			*p++ = cqct`Tbase;
			*p++ = (`uint8)cqct`Vvoid;
			return p;
		}else if(isundeftype(t)){
			*p++ = cqct`Tundef;
			return loop(subtype(t));
		}else if(isenumconst(t)){
			*p++ = cqct`Tconst;
			return loop(subtype(t));
		}else if(isbitfield(t)){
			*p++ = cqct`Tbitfield;
			p = (`uint8*)p;
			*p++ = bitfieldwidth(t);
			*p++ = bitfieldpos(t);
			p = loop(bitfieldcontainer(t));
			return p;
		}else
			error("unhandled type name %t", t);
	}

	return loop(t);
}

@define encodetdef(p, t)
{
	printf("encoding %t\n", t);

	p = (`uint8*)p;
	if(isbase(t)){
		*p++ = cqct`Tbase;
		*p++ = (`uint8)basebase(t);
		*p++ = (`uint8)baserep(t);
		return p;
	}else if(issu(t)){
		if(isstruct(t))
			*p++ = cqct`Tstruct;
		else if(isunion(t))
			*p++ = cqct`Tunion;
		p = encodes(p, cid2str(suetag(t)));
		p = (`uint64*)p;
		*p++ = susize(t);
		*p++ = length(fields(t));
		foreach(@lambda(f){
				p = (`uint64*)p;
				*p++ = fieldoff(f);
				p = encodes(p, cid2str(fieldid(f)));
				p = encodetname(p, fieldtype(f));
			}, fields(t));
		return p;
	}else if(isenum(t)){
		*p++ = cqct`Tenum;
		p = encodes(p, cid2str(suetag(t)));
		p = (`uint8*)p;
		*p++ = baserep(subtype(t));
		p = (`uint64*)p;
		*p++ = length(enumconsts(t));
		foreach(@lambda(ec){
				p = encodes(p, cid2str(ec[0]));
				p = (`uint64*)p;
				*p++ = ec[1];
			}, enumconsts(t));
		return p;
	}else if(istypedef(t)){
		*p++ = cqct`Ttypedef;
		p = encodes(p, cid2str(typedefid(t)));
		p = encodetname(p, typedeftype(t));
		return p;
	}else if(isptr(t)){
		if(!isvoid(subtype(t)))
			error("unhandled type definition %t", t);
		/* void* is special case of Tbase */
		*p++ = cqct`Tbase;
		*p++ = (`uint8)basebase(t);
		*p++ = (`uint8)baserep(t);
		return p;
	}else
		error("unhandled type definition %t", t);
}

@define decodetname(q)
{
	@local k, cb, id, w, pos, st, pt, n, v, i, sid;

	q = (`uint8*)q;
	k = *q++;
	switch(k){
	case cqct`Tbase:
		cb = *q++;
		return [mkctype_base(cb), q];
	case cqct`Tstruct:
		[id, q] = decodes(q);
		return [mkctype_struct(mkcid(id)), q];
	case cqct`Tunion:
		[id, q] = decodes(q);
		return [mkctype_union(mkcid(id)), q];
	case cqct`Tenum:
		[id, q] = decodes(q);
		return [mkctype_enum(mkcid(id)), q];
	case cqct`Ttypedef:
		[id, q] = decodes(q);
		return [mkctype_typedef(mkcid(id)), q];
	case cqct`Tptr:
		[st, q] = decodetname(q);
		return [mkctype_ptr(st), q];
	case cqct`Tconst:
		[st, q] = decodetname(q);
		return [mkctype_const(st), q];
	case cqct`Tarr:
		q = (`uint64*)q;
		n = *q++;
		[st, q] = decodetname(q);
		return [mkctype_array(st, n), q];
	case cqct`Tfun:
		[st, q] = decodetname(q);
		q = (`uint64*)q;
		n = *q++;
		v = mkvec(n);
		for(i = 0; i < n; i++){
			[sid, q] = decodes(q);
			[pt, q] = decodetname(q);
			v[i] = mkparam(pt, strlen(sid) > 0 ? mkcid(sid) : nil);
		}
		return [mkctype_fn(st, v), q];
	case cqct`Tbitfield:
		q = (`uint8*)q;
		w = *q++;
		pos = *q++;
		[st, q] = decodetname(q);
		return [mkctype_bitfield(st, w, pos), q];
	case cqct`Tundef:
		[st, q] = decodetname(q);
		return [mkctype_undef(st), q];
	default:
		error("decodetname: unhandled case %d", k);
	}
}

@define decodetdef(ns, q)
{
	@local k, cb, rep, sz, n, i, v, id, sid, c, off, mk, st, pt;
	@local w, pos;

	q = (`uint8*)q;
	k = *q++;
	switch(k){
	case cqct`Tbase:
		cb = *q++;
		rep = *q++;
		return [mkctype_base(cb, rep), q];
	case cqct`Tstruct:
	case cqct`Tunion:
		if(k == cqct`Tstruct)
			mk = mkctype_struct;
		else
			mk = mkctype_union;
		[id, q] = decodes(q);
		q = (`uint64*)q;
		sz = *q++;
		n = *q++;
		v = mkvec(n);
		for(i = 0; i < n; i++){
			q = (`uint64*)q;
			off = *q++;
			[sid, q] = decodes(q);
			[st, q] = decodetname(q);
			v[i] = mkfield(st, mkcid(sid), off);
		}
		return [mk(mkcid(id), v, sz), q];
	case cqct`Tenum:
		[id, q] = decodes(q);
		q = (`uint8*)q;
		rep = *q++;
		q = (`uint64*)q;
		n = *q++;
		st = nsreptype(ns, rep);
		if(st == nil)
			error("no base type for rep %d", rep);
		v = mkvec(n);
		for(i = 0; i < n; i++){
			[sid, q] = decodes(q);
			q = (`uint64*)q;
			c = *q++;
			v[i] = vector(mkcid(sid), {st}c);
		}
		return [mkctype_enum(mkcid(id), v, st), q];
	case cqct`Tptr:
		[st, q] = decodetname(q);
		return [mkctype_ptr(st, nsptr(ns)), q];
	case cqct`Tconst:
		[st, q] = decodetname(q);
		return [mkctype_const(st), q];
	case cqct`Tarr:
		q = (`uint64*)q;
		n = *q++;
		[st, q] = decodetname(q);
		return [mkctype_array(st, n), q];
	case cqct`Tfun:
		[st, q] = decodetname(q);
		q = (`uint64*)q;
		n = *q++;
		v = mkvec(n);
		for(i = 0; i < n; i++){
			[sid, q] = decodes(q);
			[pt, q] = decodetname(q);
			v[i] = mkparam(pt,
				       (strlen(sid) > 0 ? 
					mkcid(sid) : nil));
		}
		return [mkctype_fn(st, v), q];
	case cqct`Ttypedef:
		[id, q] = decodes(q);
		[st, q] = decodetname(q);
		return [mkctype_typedef(mkcid(id), st), q];
	case cqct`Tbitfield:
		q = (`uint64*)q;
		w = *q++;
		pos = *q++;
		[st, q] = decodetname(q);
		return [mkctype_bitfield(st, w, pos), q];
	default:
		error("decodetdef: unhandled case %d", k);
	}
}
