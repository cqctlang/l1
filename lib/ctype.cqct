@define typenamecmp(t1, t2)
{
	@local k1, k2, b1, b2, s1, s2;
	k1 = typekind(t1);
	k2 = typekind(t2);
	if(k1 != k2){
		if(k1 < k2)
			return -1;
		else
			return 1;
	}
	switch(k1){
	case cqct`Tvoid:
		return 0;
	case cqct`Tbase:
		b1 = basebase(t1);
		b2 = basebase(t2);
		if(b1 == b2)
			return 0;
		else if(b1 < b2)
			return -1;
		else
			return 1;
		break;
	case cqct`Tstruct:
	case cqct`Tunion:
	case cqct`Tenum:
		s1 = cid2str(suetag(t1));
		s2 = cid2str(suetag(t2));
		return strcmp(s1, s2);
	case cqct`Ttypedef:
		s1 = cid2str(typedefid(t1));
		s2 = cid2str(typedefid(t2));
		return strcmp(s1, s2);
	default:
		/* arbitrary */
		return 0;
	}
}

@define encodetname(p, t)
{
	@local m;

	@defloc puts(p, s)
	{
		@local m;
		m = strlen(s);
		p = (`uint64*)p;
		*p++ = m;
		p = (char*)p;
		putbytes(p, s);
		p += m;
		return p;
	}

	@defloc loop(t)
	{
		p = (`uint8*)p;
		if(isbase(t)){
			*p++ = cqct`Tbase;
			*p++ = (`uint8)basebase(t);
			return p;
		}else if(issu(t) || isenum(t)){
			if(isstruct(t))
				*p++ = cqct`Tstruct;
			else if(isunion(t))
				*p++ = cqct`Tunion;
			else if(isenum(t))
				*p++ = cqct`Tenum;
			else
				error("bug");
			return puts(p, cid2str(suetag(t)));
		}else if(istypedef(t)){
			*p++ = cqct`Ttypedef;
			return puts(p, cid2str(typedefid(t)));
		}else if(isptr(t)){
			*p++ = cqct`Tptr;
			return loop(subtype(t));
		}else if(isarray(t)){
			*p++ = cqct`Tarr;
			p = (`uint64*)p;
			m = arraynelm(t);
			if(m == nil)
				*p++ = 0; /* FIXME: maybe want escape */
			else
				*p++ = m;
			return loop(subtype(t));
		}else if(isfunc(t)){
			*p++ = cqct`Tfun;
			p = loop(rettype(t));
			p = (`uint64*)p;
			*p++ = length(params(t));
			p = (`uint8*)p;
			foreach(@lambda(par){
					p = puts(p, cid2str(paramid(par)));
					p = loop(paramtype(par));
				}, params(t));
			return p;
		}else if(isundef(t)){
			*p++ = cqct`Tundef;
			return p;
		}else if(isbitfield(t)){
			*p++ = cqct`Tbitfield;
			p = (`uint8*)p;
			*p++ = bitfieldwidth(t);
			*p++ = bitfieldpos(t);
			p = loop(subtype(t));
			return p;
		}else
			error("unhandled type name %t", t);
	}

	return loop(t);
}

@define encodetdef(p, t)
{
	@defloc puts(p, s)
	{
		@local m;
		m = strlen(s);
		p = (`uint64*)p;
		*p++ = m;
		p = (char*)p;
		putbytes(p, s);
		p += m;
		return p;
	}

	p = (`uint8*)p;
	if(isbase(t)){
		*p++ = cqct`Tbase;
		*p++ = (`uint8)basebase(t);
		*p++ = (`uint8)baserep(t);
		return p;
	}else if(issu(t)){
		if(isstruct(t))
			*p++ = cqct`Tstruct;
		else if(isunion(t))
			*p++ = cqct`Tunion;
		p = puts(p, cid2str(suetag(t)));
		p = (`uint64*)p;
		*p++ = susize(t);
		*p++ = length(fields(t));
		foreach(@lambda(f){
				p = (`uint64*)p;
				*p++ = fieldoff(f);
				p = puts(cid2str(fieldid(f)));
				p = encodetname(fieldtype(f));
			}, fields(t));
		return p;
	}else if(isenum(t)){
		*p++ = cqct`Tenum;
		p = puts(p, cid2str(suetag(t)));
		p = (`uint8*)p;
		*p++ = baserep(subtype(t));
		p = (`uint64*)p;
		*p++ = length(enumconsts(t));
		foreach(@lambda(ec){
				p = puts(cid2str(ec[0]));
				p = (`uint64*)p;
				*p++ = ec[1];
			}, enumconsts(t));
		return p;
	}else if(istypedef(t)){
		*p++ = cqct`Ttypedef;
		p = puts(p, cid2str(typedefid(t)));
		p = encodetname(subtype(t));
		return p;
	}else
		error("unhandled type name %t", t);
}

@define decodetname(q)
{
	@local k, cb, id, gets, w, pos;

	@define gets()
	{
		@local sz, s;
		q = (`uint64*)q;
		sz = *q++;
		s = getbytes(q, sz);
		q = (`uint8*)((char*)q+sz);
		return s;
	}

	q = (`uint8*)q;
	k = *q++;
	switch(k){
	case cqct`Tbase:
		cb = *q++;
		return [mkctype_base(cb), q];
	case cqct`Tstruct:
		id = mkcid(gets());
		return [mkctype_struct(id), q];
	case cqct`Tunion:
		id = mkcid(gets());
		return [mkctype_union(id), q];
	case cqct`Tenum:
		id = mkcid(gets());
		return [mkctype_enum(id), q];
	case cqct`Ttypedef:
		id = mkcid(gets());
		return [mkctype_typedef(id), q];
	case cqct`Tptr:
		[st, q] = decodetname(q);
		return [mkctype_ptr(st), q];
	case cqct`Tconst:
		[st, q] = decodetname(q);
		return [mkctype_const(st), q];
	case cqct`Tarr:
		q = (`uint64*)q;
		n = *q++;
		[st, q] = decodetname(q);
		return [mkctype_array(st, n), q];
	case cqct`Tfun:
		[st, q] = decodetname(q);
		q = (`uint64*)q;
		n = *q++;
		v = mkvec(n);
		for(i = 0; i < n; i++){
			sid = gets();
			[pt, q] = decodetname(q);
			v[i] = mkparam(pt, strlen(sid) > 0 ? mkcid(sid) : nil);
		}
		return [mkctype_fn(st, v), q];
	case cqct`Tbitfield:
		q = (`uint8*)q;
		w = *q++;
		pos = *q++;
		[st, q] = decodetname(q);
		return [mkctype_bitfield(st, w, pos), q];
	default:
		error("decodetname: unhandled case %d", k);
	}
}

@define decodetdef(ns, q)
{
	@local k, cb, rep, sz, n, i, v, id, sid, c, off, mk, st, pt;
	@local w, pos;
	@local gets;

	@define gets()
	{
		@local sz, s;
		q = (`uint64*)q;
		sz = *q++;
		s = getbytes(q, sz);
		q = (`uint8*)((char*)q+sz);
		return s;
	}

	q = (`uint8*)q;
	k = *q++;
	switch(k){
	case cqct`Tbase:
		cb = *q++;
		rep = *q++;
		return [mkctype_base(cb, rep), q];
	case cqct`Tstruct:
	case cqct`Tunion:
		if(k == cqct`Tstruct)
			mk = mkctype_struct;
		else
			mk = mkctype_union;
		id = mkcid(gets());
		q = (`uint64*)q;
		sz = *q++;
		n = *q++;
		v = mkvec(n);
		for(i = 0; i < n; i++){
			q = (`uint64*)q;
			off = *q++;
			sid = mkcid(gets());
			[st, q] = decodetname(q);
			v[i] = mkfield(st, sid, off);
		}
		return [mk(id, v, sz), q];
	case cqct`Tenum:
		id = mkcid(gets());
		q = (`uint8*)q;
		rep = *q++;
		q = (`uint64*)q;
		n = *q++;
		st = nsreptype(ns, rep);
		if(st == nil)
			error("no base type for rep %d", rep);
		v = mkvec(n);
		for(i = 0; i < n; i++){
			sid = mkcid(gets());
			q = (`uint64*)q;
			c = *q++;
			v[i] = vector(sid, {st}c);
		}
		return [mkctype_enum(id, v, st), q];
	case cqct`Tptr:
		[st,tq] = decodetname(q);
		q = tq;
		return [mkctype_ptr(st, nsptr(ns)), q];
	case cqct`Tconst:
		[st,tq] = decodetname(q);
		q = tq;
		return [mkctype_const(st), q];
	case cqct`Tarr:
		q = (`uint64*)q;
		n = *q++;
		[st,tq] = decodetname(q);
		q = tq;
		return [mkctype_array(st, n), q];
	case cqct`Tfun:
		[st,tq] = decodetname(q);
		q = tq;
		q = (`uint64*)q;
		n = *q++;
		v = mkvec(n);
		for(i = 0; i < n; i++){
			sid = gets();
			[pt,tq] = decodetname(q);
			q = tq;
			v[i] = mkparam(pt,
				       (strlen(sid) > 0 ? 
					mkcid(sid) : nil));
		}
		return [mkctype_fn(st, v), q];
	case cqct`Ttypedef:
		id = mkcid(gets());
		[st,tq] = decodetname(q);
		q = tq;
		return [mkctype_typedef(id, st), q];
	case cqct`Tbitfield:
		q = (`uint64*)q;
		w = *q++;
		pos = *q++;
		[st,tq] = decodetname(q);
		q = tq;
		return [mkctype_bitfield(st, w, pos), q];
	default:
		error("decodetdef: unhandled case %d", k);
	}
}
