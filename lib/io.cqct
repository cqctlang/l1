@global
	fdopen,
	ioctl,
	mapfile,      
	open,
	close,
	popen,
	recvfd,
	socket,
	sockpair,
	stdin,
	stdout,
	stderr,
	tcpaccept,
	tcplisten,
	tcpopen,
	unixopen
;	

{
@local ions;

ions = @names c32le {
	enum Fflag {
		/* FFlag in syscqct.h */
		Fread = 4,
		Fwrite = 8,
	};
};

@defloc mksysfdfinal(arg ...)
{
	@local rv;
	rv = apply(mksysfd, arg);
	finalize(rv, close);
	return rv;
}

@defloc mode2flags(mode)
{
	@local flags;
	flags = 0;
	if(strstr(mode, "r") != nil)
		flags |= ions`Fread;
	if(strstr(mode, "w") != nil)
		flags |= ions`Fwrite;
	if(strstr(mode, "a") != nil)
		flags |= ions`Fwrite;
	return flags;
}

@define open(file, mode)
{
	@local fd;
	fd = _open(file, mode);
	if(fd == nil)
		return nil;
	return mksysfdfinal(fd, mode2flags(mode), file);
}

@define fdopen(fd, mode)
{
	mksysfdfinal(fd, mode2flags(mode), sprintfa("fd%d", fd));
}

@define popen(arg ...)
{
	@local fds;

	fds = apply(_popen, arg);
	return map(@lambda(fd){
			/* FIXME: don't be overly permissive */
			mksysfdfinal(fd, ions`Fread|ions`Fwrite);
		}, fds);
}

@define sockpair()
{
	@local fds;
	fds = _sockpair();
	return map(@lambda(fd){
			mksysfdfinal(fd, ions`Fread|ions`Fwrite);
		}, fds);
}

@define socket(d, t, p)
{
	@local fd;
	fd = _socket(d, t, p);
	if(fd == nil)
		return nil;
	return mksysfdfinal(fd, ions`Fread|ions`Fwrite);
}

@define tcpopen(addr)
{
	@local fd;
	fd = _tcpopen(addr);
	if(fd == nil)
		return nil;
	return mksysfdfinal(fd, ions`Fread|ions`Fwrite);
}

@define unixopen(path)
{
	@local fd;
	fd = _unixopen(path);
	if(fd == nil)
		return nil;
	return mksysfdfinal(fd, ions`Fread|ions`Fwrite);
}

@define recvfd(fd)
{
	@local rfd;
	rfd = _recvfd(fd);
	if(rfd == nil)
		return nil;
	return mksysfdfinal(rfd, ions`Fread|ions`Fwrite);
}

@define tcplisten(addr)
{
	@local fd;
	fd = _tcplisten(addr);
	if(fd == nil)
		return nil;
	return mksysfdfinal(fd, 0);
}

@define tcpaccept(lfd)
{
	@local fd;
	fd = _tcpaccept(lfd);
	if(fd == nil)
		return nil;
	return mksysfdfinal(fd, ions`Fread|ions`Fwrite);
}

@define mapfile(arg ...)
{
	@local addr, len, rv;
	[addr, len] = apply(_mapfile, arg);
	if(len){
		rv = mkstrm(addr, len);
		finalize(rv, @lambda(x){ _munmap(addr, len); });
	}else
		rv = "";
	return rv;
}

@define ioctl(fd,req,buf)
{
	@local rv;

	if(!isfd(fd))
		error("ioctl: argument 0 must be a fd");
	if(!issysfd(fd))
		error("ioctl: file descriptor does not support ioctl");
	if(isclosed(fd))
		error("ioctl: attempt to ioctl on closed file descriptor");

	rv=_ioctl(sysfdno(fd),req,buf);
	// this is how fnio.c ioctl() behaved
	if(rv == -1) {
		return -errno()[0];
	} else {
		return rv;
	}
}

@define close(fd,req,buf)
{
	_close(fd,req,buf);
}


stdin = mksysfdfinal(0, ions`Fread, "(stdin)");
stdout = mksysfdfinal(1, ions`Fwrite, "(stdout)");
stderr = mksysfdfinal(2, ions`Fwrite, "(stderr)");

}
