/* chronicle assisted analyses of L1 memory management */

@global
	checkfreelist,
	valfuture,
	vallifetime,
	valpast
;

{

@defloc findcopyto(db, addr, gc)
{
	@local dom, ws, xs, args, t;

	dom = db.exedom;

	ws = db.scan('lastwrite, addr, sizeof(*addr), gc.beg, gc.end);
	if(length(ws) == 0)
		return [nil, nil];

	// we should be in an active call to 'copy'.
	// it would be nice to verify this with an o'callahan stack walk,
	// from which we could directly read the 'from' pointer,
	// but that would be expensive.
	// just go back to the last call to 'copy'.

	xs = db.scan('lastexec, &dom`copy, gc.beg, ws[0]);
	if(length(xs) != 1)
		return ['confusion, nil];
	t = xs[0];
	args = chgetargs(db, 1, t);  /* FIXME: want calls-like interface */
	return [t, {@typeof(addr)}args[0]];
}

@defloc findcopyfrom(db, addr, gc)
{
	@local ws, t, ldom, rt, dom;

	// look forward a forward pointer write

	dom = db.exedom;
	rt = db.scan('firstexec, &dom`recycle, gc.beg, gc.end);
	if(length(rt) != 1){
		printf("confusion!\n");
		return ['confusion, nil];
	}
	ws = db.scan('firstwrite, addr, sizeof(*addr), gc.beg, rt[0]);
	if(length(ws) == 0)
		return [nil, nil];
	t = ws[0];
	ldom = db.ldom(t);
	return [t, {@typeof(addr)}ldom`nh];
}

@define valpast(db, addr, t)
{
	@local ct, gcs, dom, bgcs, gc, past, ws;

	dom = db.exedom;

	ct = @typeof(addr);
	addr = (dom`Head*)addr;
	gcs = callintervals(db, db.interval(), &dom`_gc);

	past = [];

	// search backward for chain of calls to copy.

	[bgcs, _] = zsplit(gcs, t);
	bgcs = reverse(bgcs);
	while(gc = pop(bgcs)){
		@local copyt, from;
		[copyt, from] = findcopyto(db, addr, gc);
		if(copyt == nil)
			continue;
		if(copyt == 'confusion)
			return nil;
		push(past, instant(copyt, {ct}{db.dom(t)}addr));
		t = copyt;
		addr = from;
	}

	// search backward for last write to header, which we
	// presume allocation

	ws = db.scan('lastwrite, addr, sizeof(*addr), 0, t);
	if(length(ws) == 0)
		return nil;
	t = ws[0];

	push(past, instant(t, {ct}{db.dom(t)}addr));

	return past;
}

@define valfuture(db, addr, t)
{
	@local ct, gcs, dom, agcs, gc, future, e;

	dom = db.exedom;

	ct = @typeof(addr);
	addr = (dom`Head*)addr;
	gcs = callintervals(db, db.interval(), &dom`_gc);
	
	future = [];

	// search forward for chain of calls to copy.

	[_, agcs] = zsplit(gcs, t);
	while(gc = pop(agcs)){
		@local copyt, to;
		[copyt, to] = findcopyfrom(db, addr, gc);
		if(copyt == nil)
			continue;
		if(copyt == 'confusion)
			return nil;
		append(future, instant(copyt, {ct}{db.dom(t)}to));
		t = copyt;
		addr = to;
	}

	// search forward for freeseg of Seg containing addr

	[_, agcs] = zsplit(gcs, t);
	while(gc = pop(agcs)){
		@local xs, it;
		xs = calls(db, gc, &dom`freeseg);
		while(it = pop(xs)){
			@local s, a;
			s = it.val[0]; // Seg*
			a = s2a(s);
			if(a <= addr && a+Segsize < addr){
				append(future, instant(it.t, {ct}{db.dom(t)}addr));
				return future;
			}
		}
	}
	
	// execution ended before freeseg

	e = db.interval().end-1;
	append(future, instant(e, {db.dom(e)}addr));

	return future;
}

@define vallifetime(db, addr, t)
{
	@local past, future;
	past = valpast(db, addr, t);
	if(past == nil)
		return nil;
	future = valfuture(db, addr, t);
	if(future == nil)
		return nil;
	return it2ivseq(concat(past, future));
}

@define checkfreelist(db)
{
	@local dom, exclude, init, fini, stable;
	@local fst, aut, nfs;

	@defloc freesegs(iv)
	{
		@local f, rvs;
		rvs = [];
		dom = db.dom(iv.beg);
		f = dom`segmap.free;
		while(f){
			append(rvs, interval(iv.beg, iv.end, [f, Segsize]));
			f = *(void**)f;
		}
//		printf("scanning %d segments in %a\n", length(rvs), iv);
		return rvs;
	}

	dom = db.exedom;
	exclude = [
		&dom`nextfree,
		&dom`freeseg,
		&dom`freerange,
		&dom`resetmem,
	];

	init = firstreturn(db, db.interval(), &dom`initmem);
	fini = lastcall(db, db.interval(), &dom`finimem);
	stable = interval(init.t, fini.t, nil);
	stable = zdiff(stable, anycalls(db, stable, exclude));

	@defloc dofork(db, fn)
	{
		@local pid;
		db.rebind();
		switch(pid = fork()){
		case -1:
			error("fork failed");
		case 0:
			switch(fork()){
			case -1:
				error("fork failed");
			default:
				exit(0);
			case 0:
//				printf("forked\n");
				fn();
				exit(0);
			}
		default:
			waitpid(pid, 0);
			return;
		}
	}

	fst = [];
	aut = [];
	nfs = [];
	@defloc work(iv)
	{
		@local s, b, e;

		b = gettimeofday();
		s = freesegs(iv);
		e = gettimeofday();
		append(fst, e-b);

		append(nfs, length(s));

		b = gettimeofday();
		foreach(assertunaccessed, s);
		e = gettimeofday();
		append(aut, e-b);
	}

	@defloc tot(ts, name, unit)
	{
		@local x;
		x = 0;
		foreach(@lambda(t){ x += t; }, ts);
		printf("%s: %u ops %u %s/op\n", name, length(ts), x/length(ts), unit);
	}

//	time(@lambda() { foreach(@lambda(iv){ dofork(db, @lambda(){ foreach(assertunaccessed, freesegs(iv)); }); }, stable); });
//	time(@lambda() { foreach(@lambda(iv){ foreach(assertunaccessed, freesegs(iv)); }, stable); });
	time(@lambda() { foreach(@lambda(iv){ work(iv); }, stable); });
	tot(fst, "freesegs", "usec");
	tot(aut, "assertunaccessed", "usec");
	tot(nfs, "# freesegs", "freesegs");
}

}
