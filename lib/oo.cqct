/*
Object helper macro.

Example usage:

@object(Name) {
    @local a,b; //private vars
    @local super; //super class

    [a,b] = args; //args is the list of arguments passed to the constructor

    //can reference arbitrary other objects
    super = OtherObject();

    //at this point, for all X for which super.X is defined, this.X will be
    //given that value. (any this.X that had been set previously will be over
    //written)
    @inherit(super);
    //alternatively (no direct references to super)
    //@inherit(OtherObject())

    this.public = a+1; //this refers to this object

    //this.ftn1(); //would give an error b/c ftn1 has not yet been defined

    //defines this.ftn1() (was undefined to this point)
    @define ftn1() {
        printf("ran ftn1: %d\n",this.public);
    }

    //this.ftn1(); //now works.

    //multiple @inherit can be specified. 
    //Note that if Super2 defines a method named "public" or ftn1, then the
    //above assignment would be overwritten by this statement (if the local
    //assignment came after the @inherit, then it wouldn't be overwritten)
    @inherit(Super2(a,a)); 

    //defines this.ftn2(param)
    @define ftn2(param) {
        this.public = param;
        ftn1(); 
        this.ftn1(); //equivalent to above call
    }

    //not allowed to use 'return'
}

name = Name(1,2);
name.ftn1(); //runs ftn1 defined above
name.ftn2(); //runs ftn2 defined above
name.public; //equivalent to "this.public" above

Creates a function Name(args...) that returns a table
with keys ftn1 and ftn2 set to the given @define's

Inside the @object body, one is provided with the following:

 [this]   refers to the current object (which will be returned)
 [args]   refers to parameters to the Creation object

The returned table will always have the key 'type defined
to be the name of the kind of object. 
*/

@defstx @object(name) body {
    @local new_locals, new_body, old_body;

    @defloc body_stmts_locals(b) {
        switch(b) {
        @match #scope(bl):
            return body_stmts_locals(bl);
        @match #block(l,c):
            return [l,c];
        default:
            error("b must be a #scope or a #block stx");
        }
        error("shouldn't get here.");
    }


    [new_locals,old_body] = body_stmts_locals(body);
    new_body = #[];

    new_locals = Zcons(#id('this),new_locals);

    new_body = map(@lambda(e) {

        switch(stxkind(e)) {
        case 'define:

            new_locals = Zcons(stxref(e,0),new_locals);
            //add this.ftn_id = ftn_id;
            //after the @define
            return Zcons( e,
                          Zcons( #g( #dot( #id('this), 
                                      stxref(e,0) ), 
                                  stxref(e,0) ), 
                                 #[]));
        case 'mcall:

            if (stxid(stxref(e,0)) == 'inherit) {
                @local theid;
                theid = stxref(stxref(e,1),0);
                return #`{
                    {
                        @local super;
                        super = #,(theid);
                        if (!istable(super)) {
                            error("%a is not a table",super);
                        }
                        foreach(@lambda(x) {
                            this[x] = super[x];
                        }, tabkeys(super));
                    }
                };
            } else return e;

        default:
            return e;
        }

    }, old_body);

    //__name = stxid(name)
    new_body = Zcons( #g( #dot(#id('this),#id('type)) , 
                          #val( stxid(name) )), 
                      new_body);
    new_body = Zappend( #'{ 
        this = mktab(@lambda() 
                { 
                    error("reference to undefined member of %s", 
                            this.type); 
                });
    }, new_body);

    new_body = Zappend( new_body, #'{ return this; } );

    return #define( name, #[ #id('args), #ellipsis() ], 
                    #scope(#block(new_locals,new_body)) );
}
