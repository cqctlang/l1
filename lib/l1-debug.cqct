@global Segsize;

Segsize = 1ULL<<20;

@define vkind(p)
{
	p = (Head*)p;
	(p->bits>>1)&0x1f;
}

@define fmtval(p)
{
	@local k;
	k = vkind(p);
	switch(k){
	case 0:
		return "<undef>";
	case 1:
		return "nil";
	case 3:
		return sprintfa("box(%s)", fmtval(((Box*)p)->v));
	case 4:
		return "<procedure>";
	case 6:
		return "<code>";
	case 9:
		return "<domain>";
	case 19:
		return "<string>";
	case 20:
		return "<table>";
	case 8:
		p = (Cval*)p;
		return sprintfa("%d", p->v.u);
	case 15:
		return sprintfa("cons(%s, %s)", fmtval(xcar(p)), fmtval(xcdr(p)));
	default:
		return sprintfa("<qkind %d>", k);
	}
}

@define xcar(p)
{
	p = (Pair*)p;
	return p->car;
}

@define xcdr(p)
{
	p = (Pair*)p;
	return p->cdr;
}

@define mtname(mt)
{
	@local mts, rv;
	mts = [ 0   : "MThole",
		8   : "MTnix",
		16  : "MTfree",
		48  : "MTdata",
		56  : "MTode",
		64  : "MTcode",
		24  : "MTweak",
		32  : "MTbox",
		40  : "MTmutable",
		50  : "MTbigdata",
		58  : "MTbigode",
		66  : "MTbigcode" ];
	rv = mts[mt];
	if(rv == nil)
		return sprintfa("undefined mt %d", mt);
	return rv;
}

@define genname(g)
{
	@local gs;
	gs = ["G0", "G1", "G2", "G3", "Gstatic", "Gunused", "Glock"];
	if(g >= length(gs))
		return sprintfa("undefined gen %d", g);
	return gs[g];
}

@define _fmtseg(s)
{
	@local r, a;
	a = s2a(s);
	r = sprintfa("seg %p (%p-%p) %s %s", s,
		     a, a+Segsize,
		     genname(s->gen), mtname(s->mt));
	return r;
}

@define s2a(s)
{
	@local dom, o, a, segmap;
	dom = domof(s);
	segmap = &dom`segmap;
	o = s-segmap->map;
	a = segmap->lo+o*Segsize;
	return a;
}

@define a2s(a)
{
	@local dom, segmap, o;

	dom = domof(a);
	segmap = &dom`segmap;
	o = ((void*)a-segmap->lo)/Segsize;
	return segmap->map+o;
}

@define fmtseg(p)
{
	@local dom, segmap, o, s;

	dom = domof(p);
	segmap = &dom`segmap;
	o = ((void*)p-segmap->lo)/Segsize;
	s = segmap->map+o;
	return _fmtseg(s);
}

@define headbits(o)  { ((Head*)o)->bits; }
@define Vfwd(o)      { (headbits(o)>>0)&1; }
@define Vfwdaddr(o)  { headbits(o)&~1ULL; }
@define Vkind(o)     { headbits(o)>>1&0x1f; }
@define codekind(c)  { return c->kind; }
@define _codeinsn(c) { (void*)(c+1); }
@define codeinsn(c)
{
	if(codekind(c) == 0) /* Cvm */
		return _codeinsn(c)+64; /* FIXME: trampsize */
	else
		return _codeinsn(c);
}
@define codeend(c)  { (void*)c + c->sz; }

@define codeid(c)   { ciddata(c->id); }

@define pcinrange(pc, c)
{
	@local b, e;
	b = codeinsn(c);
	e = codeend(c);
//	printf(" b = %p\n", b);
//	printf("pc = %p\n", pc);
//	printf(" e = %p\n", e);
	return pc >= b && pc < e;
}

@define strdata(s)
{
	switch(s->skind){
	case 1: /* Sheap */
		return (char*)(s+1);
	case 0: /* Sperm */
		s = (Strperm*)s;
		return s->s;
	case 2: /* Smalloc */
		s = (Strmalloc*)s;
		return s->s;
	case 3: /* Smmap */
		s = (Strmmap*)s;
		return s->s;
	default:
		error("unrecognized string kind (%d)", s->kind);
	}
}

/* v must be Vec* */
@define vecdata(v)
{
	return (Val*)(v+1);
}

@define lookdbg(c, off)
{
	@local d, e, n;
	d = (Dbg*)strdata(c->dbg);
	e = d+c->ndbg;
	if(d->off > off)
		error("cannot find pc offset (%x) in code debug info", off);
	while(d < e-1){
		n = d+1;
		if(n->off > off)
			return d;
		d = n;
	}
	return d;
}

@define ra2size(ra, cp)
{
	@local off, d;
	switch(codekind(cp)){
	case 0: /* Cvm */
		if(!pcinrange(ra, cp))
			error("pc (%p) lies outside text (%p - %p)",
			      ra, codeinsn(cp), codeend(cp));
		off = (void*)ra-codeinsn(cp);
		d = lookdbg(cp, off);
		return d->fsz;
		break;
	case 1: /* Ccfn */
	case 2: /* Cccl */
		return (u64)ra;
		break;
	case 3: /* Cxfn */
		error("unimplemented for Cxfn");
	default:
		error("unrecognized code kind (%d)", cp->kind);
	}
}

@define ciddata(cid)
{
	return (char*)(cid+1);
}

@define printframe(fp, ra, cp)
{
	printf("\t%p\t%p\t%20s\n", fp, ra, ciddata(cp->id));
}
