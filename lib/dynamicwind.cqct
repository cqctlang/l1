@global dynamicwind, $dynamicwind, syscallcc, applyk, evalk;

{
	@local winders;

	winders = nil;
	syscallcc = callcc;

	@defloc listtail(l, n)
	{
		if(n == 0)
			return l;
		return listtail(cdr(l), n-1);
	}

	@defloc commontail(x, y)
	{
		@local lx, ly;

		lx = length(x);
		ly = length(y);

		@defloc loop(x, y)
		{
			x = (lx > ly) ? listtail(x, lx-ly) : x;
			y = (ly > lx) ? listtail(y, ly-lx) : y;
			if(eq(x, y))
				return x;
			else
				return loop(cdr(x), cdr(y));
		}
		return loop(x, y);
	}

	@defloc dowind(new)
	{
		@local tail;

		@defloc lout(ls)
		{
			if(!eq(ls, tail)){
				winders = cdr(ls);
				cdr(car(ls))();
				lout(cdr(ls));
			}
		}

		@defloc lin(ls)
		{
			if(!eq(ls, tail)){
				lin(cdr(ls));
				car(car(ls))();
				winders = ls;
			}
		}

		tail = commontail(new, winders);
		lout(winders);
		lin(new);
	}

	@define callcc(f)
	{
		syscallcc(@lambda(k){
				@local save, r;
				save = winders;
				r = mkcontinuation(continuationfr(k),
						   @lambda(val){
							   if(!eq(save, winders))
								   dowind(save);
							   continuationfn(k)(val);
						   });
				f(r);
			});
	}

	@define $dynamicwind(in, body, out)
	{
		@local rv;
		in();
		winders = cons(cons(in, out), winders);
		rv = body();
		winders = cdr(winders);
		out();
		return rv;
	}

	dynamicwind = $dynamicwind;

	@define applyk(fn, succ, fail, arg ...)
	{
		@local olderr, done;

		@defloc err(msg)
		{
			callcc(@lambda(k){
					printf("error: %s\n", msg);
					kbacktrace(continuationfr(k));
					done(fail());
				});
		}

		@defloc $doit()
		{
			succ(apply(apply, fn, arg));
		}

		callcc(@lambda(k){
				done = k;
				dynamicwind(
					@lambda(){
						olderr = defaulterror;
						defaulterror = err;
					},
					$doit,
					@lambda(){
						defaulterror = olderr;
					});
			});
	}

	@define evalk(s, succ, fail)
	{
		applyk(@lambda(arg ...) { eval(s); }, succ, fail, []);
	}
}
