@include <fdas.l1>

protns = @names c32le {
	enum Mkind {
		Rerror = 0,
		Tlaunch,
		Rlaunch,
		Tcont,
		Rcont,

		Tstop,
		Rstop,
		Tkill,
		Rkill,
		Tsetbrk,

		Rsetbrk,
		Tclrbrk,
		Rclrbrk,
		Tread,
		Rread,

		Abrk,
		Aobit,
		Aack,
		Tcleave,
		Rcleave,

		Twrite,
		Rwrite,
		Tsetregs,
		Rsetregs,
		Tsetsnap,

		Rsetsnap,
		Asnap,
		Tattach,
		Rattach,
		Ttest,

		Rtest,
		Tstep,
		Rstep,
	};

	enum State {
		Running,
		Stopped,
		Dead,
	};

	typedef
	struct Reg {
		@0	uint64 eflags;
		@8	uint64 rbx;
		@16	uint64 rcx;
		@24	uint64 rdx;
		@32	uint64 rsi;
		@40	uint64 rdi;
		@48	uint64 rbp;
		@56	uint64 rax;
		@64	uint64 rip;
		@72	uint64 rsp;
		@80	uint64 r8;
		@88	uint64 r9;
		@96	uint64 r10;
		@104	uint64 r11;
		@112	uint64 r12;
		@120	uint64 r13;
		@128	uint64 r14;
		@136	uint64 r15;
		@144;
	} Reg;

	struct Rerror{
		@0	uint8 op;
		@1	uint64 id;
		@9	char err[0];
		@9	char bytes[0];
		@9;
	};
	typedef struct Rerror Rerror;
	typedef struct Rerror Rread;

	struct Tlaunch{
		@0	uint8 op;
		@1	uint64 narg;
		@9;
	};
	typedef struct Tlaunch Tlaunch;

	struct Rlaunch{
		@0	uint8 op;
		@1	uint64 id;
		@9	Reg reg;
		@153;
	};
	typedef struct Rlaunch Rlaunch;
	typedef struct Rlaunch Rstop;
	typedef struct Rlaunch Tsetregs;

	struct Rcont{
		@0	uint8 op;
		@1	uint64 id;
		@1	uint64 cnt;
		@9;
	};
	typedef struct Rcont Tcont;
	typedef struct Rcont Tstop;
	typedef struct Rcont Rcont;
	typedef struct Rcont Rwrite;
	typedef struct Rcont Rattach;
	typedef struct Rcont Rclrbrk;
	typedef struct Rcont Rkill;
	typedef struct Rcont Rsetregs;
	typedef struct Rcont Aobit;
	typedef struct Rcont Aack;
	typedef struct Rcont Rtest;
	typedef struct Rcont Tstep;
	typedef struct Rcont Rstep;

	struct Tsetbrk{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@9	uint64 addr;
		@9	uint64 cid;
		@17;
	};
	typedef struct Tsetbrk Tsetbrk;
	typedef struct Tsetbrk Tclrbrk;
	typedef struct Tsetbrk Rsetbrk;
	typedef struct Tsetbrk Rsetsnap;
	typedef struct Tsetbrk Rcleave;

	struct Abrk{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@17	Reg reg;
		@161;
	};
	typedef struct Abrk Abrk;

	struct Asnap{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@9	uint64 addr;
		@17	uint64 cid;
		@17	uint64 cnt;
		@25	char bytes[0];
		@25;
	};
	typedef struct Asnap Asnap;
	typedef struct Asnap Tread;
	typedef struct Asnap Twrite;
};

define mkpras arg {
	@local addr, fd, cmd, as, protdom, l;
	@local indom, outdom, ip, op, p;
	@local read1, ipress, opress, xwr, copydata, checkreply;
	@local launch, cont, brk, ack, xread, xwrite, setbrk, clrbrk, sync;
	@local dispatch, get, put;
	@local id, state, reg;
	@local brktab, dtab;
	@local logsend, logrecv, log, verbose;

	verbose = 0;

	define logsend(s){
		if(verbose)
			printf("<-- %s\n", s);
	}

	define logrecv(s){
		if(verbose)
			printf("--> %s\n", s);
	}

	define log(s){
		if(verbose)
			printf("%s\n", s);
	}

	/* read n-1th byte ahead in input stream,
	   thereby extending window to include it and preceding bytes. */
	define ifetch(n){
		@local p;
		p = (char*)ip;
		p += n-1;
		p = *p;
	}

	define ipress(t){
		ip = {t}ip;
		return ip++;
	}

	define opress(t){
		op = {t}op;
		return op++;
	}

	define copydata(p){
		@local dom;
		dom = mkdom(nsof(p), mksas(getbytes(p)));
		return {typeof(p)}{dom}0;
	}

	define xwr(v){
		if(iscvalue(v)){
			op = {mkctype_ptr(typeof(v),nsptr(domof(v)))}op;
			*op++ = v;
		}else if(isstring(v)){
			op = (char*)op;
			putbytes(op, v);
			op += strlen(v);
		}else
			error("bad argument to xwr: %a", v);
	}

	define xrds(cnt){
		@local s;
		ip = (char*)ip;
		s = getbytes(ip, cnt);
		ip += cnt;
		return s;
	}

	define read1() {
		@local sz;

		if(indom.iseof())
			return nil;

		sz = *ipress(#indom`uint64*#);
		ifetch(sz);
		ip = (`uint8*)ip;
		switch((enum Mkind)*ip){
		case indom`Rerror:
			return ipress(#indom`Rerror*#);
		case indom`Rlaunch:
			return ipress(#indom`Rlaunch*#);
		case indom`Rcont:
			return ipress(#indom`Rcont*#);
		case indom`Rstep:
			return ipress(#indom`Rstep*#);
		case indom`Aobit:
			return ipress(#indom`Aobit*#);
		case indom`Rstop:
			return ipress(#indom`Rstop*#);
		case indom`Rsetbrk:
			return ipress(#indom`Rsetbrk*#);
		case indom`Rclrbrk:
			return ipress(#indom`Rclrbrk*#);
		case indom`Rread:
			return ipress(#indom`Rread*#);
		case indom`Abrk:
			return ipress(#indom`Abrk*#);
		case indom`Rwrite:
			return ipress(#indom`Rwrite*#);
		case indom`Rsetregs:
			return ipress(#indom`Rsetregs*#);
		case indom`Rcleave:
		case indom`Rsetsnap:
		case indom`Asnap:
		case indom`Rattach:
		case indom`Rtest:
		case indom`Rkill:
		default:
			error("received unhandled message: %e", *ip);
		}
	}

	define checkreply(op, reply){
		if(reply == nil)
			error("unexpected end of file from prctl");
		if(reply->op == indom`Rerror)
			error("pras: while waiting for %e: %s",
			      op, reply->bytes);
		if(reply->op != op)
			error("pras: while waiting for %e: received %e",
			      op, (enum Mkind)reply->op);
	}

	define launch(arg){
		@local argvlen, narg, i;

		narg = length(arg);
		if(narg == 0)
			error("mkpras: launch: empty command");

		log("1");

		/* format Tlaunch message */
		argvlen = 0;
		for(i = 0; i < narg; i++)
			argvlen += strlen(listref(arg, i))+1;
		xwr((`uint64)(sizeof(outdom`Tlaunch)+argvlen));
		p = opress(#outdom`Tlaunch*#);
		p->op = outdom`Tlaunch;
		p->narg = narg;
		for(i = 0; i < narg; i++){
			log("2");
			xwr(listref(arg, i));
			xwr((`uint8)0);
		}
		log("3");
		outdom.flush();
		logsend("Tlaunch");

		/* receive Rlaunch reply */
		reply = read1();
		checkreply(indom`Rlaunch, reply);
		id = reply->id;
		reg = copydata(&reply->reg);
		indom.flush();
		logrecv("Rlaunch");

		state = indom`Stopped;
	}

	define cont(domas){
		if(state != indom`Stopped)
			return;

		xwr((`uint64)sizeof(outdom`Tcont));
		p = opress(#outdom`Tcont*#);
		p->op = outdom`Tcont;
		p->id = id;
		outdom.flush();
		logsend("Tcont");

		reply = read1();
		checkreply(indom`Rcont, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		indom.flush();
		logrecv("Rcont");

		state = indom`Running;
	}

	define step args {
		@local n;

		if(state != indom`Stopped)
			return;

		printf("step %a\n", args);

		if(length(args) == 2)
			n = listref(args, 1);
		else
			n = 1;
		if(n == 0)
			return;
		while(n-- > 0){
			xwr((`uint64)sizeof(outdom`Tstep));
			p = opress(#outdom`Tstep*#);
			p->op = outdom`Tstep;
			p->id = id;
			outdom.flush();
			logsend("Tstep");
			
			reply = read1();
			checkreply(indom`Rstep, reply);
			if(reply->id != id)
				error("pras: got %e for unknown task",
				      (enum Mkind)reply->op);
			indom.flush();
			logrecv("Rstep");
		}
	}

	define brk(domas){
		if(state != indom`Running)
			return;

		xwr((`uint64)sizeof(outdom`Tstop));
		p = opress(#outdom`Tstop*#);
		p->op = outdom`Tstop;
		p->id = id;
		outdom.flush();
		logsend("Tstop");

		reply = read1();
		checkreply(indom`Rstop, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		reg = copydata(reply->reg);
		indom.flush();
		logrecv("Rstop");

		state = indom`Stopped;
	}

	define ack(){
		xwr((`uint64)sizeof(outdom`Aack));
		p = opress(#outdom`Aack*#);
		p->op = outdom`Aack;
		p->id = id;
		outdom.flush();
		logsend("Aack");
	}

	define xread(addr, cnt){
		@local s;

		xwr((`uint64)sizeof(outdom`Tread));
		p = opress(#outdom`Tread*#);
		p->op = outdom`Tread;
		p->id = id;
		p->addr = addr;
		p->cnt = cnt;
		outdom.flush();
		logsend("Tread");

		reply = read1();
		checkreply(indom`Rread, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		s = xrds(cnt);
		indom.flush();
		logrecv("Rread");

		return s;
	}

	define xwrite(addr, cnt, bytes){
		xwr((`uint64)(sizeof(outdom`Twrite)+cnt));
		p = opress(#outdom`Twrite*#);
		p->op = outdom`Twrite;
		p->id = id;
		p->addr = addr;
		p->cnt = cnt;
		xwr(bytes);
		outdom.flush();
		logsend("Twrite");

		reply = read1();
		checkreply(indom`Rwrite, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		indom.flush();
		logrecv("Rwrite");
	}

	define setbrk(domas, addr, fn){
		@local bp;

		xwr((`uint64)sizeof(outdom`Tsetbrk));
		p = opress(#outdom`Tsetbrk*#);
		p->op = outdom`Tsetbrk;
		p->id = id;
		p->addr = addr;
		outdom.flush();
		logsend("Tsetbrk");

		reply = read1();
		checkreply(indom`Rsetbrk, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		bp = reply->bp;
		tabinsert(brktab, bp, [addr, fn]);
		indom.flush();
		logrecv("Rsetbrk");

		return bp;
	}

	define clrbrk(domas, bp){
		xwr((`uint64)sizeof(outdom`Tclrbrk));
		p = opress(#outdom`Tclrbrk*#);
		p->op = outdom`Tclrbrk;
		p->id = id;
		p->bp = bp;
		outdom.flush();
		logsend("Tclrbrk");

		reply = read1();
		checkreply(indom`Rclrbrk, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		tabdelete(brktab, bp);
		indom.flush();
		logrecv("Rclrbrk");
	}

	define setregs(){
		xwr((`uint64)sizeof(outdom`Tsetregs));
		p = opress(#outdom`Tsetregs*#);
		p->op = outdom`Tsetregs;
		p->id = id;
		putbytes(&p->reg, getbytes(reg));
		outdom.flush();
		logsend("Tsetregs");

		reply = read1();
		checkreply(indom`Rsetregs, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		indom.flush();
		logrecv("Rsetregs");
	}

	define sync(domas){
		@local bp, rv;

		reply = read1();
		switch(reply->op){
		case indom`Aobit:
			logrecv("Aobit");
			ack();
			if(reply->id != id)
				error("pras: got obituary for unknown task");
			indom.flush();
			state = indom`Dead;
			break;
		case indom`Abrk:
			logrecv("Abrk");
			ack();
			if(reply->id != id)
				error("pras: got %e for unknown task",
				      (enum Mkind)reply->op);
			reg = copydata(&reply->reg);
			state = indom`Stopped;
			bp = tablook(brktab, reply->bp);
			if(bp == nil)
				error("unregistered breakpoint: %d",
				      reply->bp);
			indom.flush();
			rv = listref(bp, 1)(listref(bp, 0));
			if(rv != 1)
				cont(domas);
			break;
		case indom`Asnap:
			logrecv("Asnap");
			error("pras: sync: unhandled message: %e",
			      (enum Mkind)reply->op);
		default:
			error("pras: sync: unexpected message: %e",
			      (enum Mkind)reply->op);
		}
	}

	define contwait(domas){
		cont(domas);
		while(state == indom`Running)
			sync(domas);
	}

	define get(domas, r){
		return xread(rangebeg(r), rangelen(r));
	}

	define put(domas, r, s){
		return xwrite(rangebeg(r), rangelen(r), s);
	}

	define map(domas){
		return vector(mkrange(0, (`uint64)-1));
	}

	define getrbx(domas){
		if(isdomain(domas))
			return {domas}reg->rbx;
		else
			return reg->rbx;
	}
	define getrcx(domas){
		if(isdomain(domas))
			return {domas}reg->rcx;
		else
			return reg->rcx;
	}
	define getrdx(domas){
		if(isdomain(domas))
			return {domas}reg->rdx;
		else
			return reg->rdx;
	}
	define getrsi(domas){
		if(isdomain(domas))
			return {domas}reg->rsi;
		else
			return reg->rsi;
	}
	define getrdi(domas){
		if(isdomain(domas))
			return {domas}reg->rdi;
		else
			return reg->rdi;
	}
	define getrbp(domas){
		if(isdomain(domas))
			return {domas}reg->rbp;
		else
			return reg->rbp;
	}
	define getrax(domas){
		if(isdomain(domas))
			return {domas}reg->rax;
		else
			return reg->rax;
	}
	define getrip(domas){
		if(isdomain(domas))
			return {domas}reg->rip;
		else
			return reg->rip;
	}
	define getrsp(domas){
		if(isdomain(domas))
			return {domas}reg->rsp;
		else
			return reg->rsp;
	}
	define getr8(domas){
		if(isdomain(domas))
			return {domas}reg->r8;
		else
			return reg->r8;
	}
	define getr9(domas){
		if(isdomain(domas))
			return {domas}reg->r9;
		else
			return reg->r9;
	}
	define getr10(domas){
		if(isdomain(domas))
			return {domas}reg->r10;
		else
			return reg->r10;
	}
	define getr11(domas){
		if(isdomain(domas))
			return {domas}reg->r11;
		else
			return reg->r11;
	}
	define getr12(domas){
		if(isdomain(domas))
			return {domas}reg->r12;
		else
			return reg->r12;
	}
	define getr13(domas){
		if(isdomain(domas))
			return {domas}reg->r13;
		else
			return reg->r13;
	}
	define getr14(domas){
		if(isdomain(domas))
			return {domas}reg->r14;
		else
			return reg->r14;
	}
	define getr15(domas){
		if(isdomain(domas))
			return {domas}reg->r15;
		else
			return reg->r15;
	}

	define geteflags(domas){
		if(isdomain(domas))
			return {domas}reg->eflags;
		else
			return reg->eflags;
	}

	define setrbx(domas, x) { reg->rbx = x; setregs(); }
	define setrcx(domas, x) { reg->rcx = x; setregs(); }
	define setrdx(domas, x) { reg->rdx = x; setregs(); }
	define setrsi(domas, x) { reg->rsi = x; setregs(); }
	define setrdi(domas, x) { reg->rdi = x; setregs(); }
	define setrbp(domas, x) { reg->rbp = x; setregs(); }
	define setrax(domas, x) { reg->rax = x; setregs(); }
	define setrip(domas, x) { reg->rip = x; setregs(); }
	define setrsp(domas, x) { reg->rsp = x; setregs(); }
	define setr8(domas, x)  { reg->r8 = x; setregs(); }
	define setr9(domas, x)  { reg->r9 = x; setregs(); }
	define setr10(domas, x) { reg->r10 = x; setregs(); }
	define setr11(domas, x) { reg->r11 = x; setregs(); }
	define setr12(domas, x) { reg->r12 = x; setregs(); }
	define setr13(domas, x) { reg->r13 = x; setregs(); }
	define setr14(domas, x) { reg->r14 = x; setregs(); }
	define setr15(domas, x) { reg->r15 = x; setregs(); }
	define seteflags(domas, x) { reg->eflags = x; setregs(); }

	dtab = mktab();
	tabinsert(dtab, "get",		get);
	tabinsert(dtab, "put",		put);
	tabinsert(dtab, "map",		map);

	tabinsert(dtab, "getebx",	getrbx);
	tabinsert(dtab, "getecx",	getrcx);
	tabinsert(dtab, "getedx",	getrdx);
	tabinsert(dtab, "getesi",	getrsi);
	tabinsert(dtab, "getedi",	getrdi);
	tabinsert(dtab, "getebp",	getrbp);
	tabinsert(dtab, "geteax",	getrax);
	tabinsert(dtab, "geteip",	getrip);
	tabinsert(dtab, "getesp",	getrsp);

	tabinsert(dtab, "setebx",	setrbx);
	tabinsert(dtab, "setecx",	setrcx);
	tabinsert(dtab, "setedx",	setrdx);
	tabinsert(dtab, "setesi",	setrsi);
	tabinsert(dtab, "setedi",	setrdi);
	tabinsert(dtab, "setebp",	setrbp);
	tabinsert(dtab, "seteax",	setrax);
	tabinsert(dtab, "seteip",	setrip);
	tabinsert(dtab, "setesp",	setrsp);

	tabinsert(dtab, "getrbx",	getrbx);
	tabinsert(dtab, "getrcx",	getrcx);
	tabinsert(dtab, "getrdx",	getrdx);
	tabinsert(dtab, "getrsi",	getrsi);
	tabinsert(dtab, "getrdi",	getrdi);
	tabinsert(dtab, "getrbp",	getrbp);
	tabinsert(dtab, "getrax",	getrax);
	tabinsert(dtab, "getrip",	getrip);
	tabinsert(dtab, "getrsp",	getrsp);
	tabinsert(dtab, "getr8",	getr8);
	tabinsert(dtab, "getr9",	getr9);
	tabinsert(dtab, "getr10",	getr10);
	tabinsert(dtab, "getr11",	getr11);
	tabinsert(dtab, "getr12",	getr12);
	tabinsert(dtab, "getr13",	getr13);
	tabinsert(dtab, "getr14",	getr14);
	tabinsert(dtab, "getr15",	getr15);

	tabinsert(dtab, "setrbx",	setrbx);
	tabinsert(dtab, "setrcx",	setrcx);
	tabinsert(dtab, "setrdx",	setrdx);
	tabinsert(dtab, "setrsi",	setrsi);
	tabinsert(dtab, "setrdi",	setrdi);
	tabinsert(dtab, "setrbp",	setrbp);
	tabinsert(dtab, "setrax",	setrax);
	tabinsert(dtab, "setrip",	setrip);
	tabinsert(dtab, "setrsp",	setrsp);
	tabinsert(dtab, "setr8",	setr8);
	tabinsert(dtab, "setr9",	setr9);
	tabinsert(dtab, "setr10",	setr10);
	tabinsert(dtab, "setr11",	setr11);
	tabinsert(dtab, "setr12",	setr12);
	tabinsert(dtab, "setr13",	setr13);
	tabinsert(dtab, "setr14",	setr14);
	tabinsert(dtab, "setr15",	setr15);

	tabinsert(dtab, "geteflags",	geteflags);
	tabinsert(dtab, "seteflags",	seteflags);

	tabinsert(dtab, "bpset",	setbrk);
	tabinsert(dtab, "bpdel",	clrbrk);
	tabinsert(dtab, "xcont",	cont);
	tabinsert(dtab, "xstep",	step);
	tabinsert(dtab, "xcontwait",	contwait);
	tabinsert(dtab, "xbreak",	brk);

	define dispatch arg {
		cmd = pop(arg);
		fn = tablook(dtab, cmd);
		if(fn == nil)
			error("call to undefined pras operator: %s", cmd);
		return apply(fn, arg);
	}

	if(isstring(listref(arg, 0))){
		addr = listref(arg, 0);
		pop(arg);
		fd = opentcp(addr);
	}else if(isfd(listref(arg, 0))){
		fd = listref(arg, 0);
		pop(arg);
	}else
		error("operand 1 to mkpras must be an address or an fd");

	l = mkfdas(fd, nil);
	indom = mkdom(protns, listref(l, 0));
	outdom = mkdom(protns, listref(l, 1));
	ip = {indom}0;
	op = {outdom}0;
	brktab = mktab();

	launch(arg);
	return mkas(dispatch);
}

define mkremoteprocdom arg {
}

define mklocalprocas arg {
	@local cmd, fd, as;

	cmd = listref(arg, 0);
	fd = popen("prctl", "-c");
	as = apply(mkpras, fd, arg);
	return as;
}

define mklocalprocdom arg {
	@local cmd, ns, as;

	cmd = listref(arg, 0);
	ns = eval(sprintfa("@names c32le { @include \"%s.names\" };", cmd));
	as = apply(mklocalprocas, arg);
	return mkdom(ns, as);
}
