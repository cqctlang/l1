@include <fdas.l1>

protns = @names c32le {
	enum Mkind {
		Rerror = 0,
		Tlaunch,
		Rlaunch,
		Tcont,
		Rcont,

		Tstop,
		Rstop,
		Tkill,
		Rkill,
		Tsetbrk,

		Rsetbrk,
		Tclrbrk,
		Rclrbrk,
		Tread,
		Rread,

		Abrk,
		Aobit,
		Aack,
		Tcleave,
		Rcleave,

		Twrite,
		Rwrite,
		Tsetregs,
		Rsetregs,
		Tsetsnap,

		Rsetsnap,
		Asnap,
		Tattach,
		Rattach,
		Ttest,

		Rtest,
		Tstep,
		Rstep,
		Aclone,
	};

	enum State {
		Running,
		Stopped,
		Dead,
	};

	typedef
	struct Reg {
		@0	uint64 eflags;
		@8	uint64 rbx;
		@16	uint64 rcx;
		@24	uint64 rdx;
		@32	uint64 rsi;
		@40	uint64 rdi;
		@48	uint64 rbp;
		@56	uint64 rax;
		@64	uint64 rip;
		@72	uint64 rsp;
		@80	uint64 r8;
		@88	uint64 r9;
		@96	uint64 r10;
		@104	uint64 r11;
		@112	uint64 r12;
		@120	uint64 r13;
		@128	uint64 r14;
		@136	uint64 r15;
		@144;
	} Reg;

	struct Rerror{
		@0	uint8 op;
		@1	uint64 id;
		@9	char err[0];
		@9	char bytes[0];
		@9;
	};
	typedef struct Rerror Rerror;
	typedef struct Rerror Rread;

	struct Tlaunch{
		@0	uint8 op;
		@1	uint64 narg;
		@9;
	};
	typedef struct Tlaunch Tlaunch;

	struct Rlaunch{
		@0	uint8 op;
		@1	uint64 id;
		@9	Reg reg;
		@153;
	};
	typedef struct Rlaunch Rlaunch;
	typedef struct Rlaunch Rstop;
	typedef struct Rlaunch Tsetregs;

	struct Rcont{
		@0	uint8 op;
		@1	uint64 id;
		@1	uint64 cnt;
		@9;
	};
	typedef struct Rcont Tcont;
	typedef struct Rcont Tstop;
	typedef struct Rcont Rcont;
	typedef struct Rcont Rwrite;
	typedef struct Rcont Tattach;
	typedef struct Rcont Rattach;
	typedef struct Rcont Rclrbrk;
	typedef struct Rcont Rkill;
	typedef struct Rcont Rsetregs;
	typedef struct Rcont Aobit;
	typedef struct Rcont Aack;
	typedef struct Rcont Rtest;
	typedef struct Rcont Tstep;
	typedef struct Rcont Rstep;

	struct Tsetbrk{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@9	uint64 addr;
		@9	uint64 cid;
		@17;
	};
	typedef struct Tsetbrk Tsetbrk;
	typedef struct Tsetbrk Tclrbrk;
	typedef struct Tsetbrk Rsetbrk;
	typedef struct Tsetbrk Rsetsnap;
	typedef struct Tsetbrk Rcleave;

	struct Abrk{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@9	uint64 cid;
		@17	Reg reg;
		@161;
	};
	typedef struct Abrk Abrk;
	typedef struct Abrk Aclone;

	struct Asnap{
		@0	uint8 op;
		@1	uint64 id;
		@9	uint64 bp;
		@9	uint64 addr;
		@17	uint64 cid;
		@17	uint64 cnt;
		@25	char bytes[0];
		@25;
	};
	typedef struct Asnap Asnap;
	typedef struct Asnap Tread;
	typedef struct Asnap Twrite;
};

@record Trapman { look, add, clr, reset, list };
rdsetfmt(@record Trap { uid, mid, fn, arg, clr },
	 lambda(t) { sprintfa("[ %u %u %a %a ]", t.uid, t.mid, t.fn, t.arg); });

define mktrapman()
{
	@local trapman, nextid;
	@local uidmap, midmap, look, add, clr, list, reset;
	
	nextid = 0;
	uidmap = {:};
	midmap = {:};

	define look(mid)
	{
		return midmap[mid];
	}

	define add(mid, fn, arg, clr)
	{
		@local t, uid;
		uid = nextid++;
		t = Trap(uid, mid, fn, arg, clr);
		uidmap[uid] = t;
		midmap[mid] = t;
		return t;
	}

	define clr(uid)
	{
		@local t;
		t = uidmap[uid];
		if(t == nil)
			error("no such trap: %a", uid);
		tabdelete(uidmap, t.uid);
		tabdelete(midmap, t.mid);
		t.clr();
	}

	define list()
	{
		@local k, rv;
		k = tabkeys(uidmap);
		sort(k, lambda(a,b){ return a-b; });
		return map(lambda(uid){ uidmap[uid]; }, k);
	}

	define reset()
	{
		@local k, rv;
		k = tabkeys(uidmap);
		sort(k, lambda(a,b){ return a-b; });
		foreach(clr, k);
		nextid = 0;
	}

	return Trapman(look, add, clr, reset, list);
}

define mkpras(arg) {
	@local addr, fd, cmd, as, protdom, l;
	@local indom, outdom, ip, op, p;
	@local read1, ipress, opress, xwr, copydata, checkreply;
	@local launch, cont, brk, ack, xread, xwrite, setbrk, clrbrk, sync;
	@local dispatch, get, put, map;
	@local id, state, reg;
	@local brktab, dtab;
	@local logsend, logrecv, log, verbose;
	@local as, rdom, trapman;

	trapman = mktrapman();
	verbose = 0;

	define logsend(s){
		if(verbose)
			printf("<-- %s\n", s);
	}

	define logrecv(s){
		if(verbose)
			printf("--> %s\n", s);
	}

	define log(s){
		if(verbose)
			printf("%s\n", s);
	}

	/* read n-1th byte ahead in input stream,
	   thereby extending window to include it and preceding bytes. */
	define ifetch(n){
		@local p;
		p = (char*)ip;
		p += n-1;
		p = *p;
	}

	define ipress(t){
		ip = {t}ip;
		return ip++;
	}

	define opress(t){
		op = {t}op;
		return op++;
	}

	define copydata(p){
		@local dom;
		dom = mkdom(nsof(p), mksas(getbytes(p)));
		return {typeof(p)}{dom}0;
	}

	define xwr(v){
		if(iscvalue(v)){
			op = {mkctype_ptr(typeof(v),nsptr(domof(v)))}op;
			*op++ = v;
		}else if(isstring(v)){
			op = (char*)op;
			putbytes(op, v);
			op += strlen(v);
		}else
			error("bad argument to xwr: %a", v);
	}

	define xrds(cnt){
		@local s;
		ip = (char*)ip;
		s = getbytes(ip, cnt);
		ip += cnt;
		return s;
	}

	define read1() {
		@local sz;

		if(indom.iseof())
			return nil;

		sz = *ipress(#indom`uint64*#);
		ifetch(sz);
		ip = (`uint8*)ip;
		switch((enum Mkind)*ip){
		case indom`Rerror:
			return ipress(#indom`Rerror*#);
		case indom`Rlaunch:
			return ipress(#indom`Rlaunch*#);
		case indom`Rcont:
			return ipress(#indom`Rcont*#);
		case indom`Rstep:
			return ipress(#indom`Rstep*#);
		case indom`Aobit:
			return ipress(#indom`Aobit*#);
		case indom`Rstop:
			return ipress(#indom`Rstop*#);
		case indom`Rsetbrk:
			return ipress(#indom`Rsetbrk*#);
		case indom`Rclrbrk:
			return ipress(#indom`Rclrbrk*#);
		case indom`Rread:
			return ipress(#indom`Rread*#);
		case indom`Abrk:
			return ipress(#indom`Abrk*#);
		case indom`Rwrite:
			return ipress(#indom`Rwrite*#);
		case indom`Rsetregs:
			return ipress(#indom`Rsetregs*#);
		case indom`Rattach:
			return ipress(#indom`Rattach*#);
		case indom`Aclone:
			return ipress(#indom`Aclone*#);
		case indom`Rcleave:
		case indom`Rsetsnap:
		case indom`Asnap:
		case indom`Rtest:
		case indom`Rkill:
		default:
			error("received unhandled message: %e", *ip);
		}
	}

	define checkreply(op, reply){
		if(reply == nil)
			error("unexpected end of file from prctl");
		if(reply->op == indom`Rerror)
			error("pras: while waiting for %e: %s",
			      op, reply->bytes);
		if(reply->op != op)
			error("pras: while waiting for %e: received %e",
			      op, (enum Mkind)reply->op);
	}

	define attach(domas, pid){
		xwr((`uint64)sizeof(outdom`Tattach));
		p = opress(#outdom`Tattach*#);
		p->op = outdom`Tattach;
		p->id = pid;
		outdom.flush();
		logsend("Tattach");

		reply = read1();
		checkreply(indom`Rattach, reply);
		id = reply->id;
		/* since attach does not stop, initialize regs to zero */
		reg = {#indom`Reg*#}{mkdom(indom.ns,
					   mksas(mkstr(sizeof(indom`Reg))))}0;
		indom.flush();

		state = indom`Running;
	}

	define launch(domas, arg){
		@local argvlen, narg, i;

		narg = length(arg);
		if(narg == 0)
			error("mkpras: launch: empty command");

		/* format Tlaunch message */
		argvlen = 0;
		for(i = 0; i < narg; i++)
			argvlen += strlen(listref(arg, i))+1;
		xwr((`uint64)(sizeof(outdom`Tlaunch)+argvlen));
		p = opress(#outdom`Tlaunch*#);
		p->op = outdom`Tlaunch;
		p->narg = narg;
		for(i = 0; i < narg; i++){
			log("2");
			xwr(listref(arg, i));
			xwr((`uint8)0);
		}
		log("3");
		outdom.flush();
		logsend("Tlaunch");

		/* receive Rlaunch reply */
		reply = read1();
		checkreply(indom`Rlaunch, reply);
		id = reply->id;
		reg = copydata(&reply->reg);
		indom.flush();
		logrecv("Rlaunch");

		state = indom`Stopped;
	}

	define cont(domas){
		if(state != indom`Stopped)
			return;

		xwr((`uint64)sizeof(outdom`Tcont));
		p = opress(#outdom`Tcont*#);
		p->op = outdom`Tcont;
		p->id = id;
		outdom.flush();
		logsend("Tcont");

		reply = read1();
		checkreply(indom`Rcont, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		indom.flush();
		logrecv("Rcont");

		state = indom`Running;
	}

	define step args {
		@local n;

		if(state != indom`Stopped)
			return;

		printf("step %a\n", args);

		if(length(args) == 2)
			n = listref(args, 1);
		else
			n = 1;
		if(n == 0)
			return;
		while(n-- > 0){
			xwr((`uint64)sizeof(outdom`Tstep));
			p = opress(#outdom`Tstep*#);
			p->op = outdom`Tstep;
			p->id = id;
			outdom.flush();
			logsend("Tstep");
			
			reply = read1();
			checkreply(indom`Rstep, reply);
			if(reply->id != id)
				error("pras: got %e for unknown task",
				      (enum Mkind)reply->op);
			indom.flush();
			logrecv("Rstep");
		}
	}

	define brk(domas){
		if(state != indom`Running)
			return;

		xwr((`uint64)sizeof(outdom`Tstop));
		p = opress(#outdom`Tstop*#);
		p->op = outdom`Tstop;
		p->id = id;
		outdom.flush();
		logsend("Tstop");

		reply = read1();
		checkreply(indom`Rstop, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		reg = copydata(&reply->reg);
		indom.flush();
		logrecv("Rstop");

		state = indom`Stopped;
	}

	define ack(){
		xwr((`uint64)sizeof(outdom`Aack));
		p = opress(#outdom`Aack*#);
		p->op = outdom`Aack;
		p->id = id;
		outdom.flush();
		logsend("Aack");
	}

	define xread(addr, cnt){
		@local s;

		xwr((`uint64)sizeof(outdom`Tread));
		p = opress(#outdom`Tread*#);
		p->op = outdom`Tread;
		p->id = id;
		p->addr = addr;
		p->cnt = cnt;
		outdom.flush();
		logsend("Tread");

		reply = read1();
		checkreply(indom`Rread, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		s = xrds(cnt);
		indom.flush();
		logrecv("Rread");

		return s;
	}

	define xwrite(addr, cnt, bytes){
		xwr((`uint64)(sizeof(outdom`Twrite)+cnt));
		p = opress(#outdom`Twrite*#);
		p->op = outdom`Twrite;
		p->id = id;
		p->addr = addr;
		p->cnt = cnt;
		xwr(bytes);
		outdom.flush();
		logsend("Twrite");

		reply = read1();
		checkreply(indom`Rwrite, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		indom.flush();
		logrecv("Rwrite");
	}

	define clrbrk(domas, bp){
		xwr((`uint64)sizeof(outdom`Tclrbrk));
		p = opress(#outdom`Tclrbrk*#);
		p->op = outdom`Tclrbrk;
		p->id = id;
		p->bp = bp;
		outdom.flush();
		logsend("Tclrbrk");

		reply = read1();
		checkreply(indom`Rclrbrk, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		indom.flush();
		logrecv("Rclrbrk");
	}

	define xtrap(domas, addr, fn){
		xwr((`uint64)sizeof(outdom`Tsetbrk));
		p = opress(#outdom`Tsetbrk*#);
		p->op = outdom`Tsetbrk;
		p->id = id;
		p->addr = addr;
		outdom.flush();
		logsend("Tsetbrk");

		reply = read1();
		checkreply(indom`Rsetbrk, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		bp = reply->bp;
		indom.flush();
		logrecv("Rsetbrk");

		return trapman.add(bp, fn, [addr],
				lambda() {
					xwr((`uint64)sizeof(outdom`Tclrbrk));
					p = opress(#outdom`Tclrbrk*#);
					p->op = outdom`Tclrbrk;
					p->id = id;
					p->bp = bp;
					outdom.flush();
					logsend("Tclrbrk");
					
					reply = read1();
					checkreply(indom`Rclrbrk, reply);
					if(reply->id != id)
						error("pras: got %e "
						      "for unknown task",
						      (enum Mkind)reply->op);
					indom.flush();
					logrecv("Rclrbrk");
				});
	}

	define trapdel(domas, tid){
		trapman.clr(tid);
		return nil;
	}

	define trapreset(domas){
		trapman.reset();
		return nil;
	}

	define traplist(domas){
		return trapman.list();
	}

	define setbrk(domas, addr, fn){
		@local bp;

		xwr((`uint64)sizeof(outdom`Tsetbrk));
		p = opress(#outdom`Tsetbrk*#);
		p->op = outdom`Tsetbrk;
		p->id = id;
		p->addr = addr;
		outdom.flush();
		logsend("Tsetbrk");

		reply = read1();
		checkreply(indom`Rsetbrk, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		bp = reply->bp;
		tabinsert(brktab, bp, [addr, fn]);
		indom.flush();
		logrecv("Rsetbrk");

		return bp;
	}

	define setregs(){
		xwr((`uint64)sizeof(outdom`Tsetregs));
		p = opress(#outdom`Tsetregs*#);
		p->op = outdom`Tsetregs;
		p->id = id;
		putbytes(&p->reg, getbytes(reg));
		outdom.flush();
		logsend("Tsetregs");

		reply = read1();
		checkreply(indom`Rsetregs, reply);
		if(reply->id != id)
			error("pras: got %e for unknown task",
			      (enum Mkind)reply->op);
		indom.flush();
		logrecv("Rsetregs");
	}

	define sync(domas){
		@local bp, rv, t;

		reply = read1();
		switch(reply->op){
		case indom`Aobit:
			logrecv("Aobit");
			ack();
			if(reply->id != id)
				error("pras: got obituary for unknown task");
			indom.flush();
			state = indom`Dead;
			break;
		case indom`Abrk:
			logrecv("Abrk");
			ack();
			if(reply->id != id)
				error("pras: got %e for unknown task",
				      (enum Mkind)reply->op);
			reg = copydata(&reply->reg);
			state = indom`Stopped;
			t = trapman.look(reply->bp);
			indom.flush();
			rv = t.fn(t.uid, getpc(domas));
			if(rv == 1)
				cont(domas);
			else if(rv != 0)
				error("xtrap handler returned bad value (%d)",
				      rv);
			break;
		case indom`Aclone:
			logrecv("Aclone");
			ack();
			if(reply->id != id)
				error("pras: got %e for unknown task",
				      (enum Mkind)reply->op);
			break;
		case indom`Asnap:
			logrecv("Asnap");
			error("pras: sync: unhandled message: %e",
			      (enum Mkind)reply->op);
		default:
			error("pras: sync: unexpected message: %e",
			      (enum Mkind)reply->op);
		}
	}

	define contwait(domas){
		cont(domas);
		while(state == indom`Running)
			sync(domas);
	}

	define get(domas, r){
		return xread(rangebeg(r), rangelen(r));
	}

	define put(domas, r, s){
		return xwrite(rangebeg(r), rangelen(r), s);
	}

	define map(domas){
		return vector(mkrange(0, (`uint64)-1));
	}

	define getrbx(domas){
		if(isdom(domas))
			return {domas}reg->rbx;
		else
			return {rdom}reg->rbx;
	}
	define getrcx(domas){
		if(isdom(domas))
			return {domas}reg->rcx;
		else
			return {rdom}reg->rcx;
	}
	define getrdx(domas){
		if(isdom(domas))
			return {domas}reg->rdx;
		else
			return {rdom}reg->rdx;
	}
	define getrsi(domas){
		if(isdom(domas))
			return {domas}reg->rsi;
		else
			return {rdom}reg->rsi;
	}
	define getrdi(domas){
		if(isdom(domas))
			return {domas}reg->rdi;
		else
			return {rdom}reg->rdi;
	}
	define getrbp(domas){
		if(isdom(domas))
			return {domas}reg->rbp;
		else
			return {rdom}reg->rbp;
	}
	define getrax(domas){
		if(isdom(domas))
			return {domas}reg->rax;
		else
			return {rdom}reg->rax;
	}
	define getrip(domas){
		if(isdom(domas))
			return {domas}reg->rip;
		else
			return {rdom}reg->rip;
	}
	define getrsp(domas){
		if(isdom(domas))
			return {domas}reg->rsp;
		else
			return {rdom}reg->rsp;
	}
	define getr8(domas){
		if(isdom(domas))
			return {domas}reg->r8;
		else
			return {rdom}reg->r8;
	}
	define getr9(domas){
		if(isdom(domas))
			return {domas}reg->r9;
		else
			return {rdom}reg->r9;
	}
	define getr10(domas){
		if(isdom(domas))
			return {domas}reg->r10;
		else
			return {rdom}reg->r10;
	}
	define getr11(domas){
		if(isdom(domas))
			return {domas}reg->r11;
		else
			return {rdom}reg->r11;
	}
	define getr12(domas){
		if(isdom(domas))
			return {domas}reg->r12;
		else
			return {rdom}reg->r12;
	}
	define getr13(domas){
		if(isdom(domas))
			return {domas}reg->r13;
		else
			return {rdom}reg->r13;
	}
	define getr14(domas){
		if(isdom(domas))
			return {domas}reg->r14;
		else
			return {rdom}reg->r14;
	}
	define getr15(domas){
		if(isdom(domas))
			return {domas}reg->r15;
		else
			return {rdom}reg->r15;
	}

	define geteflags(domas){
		if(isdom(domas))
			return {domas}reg->eflags;
		else
			return {rdom}reg->eflags;
	}

	define getpc(domas){
		if(!isdom(domas))
			error("getpc must be invoked on a domain");
		if(sizeof(nsptr(domas)) == 8)
			return {domas}reg->rip;
		else
			return {domas}reg->eip;
	}

	define setrbx(domas, x) { reg->rbx = x; setregs(); }
	define setrcx(domas, x) { reg->rcx = x; setregs(); }
	define setrdx(domas, x) { reg->rdx = x; setregs(); }
	define setrsi(domas, x) { reg->rsi = x; setregs(); }
	define setrdi(domas, x) { reg->rdi = x; setregs(); }
	define setrbp(domas, x) { reg->rbp = x; setregs(); }
	define setrax(domas, x) { reg->rax = x; setregs(); }
	define setrip(domas, x) { reg->rip = x; setregs(); }
	define setrsp(domas, x) { reg->rsp = x; setregs(); }
	define setr8(domas, x)  { reg->r8 = x; setregs(); }
	define setr9(domas, x)  { reg->r9 = x; setregs(); }
	define setr10(domas, x) { reg->r10 = x; setregs(); }
	define setr11(domas, x) { reg->r11 = x; setregs(); }
	define setr12(domas, x) { reg->r12 = x; setregs(); }
	define setr13(domas, x) { reg->r13 = x; setregs(); }
	define setr14(domas, x) { reg->r14 = x; setregs(); }
	define setr15(domas, x) { reg->r15 = x; setregs(); }
	define seteflags(domas, x) { reg->eflags = x; setregs(); }

	define setpc(domas, x){
		if(!isdom(domas))
			error("setpc must be invoked on a domain");
		if(sizeof(nsptr(domas)) == 8)
			reg->rip = x;
		else
			reg->eip = x;
		setregs();
	}

	dtab = {
		"get"		:       get,
		"put"		:	put,
		"map"		:	map,
		
		"getebx"	:	getrbx,
		"getecx"	:	getrcx,
		"getedx"	:	getrdx,
		"getesi"	:	getrsi,
		"getedi"	:	getrdi,
		"getebp"	:	getrbp,
		"geteax"	:	getrax,
		"geteip"	:	getrip,
		"getesp"	:	getrsp,
		
		"setebx"	:	setrbx,
		"setecx"	:	setrcx,
		"setedx"	:	setrdx,
		"setesi"	:	setrsi,
		"setedi"	:	setrdi,
		"setebp"	:	setrbp,
		"seteax"	:	setrax,
		"seteip"	:	setrip,
		"setesp"	:	setrsp,
		
		"getrbx"	:	getrbx,
		"getrcx"	:	getrcx,
		"getrdx"	:	getrdx,
		"getrsi"	:	getrsi,
		"getrdi"	:	getrdi,
		"getrbp"	:	getrbp,
		"getrax"	:	getrax,
		"getrip"	:	getrip,
		"getrsp"	:	getrsp,
		"getr8"		:	getr8,
		"getr9"		:	getr9,
		"getr10"	:	getr10,
		"getr11"	:	getr11,
		"getr12"	:	getr12,
		"getr13"	:	getr13,
		"getr14"	:	getr14,
		"getr15"	:	getr15,
		
		"setrbx"	:	setrbx,
		"setrcx"	:	setrcx,
		"setrdx"	:	setrdx,
		"setrsi"	:	setrsi,
		"setrdi"	:	setrdi,
		"setrbp"	:	setrbp,
		"setrax"	:	setrax,
		"setrip"	:	setrip,
		"setrsp"	:	setrsp,
		"setr8"		:	setr8,
		"setr9"		:	setr9,
		"setr10"	:	setr10,
		"setr11"	:	setr11,
		"setr12"	:	setr12,
		"setr13"	:	setr13,
		"setr14"	:	setr14,
		"setr15"	:	setr15,
		
		"getpc"		:	getpc, 
		"setpc"		:	setpc, 

		"geteflags"	:	geteflags,
		"seteflags"	:	seteflags,
		
		"launch"	:	launch,
		"attach"	:	attach,
		"xtrap"		:	xtrap,
		"trapdel"	:	trapdel,
		"traplist"	:	traplist,
		"trapreset"	:	trapreset,
		"xcont"		:	cont,
		"xstep"		:	step,
		"xcontwait"	:	contwait,
		"xbreak"	:	brk,
	};
	
	if(isstring(arg))
		fd = tcpopen(arg);
	else if(isfd(arg))
		fd = arg;
	else
		error("operand 1 to mkpras must be an address or an fd");

	l = mkfdas(fd, nil);
	indom = mkdom(protns, l[0]);
	outdom = mkdom(protns, l[1]);
	ip = {indom}0;
	op = {outdom}0;
	brktab = mktab();
	as = mkas(dtab);
	rdom = mkdom(c32le, as);
	return as;
}

define mkremoteprocdom arg {
       @local fd, as;
       fd = tcpopen(pop(arg));
       as = mkpras(fd);
       as.launch(arg);
       return as;
}

define launchlocalproc arg {
	@local fd, as;
	fd = popen("prctl", "-c");
	as = mkpras(fd);
	as.launch(arg);
	return as;
}

define attachlocalproc(pid) {
	@local fd, as;
	fd = popen("prctl", "-c");
	as = mkpras(fd);
	as.attach(pid);
	return as;
}

define mklocalprocdom arg {
	@local cmd, ns, as;

	cmd = listref(arg, 0);
	ns = eval(sprintfa("@names clp64le { @include \"%s.names\" };", cmd));
	as = apply(launchlocalproc, arg);
	return mkdom(ns, as);
}
