@global library_defined;

@include <pp.cqct>

if (library_defined == nil)
{
@global library_exports,pathto;
library_exports = [:];


@define pathto(f) {
  @local i,paths,len;
  paths = loadpath();
  len = length(paths);
  for(i=0;i<len;++i) {
    @local fp;
    fp = sprintfa("%s/%s",paths[i],f);
    if (access(fp,"r"))
      return fp;
  }
  return nil;
}

@defstx @library(name,imports,exports) body {
  @local libname, new_body, new_locals;

  switch(name) {
  @match #id(v):
    libname = v;
    break;
  default: error("Error: library name %a not an id",name);
  }

  @defloc gen_libload_stx(lib) {
    return #`{
      if (library_exports[#,(lib)] == nil) {
        @local l,fp;
        fp = pathto(sprintfa("%a.cqct",#,(lib)));
        if (fp == nil) error("Error: could not find library: %a",#,(lib));
        l = mapfile(fp);
        eval(l);
        if (library_exports[#,(lib)] == nil) 
          error("Error: library %a does not export itself (no @library?)",
              #,(lib));
      }
    };
  }

  new_body = [ #`{ library_exports[#,(#val(libname))] = [:]; } ];
  new_locals = [];
  switch(imports) {
    @match #list(x): 
      imports = x; break;
    default: error("Error: library %a imports not a list\n",libname);
  };
  foreach(@lambda(en) {
    @local s,fn;
    printf("%a\n",en);
    switch(en) {
      @match #list(x):
        fn = Zcar(x);
        switch(fn) {
        @match #id(d): fn = d; break;
        default: error("Bad import entry: %a\n",en);
        };
        switch(Zcar(Zcdr(x))) {
          @match #dot(#id(lname),#id(lfn)):
            //store the id in the list of locals
            append(new_locals,#id(fn));
            //create a lazy-loading function that will fetch that symbol
            //from the named library when the function is run.
            s = #`{
              #,(#id(fn)) = @lambda(args...) {
                //printf("X %a %a %a\n", library_exports[ #,(lname) ],
                                                      //#,(lname), #,(lfn));
                #,(gen_libload_stx(lname));
                /*
                foreach(@lambda(k,v) { 
                  printf("%a %a\n",k,v);
                  foreach(@lambda(k2,v2) {
                    printf("  %a %a\n",k2,v2);
                  },library_exports[k]);
                },library_exports);
                */
                #,(#id(fn)) = 
                    library_exports[ #,(lname) ][ #,(lfn) ]();
                if ( #,(#id(fn)) == nil ) 
                  error("Error: %a depends on unprovided %a in %a",
                    #,(libname), #,(#val(lfn)), #,(#val(lname)));
                return apply(#,(#id(fn)),args);
              };
            };
            append(new_body,s);
            break;
          default: error("Error: library %a could not parse imports\n",libname);
        }
        break;
      default: error("Error: library %a could not parse imports\n",libname);
    }
  },Z2list(imports));

  switch(exports) {
    @match #list(x): 
      exports = x; break;
    default: error("Error: library %a exports not a list\n",libname);
  };
  foreach(@lambda(en) {
    @local s;
    append(new_locals,en);
    switch(en) {
    @match #id(x): en = x; break;
    default: error("Error parsing export %a in %a\n",en,libname);
    }
    s = #`{
      library_exports[#,(#val(libname))] [#,(en)] = 
          @lambda() { return #,(#id(en)); };
    };
    append(new_body,Zcar(s));
  },Z2list(exports));

  new_locals = apply(Zlist,new_locals);

  append(new_body,body);
  new_body = apply(Zlist,new_body);
  
  printf("expanding @library %a\n",libname);
  return #[#scope(#block(new_locals,new_body))];
}

}
