@global library_defined;

/*
Prototype implementation of a library system for l1.

To define a library create a new file and start with the following:

@library(name, //must be the file's name minus its .cqct extension
  [ [import1, lib1.f1], [import2, lib1.f2], [import3, lib2.f1], ... ],
  [ export1, export2, ... ]
{
  //in this scope, import1 will be bound as a local variable to the export 
  //named f1 of the library named lib1 (the system will search the load path 
  //for lib1.cqct). lib1.cqct must contain an @library(lib1 ... ) { ... }.

  //We must define export1, export2, etc in this scope.
}

All library bindings are resolved lazily at run time. Recursive dependencies
are allowed. 

*/

if (library_defined == nil)
{
@global library_exports,pathto;
library_exports = [:];

@define pathto(f) {
  @local i,paths,len;
  paths = loadpath();
  len = length(paths);
  for(i=0;i<len;++i) {
    @local fp;
    fp = sprintfa("%s/%s",paths[i],f);
    if (access(fp,"r"))
      return fp;
  }
  return nil;
}

@defstx @library(name,imports,exports) body {
  @local libname, new_body, new_locals;

  switch(name) {
  @match #id(v):
    libname = v;
    break;
  default: error("library name %a not an id",name);
  }

  @defloc gen_libload_stx(lib) {
    return #`{
      if (library_exports[#,(lib)] == nil) {
        @local l,fp;
        fp = pathto(sprintfa("%a.cqct",#,(lib)));
        if (fp == nil) error("could not find library: %a",#,(lib));
        l = mapfile(fp);
        eval(l);
        if (library_exports[#,(lib)] == nil) 
          error("library %a does not export itself (no @library?)",
              #,(lib));
      }
    };
  }

  new_body = [ #`{ library_exports[#,(#val(libname))] = [:]; } ];
  new_locals = [];
  switch(imports) {
    @match #list(x): 
      imports = x; break;
    default: error("library %a imports not a list\n",libname);
  };
  foreach(@lambda(en) {
    @local s,fn;
    switch(en) {
      @match #comma(x,y):
        fn = x;
        switch(fn) {
        @match #id(d): fn = d; break;
        default: error("Bad import entry: %a\n",en);
        };
        switch(y) {
          @match #dot(#id(lname),#id(lfn)):
            //store the id in the list of locals
            append(new_locals,#id(fn));
            //create a lazy-loading function that will fetch that symbol
            //from the named library when the function is run.
            s = #`{
              #,(#id(fn)) = @lambda(args...) {
                //printf("X %a %a %a\n", library_exports[ #,(lname) ],
                                                      //#,(lname), #,(lfn));
                #,(gen_libload_stx(lname));
                /*
                foreach(@lambda(k,v) { 
                  printf("%a %a\n",k,v);
                  foreach(@lambda(k2,v2) {
                    printf("  %a %a\n",k2,v2);
                  },library_exports[k]);
                },library_exports);
                */
                #,(#id(fn)) = 
                    library_exports[ #,(lname) ][ #,(lfn) ];
                if ( #,(#id(fn)) == nil ) 
                  error("%a depends non-existent %a.%a",
                    #,(libname), #,(#val(lname)), #,(#val(lfn))  );
                #,(#id(fn)) = #,(#id(fn))();
                if ( #,(#id(fn)) == nil ) 
                  error("%a depends non-existent %a.%a",
                    #,(libname), #,(#val(lname)), #,(#val(lfn))  );
                return apply(#,(#id(fn)),args);
              };
            };
            append(new_body,s);
            break;
          default: error("library %a could not parse imports\n",libname);
        }
        break;
      default: error("library %a could not parse imports\n",libname);
    }
  },Z2list(imports));

  switch(exports) {
    @match #list(x): 
      exports = x; break;
    default: error("library %a exports field is not a list\n",libname);
  };
  foreach(@lambda(en) {
    @local s;
    append(new_locals,en);
    switch(en) {
    @match #id(x): en = x; break;
    default: error("Error parsing export %a in %a\n",en,libname);
    }
    s = #`{
      library_exports[#,(#val(libname))] [#,(en)] = 
          @lambda() { return #,(#id(en)); };
    };
    append(new_body,Zcar(s));
  },Z2list(exports));

  new_locals = apply(Zlist,new_locals);

  append(new_body,body);
  new_body = apply(Zlist,new_body);
  
  return #[#scope(#block(new_locals,new_body))];
}

}
