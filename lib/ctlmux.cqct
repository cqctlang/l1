@include <linux-x86_64.cqct>
@include <stack.x86_64.cqct>
@include <trapman.cqct>
@include <linux.cqct>

ctlmux = @names clp64le {
	enum Mkind {
		Reserved0 = 0,
		Rerror,
		Reserved2,
		Aevent,
		Tversion,
		Rversion,
		Tping,
		Rping,
		Tps,
		Rps,
		Tlaunch,
		Rlaunch,
		Tattach,
		Rattach,
		Tstat,
		Rstat,
		Tcont,
		Rcont,
		Tstop,
		Rstop,
		Tstep,
		Rstep,
		Tsnap,
		Rsnap,
		Tkill,
		Rkill,
		Tdetach,
		Rdetach,
		Ttrace,
		Rtrace,
		Tsettrap,
		Rsettrap,
		Tclrtrap,
		Rclrtrap,
		Tgetctx,
		Rgetctx,
		Tsetctx,
		Rsetctx,
		Tread,
		Rread,
		Twrite,
		Rwrite,
		Tlooksym,
		Rlooksym,
		Tenumsym,
		Renumsym,
		Tlooktype,
		Rlooktype,
		Tenumtype,
		Renumtype,
		Tlookaddr,
		Rlookaddr,
		Tenumloc,
		Renumloc,
		Tunwind,
		Runwind,
		Tenumseg,
		Renumseg,
		Tnames,
		Rnames,
		Tunwind1,
		Runwind1,
	};

	enum State {
		Running,
		Requestedrun,
		Stopped,
		Dead,
	};

	enum Mode {
		/* trap modes */
		Mbrk	= 0,
		Msnap	= 1,
	};

	enum Flags {
		/* launch flags */
		Fstdin   = 1,		  /* redirect stdin */
		Fstdout  = (Fstdin<<1),   /* redirect stdout */
		Fstderr  = (Fstdout<<1),  /* redirect stderr */
	};

	typedef
	enum Event {
		Eclear	 = 0,
		Eset	 = 1,
		Esyscall = (Eset<<1),
		Eexec	 = (Esyscall<<1),
		Efork    = (Eexec<<1),
		Eclone   = (Efork<<1),
		Esignal  = (Eclone<<1),
		Eexit    = (Esignal<<1),
		Etrap    = (Eexit<<1),
		Esnap	 = (Etrap<<1),
		Estepctx = (Esnap<<1),
		Eload	 = (Estepctx<<1),
		Eunload	 = (Eload<<1),
	} Event;

	typedef
	enum Prot {
		PROT_READ	= 0x1,		/* Page can be read.  */
		PROT_WRITE	= 0x2,		/* Page can be written.  */
		PROT_EXEC	= 0x4,		/* Page can be executed.  */
	} Prot;

	typedef
	enum Attrval {
		Astr,
		Acid,
		Auint,
	} Attrval;

	typedef
	enum Cbase
	{
		Vundef=0,
		Vlo,
		Vbool=Vlo,
		Vchar,
		Vshort,
		Vint,
		Vlong,
		Vvlong,
		Vuchar,
		Vushort,
		Vuint,
		Vulong,
		Vuvlong,
		Vfloat,
		Vdouble,
		Vlongdouble,
		Vcomplex,
		Vdoublex,
		Vlongdoublex,
		Vnbase,
		Vptr = Vnbase,		/* alias for some other base type */
		Vvoid,
		Vnallbase,
	} Cbase;

	/* base type representations */
	typedef
	enum Rkind
	{
		Rundef,
		Ru08le,
		Ru16le,
		Ru32le,
		Ru64le,
		Rs08le,
		Rs16le,
		Rs32le,
		Rs64le,
		Ru08be,
		Ru16be,
		Ru32be,
		Ru64be,
		Rs08be,
		Rs16be,
		Rs32be,
		Rs64be,
		Rf32,
		Rf64,
		Rf96,
		Rf128,
		Rx64,
		Rx128,
		Rx192,
		Rnrep,
	} Rkind;
	
	typedef
	enum Tkind
	{
		Tvoid = 0,
		Tbase = 1,
		Tstruct = 2,
		Tunion = 3,
		Tenum = 4,
		Tptr = 5,
		Tarr = 6,
		Tfun = 7,
		Ttypedef = 8,
		Tbitfield = 9,
		Tconst = 10,
		Txaccess = 11,		/* unused */
		Tundef = 12,
	} Tkind;

	enum Stype
	{
		Sundef = 1,
		Sdata = Sundef<<1,
		Stext = Sdata<<1,
		Sro = Stext<<1,
		Senum = Sro<<1,
		Sinline = Senum<<1,
	};

	typedef
	enum Rulekind
	{
		Rnone = 0,
		// cfa rules
		Rcfaro,
		Rcfae,			/* unimplemented */
		// register rules
		Rsame,
		Roff,
		Rvoff,
		Rreg,
		Rexp,			/* unimplemented */
		Rvexp,			/* unimplemented */
	} Rulekind;

	enum ELF_SHN {
		SHN_UNDEF	= 0,
		SHN_ABS		= 0xfff1,
		SHN_COMMON	= 0xfff2,
	};

	typedef
	struct Ctx {
		/* kernel's register set */
		@0x0	uint64 r15;
		@0x8	uint64 r14;
		@0x10	uint64 r13;
		@0x18	uint64 r12;
		@0x20	uint64 rbp;
		@0x28	uint64 rbx;
		@0x30	uint64 r11;
		@0x38	uint64 r10;
		@0x40	uint64 r9;
		@0x48	uint64 r8;
		@0x50	uint64 rax;
		@0x58	uint64 rcx;
		@0x60	uint64 rdx;
		@0x68	uint64 rsi;
		@0x70	uint64 rdi;
		@0x78	uint64 orig_rax;
		@0x80	uint64 rip;
		@0x88	uint64 cs;
		@0x90	uint64 eflags;
		@0x98	uint64 rsp;
		@0xa0	uint64 ss;
		@0xa8	uint64 fs_base;
		@0xb0	uint64 gs_base;
		@0xb8	uint64 ds;
		@0xc0	uint64 es;
		@0xc8	uint64 fs;
		@0xd0	uint64 gs;

		/* current signal number */
		@0xd8	uint64 sig;
		@0xe0; /* 224 */
	} Ctx;

	struct Tversion{
		@0	uint8 op;
		@1	uint32 tag;
		@5;
	};
	typedef struct Tversion Tversion;
	typedef struct Tversion Rversion;

	struct Rerror{
		@0	uint8 op;
		@1	uint32 tag;
		@5	char err[0];
		@5	char bytes[0];
		@5;
	};
	typedef struct Rerror Rerror;
	typedef struct Rerror Rread;

	struct Rcont {
		@0	uint8 op;
		@1	uint32 tag;
		@5;
	};
	typedef struct Rcont Rcont;
	typedef struct Rcont Rclrtrap;
	typedef struct Rcont Rdetach;
	typedef struct Rcont Rkill;
	typedef struct Rcont Rsetctx;
	typedef struct Rcont Rtrace;

	struct Rstop {
		@0	uint8 op;
		@1	uint32 tag;
		@5	Ctx ctx;
		@229;
	};
	typedef struct Rstop Rstop;
	typedef struct Rstop Rgetctx;

	struct Rstep {
		@0	uint8 op;
		@1	uint32 tag;
		@5	Ctx ctx;
		@229;
	};
	typedef struct Rstep Rstep;

	struct Tlaunch{
		@0	uint8 op;
		@1	uint32 tag;
		@5;
	};
	typedef struct Tlaunch Tlaunch;
	typedef struct Tlaunch Tps;
	typedef struct Tlaunch Rps;

	struct Ttrace{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@13;
	};
	typedef struct Ttrace Ttrace;

	struct Rlaunch{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@13	Ctx ctx;
		@237;
	};
	typedef struct Rlaunch Rlaunch;
	typedef struct Rlaunch Rattach;
	typedef struct Rlaunch Tsetctx;

	struct Tcont{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@5	uint64 cnt;
		@13;
	};
	typedef struct Tcont Tcont;
	typedef struct Tcont Tstop;
	typedef struct Tcont Tattach;
	typedef struct Tcont Tkill;
	typedef struct Tcont Tsnap;
	typedef struct Tcont Tdetach;
	typedef struct Tcont Tstep;
	typedef struct Tcont Tstat;
	typedef struct Tcont Rwrite;
	typedef struct Tcont Rping;
	typedef struct Tcont Tgetctx;

	struct Tsettrap{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@13;
	};
	typedef struct Tsettrap Tsettrap;

	struct Tclrtrap{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@13	uint64 tid;
		@21;
	};
	typedef struct Tclrtrap Tclrtrap;

	struct Rsettrap{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 tid;
		@13;
	};
	typedef struct Rsettrap Rsettrap;

	struct Rsnap{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 cid;
		@13	Ctx ctx;
		@237;
	};
	typedef struct Rsnap Rsnap;

	struct Aevent{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@13	uint64 flags;
		@21;
	};
	typedef struct Aevent Aevent;

	struct Esyscall {
		@0	Ctx ctx;
		@224;
	};
	typedef struct Esyscall Esyscall;

	struct Eexit {
		@0;
	};
	typedef struct Eexit Eexit;

	struct Etrap {
		@0	uint64 tid;
		@8	Ctx ctx;
		@232;
	};
	typedef struct Etrap Etrap;
	typedef struct Etrap Eexec;

	struct Esnap {
		@0	uint64 tid;
		@8	uint64 cid;
		@16	Ctx ctx;
		@240;
	};
	typedef struct Esnap Esnap;

	struct Esignal {
		@0	Ctx ctx;
		@224;
	};
	typedef struct Esignal Esignal;

	struct Efork {
		@0	uint64 cid;
		@8	Ctx ctx;
		@232	Ctx cctx;
		@456;
	};
	typedef struct Efork Efork;
	typedef struct Efork Eclone;

	struct Eload {
		/* parse by hand */
		@0;
	};
	typedef struct Eload Eload;

	struct Eunload {
		/* parse by hand */
		@0;
	};
	typedef struct Eunload Eunload;

	struct Tread{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@13	uint64 fd;
		@21     uint64 addr;
		@29	uint64 cnt;
		@37;
	};
	typedef struct Tread Tread;

	struct Twrite{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@13	uint64 fd;
		@21     uint64 addr;
		@29	char bytes[0];
		@29;
	};
	typedef struct Twrite Twrite;

	struct Rstat{
		@0	uint8 op;
		@1	uint32 tag;
		@5	char bytes[0];
		@5;
	};
	typedef struct Rstat Rstat;
	typedef struct Rstat Tping;

	struct Tns{
		@0	uint8 op;
		@1	uint32 tag;
		@5	char bytes[0];
		@5;
	};
	typedef struct Tns Tlooksym;
	typedef struct Tns Tenumsym;
	typedef struct Tns Tlooktype;
	typedef struct Tns Tenumtype;
	typedef struct Tns Tlookaddr;
	typedef struct Tns Tenumloc;
	typedef struct Tns Tunwind;
	typedef struct Tns Tenumseg;
	typedef struct Tns Tnames;
	typedef struct Tns Tunwind1;
	typedef struct Tns Rlooksym;
	typedef struct Tns Renumsym;
	typedef struct Tns Rlooktype;
	typedef struct Tns Renumtype;
	typedef struct Tns Rlookaddr;
	typedef struct Tns Renumloc;
	typedef struct Tns Runwind;
	typedef struct Tns Renumseg;
	typedef struct Tns Rnames;
	typedef struct Tns Runwind1;
};

@record region {
	file,
	addr,
	len,
	flags,
};

@record dll {
	id,
	path,
	base,
};

@record symrec {
	id,
	flags,
	val,
	sz,
	type,
};

@record loc {
	id,
	sz,
	ltype,
	loc,
	type,
};

@record seg {
	addr,
	len,
	name,
};

@record rule {
	kind,
	r,
	n,
};

@record ctlrec {
	id,
	xstop,
	xcont,
	xstep,
	detach,
	kill,
	snap,
	mem,
	ns,
	flushns,
	reg,
	statunix,
	statwin,
	setreg,
	trace,
	xtrap,
	xsnap,
	xtraps,
	trapdel,
	trapreset,
	unwind,
	localns,
	locals,
	// private
	state,
	traps,
	callbacks,
	pending,
};

@define mkresolve(cache, undef, lt)
{
	@local resolve, undefined, ptr, ptrrep;
	@local typepos;

	typepos = 0;   // FIXME: should be opaque

	ptr = lt(mkctype_base(ctlmux`Vptr));
	if(ptr == nil)
		error("no pointer type");
	ptrrep = baserep(ptr);

	@define undefined(tn)
	{
		@local td;
		td = mkctype_undef(tn);
		cache[typename(tn)] = td;
		undef[typename(tn)] = td;
		return td;
	}

	@define resolve(tn)
	{
		@local td, i, m, s, v, st;

		td = cache[typename(tn)];
		if(td != nil)
			return td;

		if(isbase(tn)){
			td = lt(tn);
			if(td == nil)
				error("name space does not define %t", tn);
			cache[typename(tn)] = td;
			return td;
		}else if(issu(tn)){
			td = lt(tn);
			if(td == nil)
				return undefined(tn);
			cache[typename(tn)] = td; // terminate cycles
			s = fields(td);
			m = length(s);
			for(i = 0; i < m; i++){
				v = s[i];
				v[typepos] = resolve(v[typepos]);
			}
			return td;
		}else if(isenum(tn)){
			td = lt(tn);
			if(td == nil)
				return undefined(tn);
			cache[typename(tn)] = td;
			return td;
		}else if(istypedef(tn)){
			td = lt(tn);
			if(td == nil)
				return undefined(tn);
			cache[typename(tn)] = td; // terminate cycles
			settypedeftype(td, resolve(typedeftype(td)));
			return td;
		}else if(isptr(tn)){
			td = mkctype_ptr(resolve(subtype(tn)), ptrrep);
			/* FIXME: cannot cache into cache because
			   we return that as enumtype.  but we could
		           create a separate ptrcache. */
			// cache[typename(tn)] = td; // why not?
			return td;
		}else if(isenumconst(tn)){
			td = mkctype_const(resolve(subtype(tn)));
			return td;
		}else if(isfunc(tn)){
			s = params(tn);
			m = length(s);
			for(i = 0; i < m; i++){
				v = s[i];
				v[typepos] = resolve(v[typepos]);
			}
			td = mkctype_fn(resolve(rettype(tn)), s);
			return td;
		}else if(isarray(tn)){
			return mkctype_array(resolve(subtype(tn)),
					     arraynelm(tn));
		}else if(isvoid(tn)){
			cache[typename(tn)] = mkctype_void();
		}else if(isbitfield(tn)){
			st = resolve(bitfieldcontainer(tn));
			return mkctype_bitfield(st,
						bitfieldwidth(tn),
						bitfieldpos(tn));
		}else
			error("type resolution on unexpected type: %t", tn);
	}
	
	return resolve;
}

@define mkctl(mux, id, state, _reg, traps, callbacks)
{
	@local xstop, xcont, xstep, detach, kill, snap;
	@local mem, reg, setreg, trace, xtrap, xsnap, xtraps, xns;
	@local trapset, trapdel, trapreset;
	@local statunix, statwin, unwind, localns, locals;
	@local this, thisns, checkdead;

	@define checkdead()
	{
		if(state == ctlmux`Dead)
			error("ctl is dead");
	}

	@define xstop()
	{
		checkdead();
		if(this.pending == nil)
			return mux.stop(this);
		this.pending = "stop";
		return nil;
	}

	@define xcont()
	{
		checkdead();
		if(this.pending == nil)
			return mux.cont(this);
		this.pending = "run";
		return nil;
	}

	@define xstep()
	{
		checkdead();
		if(this.pending == nil)
			return mux.step(this);
		this.pending = "step";
		return nil;
	}

	@define detach()
	{
		checkdead();
		if(this.pending == nil)
			mux.detach(this);
		this.pending = "detach";
		return nil;
	}

	@define kill()
	{
		checkdead();
		if(this.pending == nil)
			mux.kill(this);
		this.pending = "kill";
		return nil;
	}

	@define statunix()
	{
		checkdead();
		return mux.statunix(this);
	}

	@define statwin()
	{
		checkdead();
		return mux.statwin(this);
	}

	@define snap()
	{
		checkdead();
		return mux.snap(this);
	}

	@define trace(event, fn)
	{
		checkdead();
		callbacks[(ctlmux`Event)event] = fn;
		if(fn == nil)
			return mux.trace(this, event|ctlmux`Eclear);
		else
			return mux.trace(this, event|ctlmux`Eset);
	}

	@define trapset(addr, fn, mode)
	{
		@local tid, bp, kind;
		checkdead();
		bp = mux.settrap(this, mode, addr);
		switch(mode){
		case ctlmux`Mbrk:
			kind = "brk";
			break;
		case ctlmux`Msnap:
			kind = "snap";
			break;
		default:
			error("unknown trap mode: %e", mode);
		}
		tid = traps.add(bp, fn, [kind, addr], nil);
		return tid;
	}

	@define xtrap(addr, fn)
	{
		checkdead();
		return trapset(addr, fn, ctlmux`Mbrk);
	}

	@define xsnap(addr, fn)
	{
		checkdead();
		return trapset(addr, fn, ctlmux`Msnap);
	}

	@define xtraps()
	{
		checkdead();
		return traps.list();
	}

	@define trapdel(tid)
	{
		@local trap;
		/* FIXME: this api sucks */
		checkdead();
		trap = traps.lookuid(tid);
		traps.clr(tid);
		mux.clrtrap(this, trap.mid);
		return nil;
	}

	@define trapreset()
	{
		checkdead();
		traps.reset();
		return nil;
	}

	@define unwind()
	{
		checkdead();
		mux.unwind(id, _reg);
	}

	@define localns(ctx)
	{
		@local lt, ls, et, es, la, ns;
		@local sym;

		sym = locals(ctx);
		if(sym == nil)
			return nil;
		ns = xns();

		@define lt(this, tn)
		{
			return ns.looktype(tn);
		}

		@define et(this)
		{
			return ns.enumtype();
		}

		@define ls(this, name)
		{
			@local s;
			s = sym[name];
			if(s != nil)
				return s;
			return ns.looksym(name);
		}
		
		@define es(this)
		{
			@local ss;
			ss = ns.enumsym();
			foreach(@lambda(id, s){
					ss[id] = s;
				}, sym);
			return ss;
		}

		@define la(this, a)
		{
			/* locals are not code, so just go to ns */
			return ns.lookaddr(a);
		}

		return mkns([ "looktype" : lt,
			      "enumtype" : et,
			      "looksym"  : ls,
			      "enumsym"  : es,
			      "lookaddr" : la ]);
	}

	@define locals(ctx)
	{
		@local ns, sym, ls;

		sym = [:];
		ls = mux.enumloc(id, ctx);
		if(ls == nil)
			return sym;
		ns = xns();
		foreach(@lambda(s){
				sym[s.id] = mksym(looktype(ns, s.type),
						  mkcid(s.id),
						  s.loc);
			}, ls);
		return sym;
	}

	@define setreg(r)
	{
		_reg = r;
	}

	@define reg()
	{
		checkdead();
		return _reg;
	}

	@define xns(path ...)
	{
		@local st, id, ns;
		if(path == [])
			path = nil;
		else
			path = path[0];
		if(thisns != nil)
			return thisns;
		st = mux.statunix(this);
		id = nil;
		if(path)
			foreach(@lambda(dll){
					if(strstr(dll.path, path))
						id = dll.id;
				}, st[1]);
			else
				foreach(@lambda(dll){
						if(dll.base == 0)
							id = dll.id;
					}, st[1]);
		if(id == nil)
			return nil;
		ns = mux.nsinit(id);
		thisns = ns;
		return ns;
	}

	@defloc flushns()
	{
		thisns = nil;
	}

	@define mem()
	{
		@local map, get, put, dispatch, ismapped, ctl, id;

		@define get(as, r)
		{
			return mux.pread(this, rangebeg(r), rangelen(r));
		}

		@define put(as, r, s)
		{
			return mux.pwrite(this, rangebeg(r), rangelen(r), s);
		}

		// FIXME: WORKS ONLY FOR UNIX
		@define map(as)
		{
			@local n, rs, i, rv;

			rs = mux.statunix(this)[0];
			n = length(rs);
			rv = mkvec(n);
			for(i = 0; i < n; i++)
				rv[i] = mkrange(rs[i].addr,
						rs[i].addr+rs[i].len);
			return rv;
		}

		/* FIXME: this and map should not call stat every time */
		@define ismapped(as, r)
		{
			return isrinr(r, map(as));
		}

		@define ctl(as)
		{
			return this;
		}


		@define id(as)
		{
			return this.id;
		}

		// redirect unknown calls to ctl
		@define dispatch(arg ...)
		{
			@local name, f, rv;
			pop(arg);
			name = pop(arg);

			// this is not cool.
			f = rdgettab(rdof(this))[mkcid(name)](this);

			rv = apply(f, arg);
			return rv;
		}

		checkdead();
		return mkas([ "get"       : get,
			      "put"       : put,
			      "map"       : map,
			      "ismapped"  : ismapped,
			      "ctl"       : ctl,
			      "id"	  : id,
			      "dispatch"  : dispatch,
			    ]);
	}



	thisns = nil;
	this = ctlrec(id, xstop, xcont, xstep, detach, kill, snap,
		      mem, xns, flushns, reg, statunix, statwin,
		      setreg, trace, xtrap, xsnap,
		      xtraps, trapdel, trapreset, unwind, localns, locals,
		      // begin private
		      state, traps, callbacks, nil);
	return this;
}

@record muxrec {
	ps,
	launch,
	attach,
	run,
	runtil,
	settimer,
	close,
	abort,
	looksym,
	enumsym,
	lookaddr,
	looktype,
	enumtype,
	enumseg,
	enumloc,
	unwind,
	names,
	nsinit,
	// private
	stop,
	cont,
	step,
	detach,
	kill,
	statunix,
	statwin,
	snap,
	pread,
	pwrite,
	trace,
	settrap,
	clrtrap,
};

@define mkctlmux_local()
{
	@local fds, fd;
//	fds = popen("mygrind", "sctl", "-c", 2|4|8);
	fds = popen("sctl", "-c", 2|4|8);
	fd = fds[0];
	finalize(fd, @lambda(fd) { close(fd); });
	return mkctlmux(fds[0]);
}

@define mkctlmux_remote(address)
{
	@local fd;
	fd = tcpopen(address);
	finalize(fd, @lambda(fd) { close(fd); });
	return mkctlmux(fd);
}

@define mkctlmux(fd)
{
	@local launch, attach, run, muxclose, abort;
	@local verbose;
	@local checkreply, checkreplyio, ctls;
	@local freetags, nexttag, taghandler, mux;
	@local stop, step, detach, kill, statwin, statunix, snap;
	@local pread, pwrite;
	@local trace, fmtmsg, buf2msg;
	@local settrap, clrtrap;
	@local aborted, version, ps;
	@local osversion;
	@local muxlooksym, muxenumsym, muxlookaddr;
	@local muxlooktype, muxenumtype, muxenumseg;
	@local muxenumloc, muxunwind, muxunwind1;
	@local muxnames, nsinit;
	@local contasync;
	@local timerfn, tfd;

	verbose = 0;
	aborted = 0;
	nexttag = 0;
	freetags = [ ];
	ctls = [:];
	taghandler = [:];
	timerfn = nil;

	@defloc freshtag()
	{
		if(isempty(freetags))
			return nexttag++;
		return pop(freetags);
	}

	@defloc reusetag(tag)
	{
		push(freetags, tag);
	}

	@defloc log(arg ...)
	{
		if(verbose){
			apply(printf, arg);
			printf("\n");
		}
	}

	@defloc cop(p)
	{
		return {@typeof(p)}getbytes(p);
	}

	@define checkreply(rep, op)
	{
		if(op == rep->op)
			return;
		switch(rep->op){
		case ctlmux`Rerror:
			error("ctlmux: while waiting for %e: %s",
			      op, rep->bytes);
		default:
			error("ctlmux: while waiting for %e: received %e",
			      op, (enum ctlmux`Mkind)rep->op);
		}
	}

	@define checkreplyio(rep, op, x)
	{
		switch(rep->op){
		case op:
			break;
		case ctlmux`Rerror:
			return x(rep->bytes);
			break;
		default:
			error("ctlmux: while waiting for %e: received %e",
			      op, (enum ctlmux`Mkind)rep->op);
		}
	}

	@define fmtmsg(msg)
	{
		return sprintfa("%e %d", (enum ctlmux`Mkind)msg->op, msg->id);
	}

	@define buf2msg(p)
	{
		@local op;
		op = (enum ctlmux`Mkind)*(ctlmux`uint8*)p;
		switch(op){
		case ctlmux`Aevent:
			return (ctlmux`Aevent*)p;
		case ctlmux`Rerror:
			return (ctlmux`Rerror*)p;
		case ctlmux`Tversion:
			return (ctlmux`Tversion*)p;
		case ctlmux`Rversion:
			return (ctlmux`Rversion*)p;
		case ctlmux`Tps:
			return (ctlmux`Tps*)p;
		case ctlmux`Rps:
			return (ctlmux`Rps*)p;
		case ctlmux`Tlaunch:
			return (ctlmux`Tlaunch*)p;
		case ctlmux`Rlaunch:
			return (ctlmux`Rlaunch*)p;
		case ctlmux`Tcont:
			return (ctlmux`Tcont*)p;
		case ctlmux`Rcont:
			return (ctlmux`Rcont*)p;
		case ctlmux`Tstop:
			return (ctlmux`Tstop*)p;
		case ctlmux`Rstop:
			return (ctlmux`Rstop*)p;
		case ctlmux`Tkill:
			return (ctlmux`Tkill*)p;
		case ctlmux`Rkill:
			return (ctlmux`Rkill*)p;
		case ctlmux`Tdetach:
			return (ctlmux`Tdetach*)p;
		case ctlmux`Rdetach:
			return (ctlmux`Rdetach*)p;
		case ctlmux`Tsettrap:
			return (ctlmux`Tsettrap*)p;
		case ctlmux`Rsettrap:
			return (ctlmux`Rsettrap*)p;
		case ctlmux`Tclrtrap:
			return (ctlmux`Tclrtrap*)p;
		case ctlmux`Rclrtrap:
			return (ctlmux`Rclrtrap*)p;
		case ctlmux`Tread:
			return (ctlmux`Tread*)p;
		case ctlmux`Rread:
			return (ctlmux`Rread*)p;
		case ctlmux`Tsnap:
			return (ctlmux`Tsnap*)p;
		case ctlmux`Rsnap:
			return (ctlmux`Rsnap*)p;
		case ctlmux`Twrite:
			return (ctlmux`Twrite*)p;
		case ctlmux`Rwrite:
			return (ctlmux`Rwrite*)p;
		case ctlmux`Tgetctx:
			return (ctlmux`Tgetctx*)p;
		case ctlmux`Rgetctx:
			return (ctlmux`Rgetctx*)p;
		case ctlmux`Tsetctx:
			return (ctlmux`Tsetctx*)p;
		case ctlmux`Rsetctx:
			return (ctlmux`Rsetctx*)p;
		case ctlmux`Tattach:
			return (ctlmux`Tattach*)p;
		case ctlmux`Rattach:
			return (ctlmux`Rattach*)p;
		case ctlmux`Tping:
			return (ctlmux`Tping*)p;
		case ctlmux`Rping:
			return (ctlmux`Rping*)p;
		case ctlmux`Tstep:
			return (ctlmux`Tstep*)p;
		case ctlmux`Rstep:
			return (ctlmux`Rstep*)p;
		case ctlmux`Ttrace:
			return (ctlmux`Ttrace*)p;
		case ctlmux`Rtrace:
			return (ctlmux`Rtrace*)p;
		case ctlmux`Tstat:
			return (ctlmux`Tstat*)p;
		case ctlmux`Rstat:
			return (ctlmux`Rstat*)p;
		case ctlmux`Tlooksym:
			return (ctlmux`Tlooksym*)p;
		case ctlmux`Rlooksym:
			return (ctlmux`Rlooksym*)p;
		case ctlmux`Tenumsym:
			return (ctlmux`Tenumsym*)p;
		case ctlmux`Renumsym:
			return (ctlmux`Renumsym*)p;
		case ctlmux`Tenumtype:
			return (ctlmux`Tenumtype*)p;
		case ctlmux`Renumtype:
			return (ctlmux`Renumtype*)p;
		case ctlmux`Tunwind:
			return (ctlmux`Tunwind*)p;
		case ctlmux`Runwind:
			return (ctlmux`Runwind*)p;
		case ctlmux`Tunwind1:
			return (ctlmux`Tunwind1*)p;
		case ctlmux`Runwind1:
			return (ctlmux`Runwind1*)p;
		case ctlmux`Tnames:
			return (ctlmux`Tnames*)p;
		case ctlmux`Rnames:
			return (ctlmux`Rnames*)p;
		case ctlmux`Tlooktype:
			return (ctlmux`Tlooktype*)p;
		case ctlmux`Rlooktype:
			return (ctlmux`Rlooktype*)p;
		case ctlmux`Tlookaddr:
			return (ctlmux`Tlookaddr*)p;
		case ctlmux`Rlookaddr:
			return (ctlmux`Rlookaddr*)p;
		case ctlmux`Tenumloc:
			return (ctlmux`Tenumloc*)p;
		case ctlmux`Renumloc:
			return (ctlmux`Renumloc*)p;
		case ctlmux`Tenumseg:
			return (ctlmux`Tenumseg*)p;
		case ctlmux`Renumseg:
			return (ctlmux`Renumseg*)p;
		default:
			error("unknown op %e", op);
		}
	}

	@defloc isasync(msg)
	{
		switch((enum ctlmux`Mkind)msg->op){
		case ctlmux`Aevent:
			return 1;
		default:
			return 0;
		}
	}

	@defloc sendmsg(fd, arg ...)
	{
		@local p, sz;
		p = arg[0];
		switch(length(arg)){
		case 1:
			sz = sizeof(*p);
			break;
		case 2:
			sz = arg[1];
			break;
		default:
			error("bad sendmsg");
		}
		write(fd, cval2str((ctlmux`uint64)sz));
		write(fd, getbytes(p, sz));
	}

	@defloc handleasync(msg, dat)
	{
		@local ctl, newctl, trap, ev, fn, docall;
		@local p, sz, base, path;
		ctl = ctls[msg->id];
		if(ctl == nil)
			error("%e:%e for unknown process id: %d",
			      (enum ctlmux`Mkind)msg->op,
			      (ctlmux`Event)msg->flags,
			      msg->id);
		if((enum ctlmux`Mkind)msg->op != ctlmux`Aevent)
			error("ctlmux: unhandled message %e",
			      (enum ctlmux`Mkind)msg->op);

		@define docall(ctls, thunk)
		{
			foreach(@lambda(ctl){
					ctl.pending = "run";
				}, ctls);
			thunk();
			foreach(@lambda(ctl){
					@local p;
					p = ctl.pending;
					ctl.pending = nil;
					// FIXME: do all of these async
					// to avoid stack explosion
					switch(p){
					case "run":
						contasync(ctl);
						break;
					case "stop":
						/* already stopped */
						break;
					case "kill":
						mux.kill(ctl);
						break;
					case "step":
						mux.step(ctl);
						break;
					case "detach":
						mux.detach(ctl);
						break;
					default:
						error("unexpected pending %a",
						      p);
					}
				}, ctls);
		}

		ev = (ctlmux`Event)msg->flags;
		switch(ev){
		case ctlmux`Etrap:
			dat = (ctlmux`Etrap*)dat;
			trap = ctl.traps.look(dat->tid);
			if(trap == nil)
				error("ctl %d has no trap for tid %d",
				      ctl.id, dat->tid);
			ctl.state = ctlmux`Stopped;
			ctl.setreg(cop(&dat->ctx));
			docall([ctl], @lambda() { trap.fn(ctl); });
			break;
		case ctlmux`Esnap:
			dat = (ctlmux`Esnap*)dat;
			trap = ctl.traps.look(dat->tid);
			if(trap == nil)
				error("ctl %d has no trap for tid %d",
				      ctl.id, dat->tid);
			newctl = mkctl(mux,
				       dat->cid,
				       ctlmux`Stopped,
				       cop(&dat->ctx),
				       ctl.traps.copy(),
				       ctl.callbacks);
			ctls[dat->cid] = newctl;
			docall([ctl], /* no control of newctl */
			       @lambda() { trap.fn(ctl, newctl); });
			break;
		case ctlmux`Eclone:
		case ctlmux`Efork:
			dat = (ctlmux`Efork*)dat;
			log("task %d has %s %d",
			    msg->id,
			    ev == ctlmux`Eclone ? "cloned" : "forked",
			    dat->cid);
			if(osversion != "x86-win-2010")
				// Windows does not stop the spawning thread
				ctl.state = ctlmux`Stopped;
			ctl.setreg(cop(&dat->ctx));
			newctl = mkctl(mux,
				       dat->cid,
				       ctlmux`Stopped,
				       cop(&dat->cctx),
				       ctl.traps.copy(),
				       copy(ctl.callbacks));
			ctls[dat->cid] = newctl;
			fn = ctl.callbacks[ev];
			if(fn != nil)
				docall([ctl, newctl],
				       @lambda() { fn(ctl, newctl); });
			else{
				contasync(ctl);
				contasync(newctl);
			}
			break;
		case ctlmux`Eexit:
			log("task %d has died", msg->id);
			ctl.state = ctlmux`Dead;
			fn = ctl.callbacks[ev];
			if(fn != nil)
				// it's dead: nothing to control with docall
				fn(ctl);
			tabdelete(ctls, msg->id);
			break;
		case ctlmux`Eexec:
			dat = (ctlmux`Eexec*)dat;
			ctl.state = ctlmux`Stopped;
//			ctl.setreg(cop(&dat->ctx));
			ctl.flushns();
			log("task %d has called exec", msg->id);
			fn = ctl.callbacks[ev];
			if(fn != nil)
				docall([ctl], @lambda() { fn(ctl); });
			else
				contasync(ctl);
			break;
		case ctlmux`Esyscall:
			dat = (ctlmux`Esyscall*)dat;
			ctl.state = ctlmux`Stopped;
			ctl.setreg(cop(&dat->ctx));
			log("task %d has hit a system call trap (%e)",
			    msg->id,
			    (linuxns`Syscall)dat->ctx.orig_rax);
			fn = ctl.callbacks[ev];
			if(fn != nil)
				docall([ctl], @lambda() { fn(ctl); });
			else
				contasync(ctl);
			break;
		case ctlmux`Esignal:
			dat = (ctlmux`Esignal*)dat;
			ctl.state = ctlmux`Stopped;
			ctl.setreg(cop(&dat->ctx));
			fn = ctl.callbacks[ev];
			if(fn != nil)
				docall([ctl],
				       @lambda() {
					       fn(ctl, dat->ctx.sig);
				       });
			else
				contasync(ctl);
			break;
		case ctlmux`Eload:
		case ctlmux`Eunload:
			p = (ctlmux`uint64*)dat;
			sz = *p++;
			path = getbytes(p, sz);
			p = (ctlmux`char*)p+sz;
			p = (ctlmux`uint64*)p;
			base = *p++;
			p = (ctlmux`Ctx*)p;
			ctl.setreg(cop(p));
			p++;
			ctl.state = ctlmux`Stopped;
			fn = ctl.callbacks[ev];
			if(fn != nil)
				docall([ctl],
				       @lambda() {
					       fn(ctl, path, base);
				       });
			else
				contasync(ctl);
			break;
		default:
			error("unhandled event message: %e",
			      (ctlmux`Event)msg->flags);
 		}
	}

	@defloc noctls()
	{
//		printf("noctls %a\n", map(@lambda(c,v){ decodeid(v.id); }, ctls));
		return length(ctls) == 0;
	}

	@defloc noinflight()
	{
		return length(taghandler) == 0;
	}

	@defloc settimer(freq, fn){
		@local sec, msec;
		@global timerfd_create, timerfd_settime; /* may be undefined */
		timerfn = fn;
		if(fn != nil){
			tfd = timerfd_create(linux`CLOCK_REALTIME, 0);
			sec = freq/1000;
			msec = freq%1000;
			timerfd_settime(tfd, 0,
					[ sec, msec*1000000UL,
					  sec, msec*1000000UL ]);
			timerfn();
		}else if(isfd(tfd)){
			close(tfd);
			tfd = nil;
		}
	}

	@defloc dotimer()
	{
		read(tfd, 8);
		timerfn();
	}

	@defloc runtil(pred)
	{
		@local s, sz, p, msg, h, tag, dat;

		while(!aborted && !pred()){
			if(noinflight() && noctls())
				error("runtil: nothing to do");
			if(timerfn == nil){
				s = read(fd, sizeof(ctlmux`uint64));
				if(s == nil)
					error("remote sctl hung up");
			}else{
				@local rs;
				[rs, _, _] = select([fd, tfd], [], []);
				if(ismember(rs, tfd))
					dotimer();
				if(!ismember(rs, fd))
					continue;
				s = read(fd, sizeof(ctlmux`uint64));
			}
			sz = *(ctlmux`uint64*)s;
			p = read(fd, sz);
			msg = buf2msg(p);
			if(sz > sizeof(*msg))
				dat = getbytes(msg+1, sz-sizeof(*msg));
			else
				dat = "";
			if(isasync(msg)){
				handleasync(msg, dat);
				continue;
			}
			tag = msg->tag;
			h = taghandler[tag];
			tabdelete(taghandler, tag);
			reusetag(tag);
			if(h == nil){
				log("unhandled tag %d: %s", tag, fmtmsg(msg));
				continue;
			}
			h(msg, dat);
		}
	}

	@defloc runtiltag(tag)
	{
		@local done, msg, dat;
		msg = nil;
		done = 0;
		taghandler[tag] = @lambda(m, d) { msg = m; dat = d; done = 1; };
		runtil(@lambda(){ done; });
		return [msg, dat];
	}

	@define clrtrap(ctl, tid)
	{
		@local p, rep;
		p = (ctlmux`Tclrtrap*)malloc(sizeof(ctlmux`Tclrtrap));
		p->op = ctlmux`Tclrtrap;
		p->tag = freshtag();
		p->id = ctl.id;
		p->tid = tid;
		sendmsg(fd, p);
		[rep, _] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rclrtrap);
		return nil;
	}

	@define settrap(ctl, mode, addr)
	{
		@local p, rep, sz, q;
		sz = sizeof(ctlmux`Tsettrap)+2*sizeof(ctlmux`uint64);
		p = (ctlmux`Tsettrap*)malloc(sz);
		p->op = ctlmux`Tsettrap;
		p->tag = freshtag();
		p->id = ctl.id;
		q = (ctlmux`uint64*)(p+1);
		*q++ = mode;
		*q++ = addr;
		sendmsg(fd, p, sz);
		[rep, _] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rsettrap);
		return rep->tid;
	}

	@define trace(ctl, flags)
	{
		@local p, rep, sz, q;

		sz = sizeof(ctlmux`Ttrace)+sizeof(ctlmux`uint64);
		p = (ctlmux`Ttrace*)malloc(sz);
		p->op = ctlmux`Ttrace;
		p->tag = freshtag();
		p->id = ctl.id;
		q = (ctlmux`uint64*)(p+1);
		*q++ = flags;
		sendmsg(fd, p, sz);
		[rep, _] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rtrace);
	}

	@define pread(ctl, addr, cnt)
	{
		@local p, rep, dat;

		p = (ctlmux`Tread*)malloc(sizeof(ctlmux`Tread));
		p->op = ctlmux`Tread;
		p->tag = freshtag();
		p->id = ctl.id;
		p->fd = -1;
		p->addr = addr;
		p->cnt = cnt;
		sendmsg(fd, p);

		[rep, dat] = runtiltag(p->tag);
		checkreplyio(rep, ctlmux`Rread,
			     @lambda(err){
				     error("read fault 0x%p-0x%p (%s)",
					   (void*)addr, (void*)addr+cnt, err);
			     });
		return dat;
	}

	@define pwrite(ctl, addr, cnt, bytes)
	{
		@local sz, p, rep;

		sz = sizeof(ctlmux`Twrite)+cnt;
		p = (ctlmux`Twrite*)malloc(sz);
		p->op = ctlmux`Twrite;
		p->tag = freshtag();
		p->id = ctl.id;
		p->fd = -1;
		p->addr = addr;
		putbytes(p+1, bytes);
		sendmsg(fd, p, sz);

		[rep, _] = runtiltag(p->tag);
		checkreplyio(rep, ctlmux`Rwrite,
			     @lambda(err){
				     error("write fault 0x%p - 0x%p (%s)",
					   (void*)addr, (void*)addr+cnt, err);
			     });
		return nil;
	}

	// WINDOWS ONLY
	@define statwin(ctl)
	{
		@local p, rep, dat, q, i, m, sz;
		@local id, st, threads, libs, path, base;

		p = (ctlmux`Tstat*)malloc(sizeof(ctlmux`Tstat));
		p->op = ctlmux`Tstat;
		p->tag = freshtag();
		p->id = ctl.id;
		sendmsg(fd, p);

		[rep, dat] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rstat);

		q = (ctlmux`uint32*)dat;
		st = *q++;

		libs = [];
		q = (ctlmux`uint64*)q;
		m = *q++;
		for(i = 0; i < m; i++){
			sz = *q++;
			path = getbytes(q, sz);
			q = (ctlmux`uint64*)((char*)q+sz);
			base = *q++;
			append(libs, dll(-1, path, base));
		}

		threads = [];
		q = (ctlmux`uint64*)q;
		m = *q++;
		for(i = 0; i < m; i++){
			q = (ctlmux`uint64*)q;
			id = *q++;
			q = (ctlmux`uint32*)q;
			st = *q++;
//			pid = id>>32;
//			tid = (id<<32)>>32;
			if(ctls[id] == nil)
				ctls[id] = mkctl(mux,
						 id,
						 (enum ctlmux`State)st,
						 ((ctlmux`Ctx*)
						  malloc(sizeof(ctlmux`Ctx))),
						 ctl.traps.copy(),
						 copy(ctl.callbacks));
			append(threads, ctls[id]);
		}

		return [libs,threads];
	}

	@define statunix(ctl)
	{
		@local p, rep, dat, q, i, m, sz, rs, file, addr, len, flags;
		@local bs, base, id;

		p = (ctlmux`Tstat*)malloc(sizeof(ctlmux`Tstat));
		p->op = ctlmux`Tstat;
		p->tag = freshtag();
		p->id = ctl.id;
		sendmsg(fd, p);

		[rep, dat] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rstat);

		q = (ctlmux`uint64*)dat;
		q++; /* skip pid */

		// regions (unused)
		rs = [];
		m = *q++;
		for(i = 0; i < m; i++){
			sz = *q++;
			file = getbytes(q, sz);
			q = (ctlmux`uint64*)((char*)q+sz);
			addr = *q++;
			len = *q++;
			flags = *q++;
			append(rs, region(file, addr, len, flags));
		}

		// bins
		bs = [];
		m = *q++;
		for(i = 0; i < m; i++){
			id = *q++;
			base = *q++;
			sz = *q++;
			file = getbytes(q, sz);
			q = (ctlmux`uint64*)((char*)q+sz);
			append(bs, dll(id, file, base));
		}

		return [rs,bs];
	}

	@define contasync(ctl)
	{
		@local p;

		if(ctl.state != ctlmux`Stopped)
			return;
		p = (ctlmux`Tcont*)malloc(sizeof(ctlmux`Tcont));
		p->op = ctlmux`Tcont;
		p->tag = freshtag();
		p->id = ctl.id;
		sendmsg(fd, p);

		ctl.state = ctlmux`Requestedrun;

		taghandler[p->tag] = @lambda(rep, dat){
			checkreply(rep, ctlmux`Rcont);
			ctl.state = ctlmux`Running;
		};
	}

	@defloc cont(ctl)
	{
		@local p, rep;

		if(ctl.state != ctlmux`Stopped)
			return;
		p = (ctlmux`Tcont*)malloc(sizeof(ctlmux`Tcont));
		p->op = ctlmux`Tcont;
		p->tag = freshtag();
		p->id = ctl.id;
		sendmsg(fd, p);

		[rep, _] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rcont);
		ctl.state = ctlmux`Running;
		return nil;
	}

	@define stop(ctl)
	{
		@local p, rep;

		if(ctl.state != ctlmux`Running
		   && ctl.state != ctlmux`Requestedrun)
			return;
		p = (ctlmux`Tstop*)malloc(sizeof(ctlmux`Tstop));
		p->op = ctlmux`Tstop;
		p->tag = freshtag();
		p->id = ctl.id;
		sendmsg(fd, p);

		/* FIXME: consume registers */
		[rep, _] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rstop);
		ctl.setreg(cop(&rep->ctx));
		ctl.state = ctlmux`Stopped;
		return nil;
	}

	@define step(ctl)
	{
		@local p, rep;

		if(ctl.state != ctlmux`Stopped)
			error("attempt to step running ctl");
		p = (ctlmux`Tstep*)malloc(sizeof(ctlmux`Tstep));
		p->op = ctlmux`Tstep;
		p->tag = freshtag();
		p->id = ctl.id;
		sendmsg(fd, p);

		[rep, _] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rstep);
		ctl.setreg(cop(&rep->ctx));
		return nil;
	}

	@define detach(ctl)
	{
		@local p, rep;

		p = (ctlmux`Tdetach*)malloc(sizeof(ctlmux`Tdetach));
		p->op = ctlmux`Tdetach;
		p->tag = freshtag();
		p->id = ctl.id;
		sendmsg(fd, p);

		[rep, _] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rdetach);
		ctl.state = ctlmux`Dead;
		log("task %d has detached", ctl.id);
		tabdelete(ctls, ctl.id);
	}

	@define kill(ctl)
	{
		@local p, rep;

		p = (ctlmux`Tkill*)malloc(sizeof(ctlmux`Tkill));
		p->op = ctlmux`Tkill;
		p->tag = freshtag();
		p->id = ctl.id;
		sendmsg(fd, p);

		[rep, _] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rkill);
		tabdelete(ctls, ctl.id);
		return nil;
	}

	@define snap(ctl)
	{
		@local p, rep, newctl;

		p = (ctlmux`Tsnap*)malloc(sizeof(ctlmux`Tsnap));
		p->op = ctlmux`Tsnap;
		p->tag = freshtag();
		p->id = ctl.id;
		sendmsg(fd, p);

		[rep, _] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rsnap);
		newctl = mkctl(mux,
			       rep->cid,
			       ctlmux`Stopped,
			       cop(&rep->ctx),
			       ctl.traps.copy(),
			       copy(ctl.callbacks));
		ctls[rep->cid] = newctl;
		finalize(newctl, @lambda(ctl) { ctl.kill(); });
		return newctl;
	}

	@define launch(args, flags)
	{
		@local narg, s, sz, i, p, q, ctl, rep;

		narg = length(args);
		if(narg == 0)
			error("mkpras: launch: empty command");
		if(flags == nil)
			flags = 0;

		/* format and send Tlaunch */
		sz = sizeof(ctlmux`Tlaunch);
		sz += sizeof(ctlmux`uint64); /* flags */
		sz += sizeof(ctlmux`uint64); /* narg */
		for(i = 0; i < narg; i++)
			sz += sizeof(ctlmux`uint64)+strlen(args[i]);
		p = (ctlmux`Tlaunch*)malloc(sz);
		p->op = ctlmux`Tlaunch;
		p->tag = freshtag();
		q = (ctlmux`uint64*)(p+1);
		*q++ = flags;
		*q++ = narg;
		for(i = 0; i < narg; i++){
			s = args[i];
			q = (ctlmux`uint64*)q;
			*q++ = strlen(s);
			q = (char*)q;
			putbytes(q, s);
			q += strlen(s);
		}
		sendmsg(fd, p, sz);

		/* wait for reply */
		[rep, _] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rlaunch);
		ctl = mkctl(mux,
			    rep->id,
			    ctlmux`Stopped,
			    (ctlmux`Ctx*)cop(&rep->ctx),
			    mktrapman(),
			    [ : ]);
		ctls[rep->id] = ctl;
		return ctl;
	}

	@define attach(pid)
	{
		@local p, rep, ctl;

		p = (ctlmux`Tattach*)malloc(sizeof(ctlmux`Tattach));
		p->op = ctlmux`Tattach;
		p->tag = freshtag();
		p->id = pid;
		sendmsg(fd, p);

		[rep, _] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rattach);
		ctl = mkctl(mux,
			    rep->id,
			    ctlmux`Stopped,
			    (ctlmux`Ctx*)cop(&rep->ctx),
			    mktrapman(),
			    [ : ]);
		ctls[rep->id] = ctl;
		return ctl;
	}

	@defloc encodetype(t)
	{
		@local sz, s, q, id;

		sz = sizeof(ctlmux`uint8); /* op */
		if(isbase(t)){
			sz += sizeof(ctlmux`uint8); /* base */
			s = malloc(sz);
			s[0] = ctlmux`Tbase;
			// baseid returns the cbasename strings.
			// FIXME: this conversion is unfortunate.
			s[1] = (ctlmux`uint8)basebase(t);
		}else if(issu(t) || isenum(t)){
			id = cid2str(suetag(t));
			sz += sizeof(ctlmux`uint64)+strlen(id); /* tag */
			s = malloc(sz);
			if(isstruct(t))
				s[0] = ctlmux`Tstruct;
			else if(isunion(t))
				s[0] = ctlmux`Tunion;
			else if(isenum(t))
				s[0] = ctlmux`Tenum;
			else
				error("bug");
			q = (ctlmux`uint64*)(s+1);
			*q++ = strlen(id);
			q = (char*)q;
			putbytes(q, id);
		}else if(istypedef(t)){
			id = cid2str(typedefid(t));
			sz += sizeof(ctlmux`uint64)+strlen(id); /* tid */
			s = malloc(sz);
			s[0] = ctlmux`Ttypedef;
			q = (ctlmux`uint64*)(s+1);
			*q++ = strlen(id);
			q = (char*)q;
			putbytes(q, id);
		}else
			error("encodetype: unsupported type: %t", t);
		return getbytes(s, sz);
	}

	@defloc decodetname(q)
	{
		@local k, cb, id, gets, w, pos, st, n, v, i, sid, pt, at;
		@local tq; 	/* FIXME: unnecessary in bleed */

		@define gets()
		{
			@local sz, s;
			q = (ctlmux`uint64*)q;
			sz = *q++;
			s = getbytes(q, sz);
			q = (ctlmux`uint8*)((char*)q+sz);
			return s;
		}

		q = (ctlmux`uint8*)q;
		k = *q++;
		switch(k){
		case ctlmux`Tbase:
			cb = *q++;
			return [mkctype_base(cb), q];
		case ctlmux`Tstruct:
			id = mkcid(gets());
			return [mkctype_struct(id), q];
		case ctlmux`Tunion:
			id = mkcid(gets());
			return [mkctype_union(id), q];
		case ctlmux`Tenum:
			id = mkcid(gets());
			return [mkctype_enum(id), q];
		case ctlmux`Ttypedef:
			id = mkcid(gets());
			return [mkctype_typedef(id), q];
		case ctlmux`Tptr:
			[st,tq] = decodetname(q);
			q = tq;
			return [mkctype_ptr(st), q];
		case ctlmux`Tconst:
			[st,tq] = decodetname(q);
			q = tq;
			return [mkctype_const(st), q];
		case ctlmux`Tarr:
			q = (ctlmux`uint64*)q;
			n = *q++;
			[st,tq] = decodetname(q);
			q = tq;
			return [mkctype_array(st, n), q];
		case ctlmux`Tfun:
			[st,tq] = decodetname(q);
			q = tq;
			q = (ctlmux`uint64*)q;
			n = *q++;
			v = mkvec(n);
			for(i = 0; i < n; i++){
				[at, q] = decodeattrs(q);
				sid = gets();
				[pt,tq] = decodetname(q);
				q = tq;
				v[i] = mkparam(pt,
					       (strlen(sid) > 0
						? mkcid(sid) : nil),
					       at);
			}
			return [mkctype_fn(st, v), q];
		case ctlmux`Tbitfield:
			q = (ctlmux`uint8*)q;
			w = *q++;
			pos = *q++;
			[st,tq] = decodetname(q);
			q = tq;
			return [mkctype_bitfield(st, w, pos), q];
		default:
			error("decodetname: unhandled case %d", k);
		}
	}

	@defloc decodeattrs(p)
	{
		@local tab, na, i, k, v;

		@defloc decodes(p)
		{
			error("implement me");
		}

		@defloc decodev(p)
		{
			@local e, v;
			p = (uint8*)p;
			e = *p++;
			switch(e){
			case ctlmux`Auint:
				p = (uint64*)p;
				v = *p++;
				return [v, p];
			case ctlmux`Astr:
				return decodes(p);
			case ctlmux`Acid:
				[v, p] = decodes(p);
				return [mkcid(v), p];
			default:
				error("unrecognized attribute value type: %d",
				      e);
			}
		}

		tab = [:];
		p = (uint64*)p;
		na = *p++;
		for(i = 0; i < na; i++){
			[k, p] = decodev(p);
			[v, p] = decodev(p);
			tab[k] = v;
		}
		return [tab, p];
	}

	@defloc decodetdef(ns, q)
	{
		@local k, cb, rep, sz, n, i, v, id, sid, c, off, mk, st, pt;
		@local at, fat;
		@local w, pos;
		@local gets;
		@local tq; 	/* FIXME: unnecessary in bleed */

		@define gets()
		{
			@local sz, s;
			q = (ctlmux`uint64*)q;
			sz = *q++;
			s = getbytes(q, sz);
			q = (ctlmux`uint8*)((char*)q+sz);
			return s;
		}

		q = (ctlmux`uint8*)q;
		k = *q++;
		switch(k){
		case ctlmux`Tbase:
			cb = *q++;
			rep = *q++;
			return [mkctype_base(cb, rep), q];
		case ctlmux`Tstruct:
		case ctlmux`Tunion:
			if(k == ctlmux`Tstruct)
				mk = mkctype_struct;
			else
				mk = mkctype_union;
			id = mkcid(gets());
			q = (ctlmux`uint64*)q;
			sz = *q++;
			[at, q] = decodeattrs(q);
			n = *q++;
			v = mkvec(n);
			for(i = 0; i < n; i++){
				q = (ctlmux`uint64*)q;
				off = *q++;
				[fat, q] = decodeattrs(q);
				sid = mkcid(gets());
				[st,tq] = decodetname(q);
				q = tq;
				fat["offset"] = off;
				v[i] = mkfield(st, sid, fat);
			}
			at["offset"] = sz;
			return [mk(id, v, at), q];
		case ctlmux`Tenum:
			id = mkcid(gets());
			q = (ctlmux`uint8*)q;
			rep = *q++;
			q = (ctlmux`uint64*)q;
			n = *q++;
			st = nsreptype(ns, rep);
			if(st == nil)
				error("no base type for rep %d", rep);
			v = mkvec(n);
			for(i = 0; i < n; i++){
				sid = mkcid(gets());
				q = (ctlmux`uint64*)q;
				c = *q++;
				v[i] = vector(sid, {st}c);
			}
			return [mkctype_enum(id, v, st), q];
		case ctlmux`Tptr:
			[st,tq] = decodetname(q);
			q = tq;
			return [mkctype_ptr(st, nsptr(ns)), q];
		case ctlmux`Tconst:
			[st,tq] = decodetname(q);
			q = tq;
			return [mkctype_const(st), q];
		case ctlmux`Tarr:
			q = (ctlmux`uint64*)q;
			n = *q++;
			[st,tq] = decodetname(q);
			q = tq;
			return [mkctype_array(st, n), q];
		case ctlmux`Tfun:
			[st,tq] = decodetname(q);
			q = tq;
			q = (ctlmux`uint64*)q;
			n = *q++;
			v = mkvec(n);
			for(i = 0; i < n; i++){
				[at, q] = decodeattrs(q);
				sid = gets();
				[pt,tq] = decodetname(q);
				q = tq;
				v[i] = mkparam(pt,
					       (strlen(sid) > 0 ? 
						mkcid(sid) : nil),
					       at);
			}
			return [mkctype_fn(st, v), q];
		case ctlmux`Ttypedef:
			id = mkcid(gets());
			[st,tq] = decodetname(q);
			q = tq;
			return [mkctype_typedef(id, st), q];
		case ctlmux`Tbitfield:
			q = (ctlmux`uint64*)q;
			w = *q++;
			pos = *q++;
			[st,tq] = decodetname(q);
			q = tq;
			return [mkctype_bitfield(st, w, pos), q];
		default:
			error("decodetdef: unhandled case %d", k);
		}
	}

	@define nsinit(id)
	{
		@local type, sym, addr, undef;
		@local lt, ls, et, es, la;
		@local psym2sym;
		@local ltresolve;
		
		@defloc resetltr()
		{
			ltresolve = mkresolve(type, undef,
					      @lambda(tn){
						      muxlooktype(id, tn);
					      });
		}

		type = [:];
		sym = [:];
		addr = [:];
		undef = [:];
		resetltr();

		@define lt(this, tn)
		{
			@local t;
			t = ltresolve(tn);
			if(isundeftype(t))
				return nil;
			return t;
		}

		@define et(this)
		{
			@local resolve, ts;

			// FIXME: maybe only muxenumtype if we haven't before

			/* reset cache */
			type = [:];
			undef = [:];
			resetltr();

			ts = muxenumtype(id);
			resolve = mkresolve(type, undef,
					    @lambda(tn){
						    return ts[typename(tn)];
					    });
			foreach(@lambda(k, v){
					resolve(k);
				}, ts);
			if(length(undef) > 0){
				printf("%d unresolved\n", length(undef));
				foreach(@lambda(k, v){
						printf("\t%t\n", k);
					}, undef);
			}
			return type;
		}

		@define psym2sym(psym)
		{
			@local v, t;
			
			if(psym.flags&ctlmux`Sundef)
				return nil;
			if(psym.flags&ctlmux`Sinline)
				return nil;
			t = ltresolve(psym.type);
			v = psym.val;
			if(psym.flags&ctlmux`Senum)
				v = {subtype(t)}v;
			return mksym(t, psym.id, v);
		}
		
		@define ls(this, name)
		{
			@local psym, s;
			s = sym[name];
			if(s != nil)
				return s;
			psym = muxlooksym(id, name);
			if(psym == nil)
				return nil;
			s = psym2sym(psym);
			if(s != nil){
				sym[symid(s)] = s;
				addr[symoff(s)] = s;
			}
			return s;
		}

		@define es(this)
		{
			@local ss, s;

			/* reset cache */
			sym = [:];

			ss = muxenumsym(id);
			foreach(@lambda(psym){
					s = psym2sym(psym);
					if(s != nil)
						sym[psym.id] = s;
				}, ss);
			return sym;
		}

		@define la(this, a)
		{
			@local psym, s;
			s = addr[a];
			if(s != nil)
				return s;
			psym = muxlookaddr(id, a);
			if(psym == nil)
				return nil;
			s = psym2sym(psym);
			if(s != nil)
				addr[a] = s;
			return s;
		}

		return mkns([ "looktype" : lt,
			      "enumtype" : et,
			      "looksym"  : ls,
			      "enumsym"  : es,
			      "lookaddr" : la ]);
	}

	@define muxlooktype(id, type)
	{
		@local s, p, q, rep, dat, sz, t;
		@local tq; /* FIXME: unnecessary in bleed */

		s = encodetype(type);
		sz = sizeof(ctlmux`Tlooktype);
		sz += sizeof(ctlmux`uint64); /* id */
		sz += sizeof(ctlmux`uint64)+strlen(s);
		p = (ctlmux`Tlooktype*)malloc(sz);
		p->op = ctlmux`Tlooktype;
		p->tag = freshtag();
		q = (ctlmux`uint64*)(p+1);
		*q++ = id;
		putbytes(q, s);
		sendmsg(fd, p, sz);

		/* wait for reply */
		[rep, dat] = runtiltag(p->tag);
		switch(rep->op){
		case ctlmux`Rlooktype:
			break;
		case ctlmux`Rerror:
			if(rep->bytes == "no such thing")
				return nil;
			error("ctlmux: error while waiting for %e: %s",
			      ctlmux`Rlooktype, rep->bytes);
		default:
			error("unexpected response: %e", rep->op);
		}

		q = (ctlmux`uint8*)dat;
		[t,tq] = decodetdef(c64le, q);
		q = tq;
		return t;
	}

	@define muxlooksym(id, sym)
	{
		@local p, rep, dat, sz;
		@local xid, flags, t, val, xsz, q, at;
		@local tq; /* FIXME: unnecessary in bleed */

		sym = cid2str(sym);
		sz = sizeof(ctlmux`Tlooksym);
		sz += sizeof(ctlmux`uint64); /* id */
		sz += sizeof(ctlmux`uint64)+strlen(sym);
		p = (ctlmux`Tlooksym*)malloc(sz);
		p->op = ctlmux`Tlooksym;
		p->tag = freshtag();
		q = (ctlmux`uint64*)(p+1);
		*q++ = id;
		*q++ = strlen(sym);
		q = (char*)q;
		putbytes(q, sym);
		q += strlen(sym);
		sendmsg(fd, p, sz);

		/* wait for reply */
		[rep, dat] = runtiltag(p->tag);
		switch(rep->op){
		case ctlmux`Rlooksym:
			break;
		case ctlmux`Rerror:
			if(rep->bytes == "no such thing")
				return nil;
			error("ctlmux: error while waiting for %e: %s",
			      ctlmux`Rlooksym, rep->bytes);
		default:
			error("unexpected response: %e", rep->op);
		}

		q = (ctlmux`uint64*)dat;
		sz = *q++;
		xid = mkcid(getbytes(q, sz));
		q = (ctlmux`uint8*)((char*)q+sz);
		flags = *q++;
		q = (ctlmux`uint64*)q;
		val = *q++;
		[at, q] = decodeattrs(q);
		at["offset"] = val;
		xsz = *q++;
		[t,tq] = decodetname(q);
		q = tq;
		/* FIXME: symrec should include at */
		return symrec(xid, flags, val, xsz, t);
	}

	@define muxenumsym(id)
	{
		@local p, q, rep, dat, sz, ss;
		@local m, i, xid, xsz, val, flags, t, at;
		@local tq; /* FIXME: unnecessary in bleed */

		sz = sizeof(ctlmux`Tenumsym);
		sz += sizeof(ctlmux`uint64); /* id */
		p = (ctlmux`Tenumsym*)malloc(sz);
		p->op = ctlmux`Tenumsym;
		p->tag = freshtag();
		q = (ctlmux`uint64*)(p+1);
		*q++ = id;
		sendmsg(fd, p, sz);

		/* wait for reply */
		[rep, dat] = runtiltag(p->tag);
		switch(rep->op){
		case ctlmux`Renumsym:
			break;
		case ctlmux`Rerror:
			if(rep->bytes == "no such thing")
				return nil;
			error("ctlmux: error while waiting for %e: %s",
			      ctlmux`Renumsym, rep->bytes);
		default:
			error("unexpected response: %e", rep->op);
		}

		ss = [];
		q = (ctlmux`uint64*)dat;
		m = *q++;
		for(i = 0; i < m; i++){
			q = (ctlmux`uint64*)q;
			sz = *q++;
			xid = mkcid(getbytes(q, sz));
			q = (ctlmux`uint8*)((char*)q+sz);
			flags = *q++;
			q = (ctlmux`uint64*)q;
			val = *q++;
			[at, q] = decodeattrs(q);
			at["offset"] = val;
			xsz = *q++;
			[t,tq] = decodetname(q);
			q = tq;
			/* FIXME: symrec should include at */
			append(ss, symrec(xid, flags, val, xsz, t));
		}
		return ss;
	}

	@define muxlookaddr(id, addr)
	{
		@local p, rep, dat, sz;
		@local xid, flags, t, val, xsz, q, at;
		@local tq; /* FIXME: unnecessary in bleed */

		sz = sizeof(ctlmux`Tlookaddr);
		sz += sizeof(ctlmux`uint64); /* id */
		sz += sizeof(ctlmux`uint64); /* addr */
		p = (ctlmux`Tlookaddr*)malloc(sz);
		p->op = ctlmux`Tlookaddr;
		p->tag = freshtag();
		q = (ctlmux`uint64*)(p+1);
		*q++ = id;
		*q++ = addr;
		sendmsg(fd, p, sz);

		/* wait for reply */
		[rep, dat] = runtiltag(p->tag);
		switch(rep->op){
		case ctlmux`Rlookaddr:
			break;
		case ctlmux`Rerror:
			if(rep->bytes == "no such thing")
				return nil;
			error("ctlmux: error while waiting for %e: %s",
			      ctlmux`Rlookaddr, rep->bytes);
		default:
			error("unexpected response: %e", rep->op);
		}

		q = (ctlmux`uint64*)dat;
		sz = *q++;
		xid = mkcid(getbytes(q, sz));
		q = (ctlmux`uint8*)((char*)q+sz);
		flags = *q++;
		q = (ctlmux`uint64*)q;
		val = *q++;
		[at, q] = decodeattrs(q);
		at["offset"] = val;
		xsz = *q++;
		[t,tq] = decodetname(q);
		q = tq;
		/* FIXME: symrec should include at */
		return symrec(xid, flags, val, xsz, t);
	}

	@define muxenumtype(id)
	{
		@local p, q, rep, dat, sz, ss;
		@local m, i, t;
		@local tq; /* FIXME: unnecessary in bleed */

		sz = sizeof(ctlmux`Tenumtype);
		sz += sizeof(ctlmux`uint64); /* id */
		p = (ctlmux`Tenumtype*)malloc(sz);
		p->op = ctlmux`Tenumtype;
		p->tag = freshtag();
		q = (ctlmux`uint64*)(p+1);
		*q++ = id;
		sendmsg(fd, p, sz);

		/* wait for reply */
		[rep, dat] = runtiltag(p->tag);
		switch(rep->op){
		case ctlmux`Renumtype:
			break;
		case ctlmux`Rerror:
			if(rep->bytes == "no such thing")
				return nil;
			error("ctlmux: error while waiting for %e: %s",
			      ctlmux`Renumtype, rep->bytes);
		default:
			error("unexpected response: %e", rep->op);
		}

		ss = [:];
		q = (ctlmux`uint64*)dat;
		m = *q++;
		for(i = 0; i < m; i++){
			[t,tq] = decodetdef(c64le, q);
			q = tq;
			ss[typename(t)] = t;
		}
		return ss;
	}

	@define muxenumloc(id, ctx)
	{
		@local p, q, rep, dat, sz, ss;
		@local m, i, xid, xsz, t;
		@local ltype, xloc;
		@local tq; /* FIXME: unnecessary in bleed */

		sz = sizeof(ctlmux`Tenumloc);
		sz += sizeof(ctlmux`uint64); /* id */
		sz += sizeof(ctlmux`Ctx);    /* ctx */
		p = (ctlmux`Tenumloc*)malloc(sz);
		p->op = ctlmux`Tenumloc;
		p->tag = freshtag();
		q = (ctlmux`uint64*)(p+1);
		*q++ = id;
		putbytes(q, getbytes(ctx));
		sendmsg(fd, p, sz);

		/* wait for reply */
		[rep, dat] = runtiltag(p->tag);
		switch(rep->op){
		case ctlmux`Renumloc:
			break;
		case ctlmux`Rerror:
			if(rep->bytes == "no such thing")
				return nil;
			error("ctlmux: error while waiting for %e: %s",
			      ctlmux`Renumloc, rep->bytes);
		default:
			error("unexpected response: %e", rep->op);
		}

		ss = [];
		q = (ctlmux`uint64*)dat;
		_ = *q++; /* nsid */
		m = *q++;
		for(i = 0; i < m; i++){
			q = (ctlmux`uint64*)q;
			sz = *q++;
			xid = getbytes(q, sz);
			q = (ctlmux`uint64*)((char*)q+sz);
			xsz = *q++;
			q = (ctlmux`uint8*)q;
			ltype = *q++;
			q = (ctlmux`uint64*)q;
			xloc = *q++;
			[t,tq] = decodetname(q);
			q = tq;
			append(ss, loc(xid, xsz, ltype, xloc, t));
		}
		return ss;
	}

	@define muxenumseg(id)
	{
		@local p, q, rep, dat, sz, addr, len, gs;
		@local m, i, xid;

		sz = sizeof(ctlmux`Tenumseg);
		sz += sizeof(ctlmux`uint64); /* id */
		p = (ctlmux`Tenumseg*)malloc(sz);
		p->op = ctlmux`Tenumseg;
		p->tag = freshtag();
		q = (ctlmux`uint64*)(p+1);
		*q++ = id;
		sendmsg(fd, p, sz);

		/* wait for reply */
		[rep, dat] = runtiltag(p->tag);
		switch(rep->op){
		case ctlmux`Renumseg:
			break;
		case ctlmux`Rerror:
			if(rep->bytes == "no such thing")
				return nil;
			error("ctlmux: error while waiting for %e: %s",
			      ctlmux`Renumseg, rep->bytes);
		default:
			error("unexpected response: %e", rep->op);
		}

		gs = [];
		q = (ctlmux`uint64*)dat;
		m = *q++;
		for(i = 0; i < m; i++){
			addr = *q++;
			len = *q++;
			sz = *q++;
			xid = getbytes(q, sz);
			q = (ctlmux`uint64*)((char*)q+sz);
			append(gs, seg(addr, len, xid));
		}
		return gs;
	}

	@define muxunwind(id, ctx)
	{
		@local p, q, rep, dat, sz, ss;
		@local m, i;

		sz = sizeof(ctlmux`Tunwind);
		sz += sizeof(ctlmux`uint64); /* id */
		sz += sizeof(ctlmux`Ctx);    /* ctx */
		p = (ctlmux`Tunwind*)malloc(sz);
		p->op = ctlmux`Tunwind;
		p->tag = freshtag();
		q = (ctlmux`uint64*)(p+1);
		*q++ = id;
		putbytes(q, getbytes(ctx));
		sendmsg(fd, p, sz);

		/* wait for reply */
		[rep, dat] = runtiltag(p->tag);
		switch(rep->op){
		case ctlmux`Runwind:
			break;
		case ctlmux`Rerror:
			if(rep->bytes == "no such thing")
				return nil;
			error("ctlmux: error while waiting for %e: %s",
			      ctlmux`Runwind, rep->bytes);
		default:
			error("unexpected response: %e", rep->op);
		}

		ss = [];
		q = (ctlmux`uint64*)dat;
		m = *q++;
		q = (ctlmux`Ctx*)q;
		for(i = 0; i < m; i++){
			append(ss, cop(q));
			q++;
		}
		return ss;
	}

	@define muxunwind1(id, ctx)
	{
		@local p, q, rep, dat, sz, rs, k, r, n;
		@local m, i;

		sz = sizeof(ctlmux`Tunwind1);
		sz += sizeof(ctlmux`uint64); /* id */
		sz += sizeof(ctlmux`Ctx);    /* ctx */
		p = (ctlmux`Tunwind1*)malloc(sz);
		p->op = ctlmux`Tunwind1;
		p->tag = freshtag();
		q = (ctlmux`uint64*)(p+1);
		*q++ = id;
		putbytes(q, getbytes(ctx));
		sendmsg(fd, p, sz);

		/* wait for reply */
		[rep, dat] = runtiltag(p->tag);
		switch(rep->op){
		case ctlmux`Runwind1:
			break;
		case ctlmux`Rerror:
			if(rep->bytes == "no such thing")
				return nil;
			error("ctlmux: error while waiting for %e: %s",
			      ctlmux`Runwind1, rep->bytes);
		default:
			error("unexpected response: %e", rep->op);
		}

		rs = [];
		q = (ctlmux`uint32*)dat;
		m = *q++;
		for(i = 0; i < m; i++){
			q = (ctlmux`uint8*)q;
			k = *q++;
			q = (ctlmux`uint64*)q;
			r = *q++;
			q = (ctlmux`int64*)q;
			n = *q++;
			append(rs, rule(k, r, n));
		}
		return rs;
	}

	@define muxnames(path)
	{
		@local p, q, rep, dat, sz;
		@local xid;

		sz = sizeof(ctlmux`Tnames);
		sz += sizeof(ctlmux`uint64)+strlen(path); /* path */
		p = (ctlmux`Tnames*)malloc(sz);
		p->op = ctlmux`Tnames;
		p->tag = freshtag();
		q = (ctlmux`uint64*)(p+1);
		*q++ = strlen(path);
		q = (char*)q;
		putbytes(q, path);
		q += strlen(path);
		sendmsg(fd, p, sz);

		/* wait for reply */
		[rep, dat] = runtiltag(p->tag);
		switch(rep->op){
		case ctlmux`Rnames:
			break;
		case ctlmux`Rerror:
			if(rep->bytes == "no such thing")
				return nil;
			error("ctlmux: error while waiting for %e: %s",
			      ctlmux`Rnames, rep->bytes);
		default:
			error("unexpected response: %e", rep->op);
		}

		q = (ctlmux`uint64*)dat;
		xid = *q++;
		return nsinit(xid);
	}

	@define version()
	{
		@local p, rep, dat, sz, version, os, s;

		version = "sctl-2010:x86-linux-2010,x86-win-2010";

		sz = sizeof(ctlmux`Tversion)+strlen(version);
		p = (ctlmux`Tversion*)malloc(sz);
		p->op = ctlmux`Tversion;
		p->tag = freshtag();
		putbytes(p+1, version);
		sendmsg(fd, p, sz);

		[rep, dat] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rversion);
		s = split(dat, ":");
		if(length(s) != 2)
			error("unknown remote sctl version: %s", dat);
		os = s[1];
		os = substr(os, 0, strlen(os)); /* chop NUL */
		osversion = os;
	}

//	@defloc ping(cnt)
//	{
//		@local p, rep, sz;
//
//		sz = sizeof(ctlmux`Tping)+cnt;
//		p = (ctlmux`Tping*)malloc(sz);
//		p->op = ctlmux`Tping;
//		p->tag = freshtag();
//		sendmsg(fd, p, sz);
//
//		[rep, _] = runtiltag(p->tag);
//		checkreply(rep, ctlmux`Rping);
//		if(rep->cnt != cnt)
//			error("ping reply acknowledged %d bytes, not %d",
//			      rep->cnt, cnt);
//	}

	@define ps()
	{
		@local p, rep, dat, sz, i, j, np, nt, q, pid, tid, cmd;
		@local proc, rv;

		sz = sizeof(ctlmux`Tps);
		p = (ctlmux`Tps*)malloc(sz);
		p->op = ctlmux`Tps;
		p->tag = freshtag();
		sendmsg(fd, p, sz);

		[rep, dat] = runtiltag(p->tag);
		checkreply(rep, ctlmux`Rps);
		q = (ctlmux`uint64*)dat;
		np = *q++;
		rv = [];
		for(i = 0; i < np; i++){
			proc = [];
			pid = *q++;
			append(proc, pid);
			sz = *q++;
			cmd = getbytes(q, sz);
			append(proc, cmd);
			q = (ctlmux`uint64*)((char*)q+sz);
			nt = *q++;
			for(j = 0; j < nt; j++){
				tid = *q++;
				append(proc, tid);
			}
			append(rv, proc);
		}
		return rv;
	}

	@define abort()
	{
		close(fd);
		aborted = 1;
		return nil;
	}

	@define muxclose()
	{
		// FIXME: not safe to call when run is active
		close(fd);
	}

	@define run()
	{
		if(aborted)
			error("attempt to resume aborted mux");
		runtil(noctls);
		return nil;
	}

	version();
	mux = muxrec(ps,
		     launch,
		     attach,
		     run,
		     runtil,
		     settimer,
		     muxclose,
		     abort,
		     muxlooksym,
		     muxenumsym,
		     muxlookaddr,
		     muxlooktype,
		     muxenumtype,
		     muxenumseg,
		     muxenumloc,
		     muxunwind,
		     muxnames,
		     nsinit,
		     stop,
		     cont,
		     step,
		     detach,
		     kill,
		     statunix,
		     statwin,
		     snap,
		     pread,
		     pwrite,
		     trace,
		     settrap,
		     clrtrap);
	return mux;
}

@define atnames(path)
{
	@local mux;
	mux = mkctlmux_local();
	return mux.names(path);
}
