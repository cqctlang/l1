@include <elf.cqct>

edom = mkelfdom(mapfile(listref(args, 0)));
//showallelfsectionheaders(edom);
stab = getelfsection(edom, ".stab");


if(sizeof(nsptr(edom)) == 4)
     stabns = @names nsof(edom) { @include "stabs32.names" };
else
     stabns = @names nsof(edom) { @include "stabs64.names" };

stdom = mkdom(stabns, asof(edom));

stabs = getelfsection(edom, ".stab");
stablim = strlen(stabs);
stab = mkdom(stabns, mksas(stabs));
stabstr = mkdom(stabns, mksas(getelfsection(edom, ".stabstr")));
p = (char*){stabstr}0;

sp = (struct stab*){stab}0;
esp = (struct stab*)((unsigned char*)sp + stablim);

@record lsym { id, desc };

define dolsym(stab){
     @local c, x, rv;
     rv = lsym();
     x = strstr(stab, ":");
     if(x == nil)
	  error("bad lsym");
     rv.id = substr(stab, 0, x);
     if(rv.id == "" || rv.id == " ")
	  rv.id = nil;		/* anonymous */
     x++;
     rv.desc = strref(stab, x);
     switch(rv.desc){
     case 't':
	  break;
     case 'T':
	  break;
     }
     return rv;
}

n = 0;
while(sp < esp){
     if(sp->n_type == stab`N_LSYM){
	  @local sym;
	  sym = dolsym(p+sp->n_strx);
	  printf("%d\t%x\t%e\t%c %s\n", n,
		 sp->n_strx,
		 (enum stabtype)sp->n_type,
		 sym.desc,
		 sym.id);
     }
     sp++;
     n++;
}
