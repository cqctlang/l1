@include <sctlns.cqct>
@include <elf.cqct>
@include <dwarf.cqct>
@include <debugutil.cqct>
@include <json.cqct>

@global 
	/* intervals */
	anycalls,
	anycallsinout,
	containsiv,
	it2ivseq,
	mkpickn,
	mkpicktype,
	zdiff,
	zdump,
	zjoin,
	zshred,
	zsplit,
	zunion,
	zunionall,

	/* chronicle backend */
	callrets,
	calls,
	chdegree,
	chverbose,
	chronicledb,
	firstcall,
	firstreturn,
	runchronicle,
	setchroot,
	chgetargs,
	callintervals,
	returns,
	isincall,
	callstack,
	lastcall,
	lastreturn,

	/* these should be unified with debug library */
	fmtframe,
	fmtldom,
	dumpstack,
	dumpstacklocs,
	rocdumpstack,
	uniqstacks
;

chdegree = 1;
chverbose = 0;

rdsetfmt(@record instant { t, val },
	 @lambda(r) { sprintfa("@%d%s", r.t,
			       r.val == nil ? "" :
			       sprintfa(" %a", r.val)); });
rdsetfmt(@record interval { beg, end, val },
	 @lambda(r) { sprintfa("<@%d - @%d%s>", r.beg, r.end,
			       r.val == nil ? "" :
			       isprocedure(r.val) ? " *" :
			       sprintfa(" %a", r.val)); });

{
	@local chroot, chvalgrpath, chquerypath, ns;
	@local nextid;

	@defloc initpaths()
	{
		chvalgrpath = chroot+"bin/valgrind";
		chquerypath = chroot+"bin/chronicle-query";
	}

	@define setchroot(path)
	{
		if(path[strlen(path)-1] != '/')
			path += "/";
		chroot = path;
		initpaths();
		printf("chquerypath is %s\n", chquerypath);
	}

	chroot = getenv("HOME")+"/ch/";
	initpaths();

	ns = @names clp64le {
		typedef
		struct Ctx {
			/* kernel's register set */
			@0x0	uint64 r15;
			@0x8	uint64 r14;
			@0x10	uint64 r13;
			@0x18	uint64 r12;
			@0x20	uint64 rbp;
			@0x20	uint64 fp;
			@0x28	uint64 rbx;
			@0x30	uint64 r11;
			@0x38	uint64 r10;
			@0x40	uint64 r9;
			@0x48	uint64 r8;
			@0x50	uint64 rax;
			@0x58	uint64 rcx;
			@0x60	uint64 rdx;
			@0x68	uint64 rsi;
			@0x70	uint64 rdi;
			@0x78	uint64 orig_rax;
			@0x80	uint64 rip;
			@0x80	uint64 pc;
			@0x88	uint64 cs;
			@0x90	uint64 eflags;
			@0x98	uint64 rsp;
			@0x98	uint64 sp;
			@0xa0	uint64 ss;
			@0xa8	uint64 fs_base;
			@0xb0	uint64 gs_base;
			@0xb8	uint64 ds;
			@0xc0	uint64 es;
			@0xc8	uint64 fs;
			@0xd0	uint64 gs;
			@0xd8	uint64 thread; /* chronicle construction */
			@0xe0;
		} Ctx;
	};

	@defloc tobin(x)
	{
		if(x >= '0' && x <= '9')
			return x-'0';
		if(x >= 'A' && x <= 'F')
			return x-'A'+10;
		if(x >= 'a' && x <= 'f')
			return x-'a'+10;
		error("bad hex digit");
	}

	@defloc hextobin(s)
	{
		@local i, n, m, t;
		t = m = mkxs();
		n = length(s);
		for(i = 0; i < n; i += 2)
			*t++ = (tobin(s[i])<<4)|tobin(s[i+1]);
		return getbytes(m, n/2);
	}

	@defloc elfloadaddr(filename)
	{
		@local elfdom, data, e, p, i;
		data = mapfile(filename);
		if(!iself(data))
			return nil;
		elfdom = mkelfrec(data).elf;
		if(sizeof(nsptr(elfdom.ns)) == 4){
			e = (Elf32_Ehdr*){elfdom}0;
			p = (Elf32_Phdr*)e->e_phoff;
		}else{
			e = (Elf64_Ehdr*){elfdom}0;
			p = (Elf64_Phdr*)e->e_phoff;
		}
		for(i = 0; i < e->e_phnum; i++){
			if(p[i].p_type != elfdom`PT_LOAD)
				continue;
			return (uintptr)(p[i].p_vaddr);
		}
		return nil;
	}

	@defloc mklinebuf(fd)
	{
		@local part;

		@record lb { read, write };

		part = "";

		@defloc r()
		{
			@local s, m, rv;

			while(1){
				m = strstr(part, "\n");
				if(m){
					rv = substr(part, 0, m);
					part = substr(part, m+1, length(part));
					return rv;
				}
				s = read(fd, 1024);
				if(s == nil)
					return nil; /* discard part */
				part += s;
			}
		}
		
		@defloc w(s)
		{
			return write(fd, s);
		}

		return lb(r, w);
	}

	@defloc chconnect(db)
	{
		@local lb, fds;
	
		fds = popen(chquerypath, "--db", db, 2|8);
		lb = mklinebuf(fds[0]);

		return lb;
	}

	nextid = 1;
	@defloc chquery(lb, t)
	{
		@local s, r, rvs, id;

		id = nextid++;
		t["id"] = id;

		rvs = [];
		t = val2json(t)+"\n";
		lb.write(t);
		if(chverbose)
			printf("--> %s", t);
		while(1){
			s = lb.read();
			if(chverbose)
				printf("<-- %s\n", s);
			if(s == nil){
				error("unexpected eof of chquery channel");
				break;
			}
			r = json2val(s);
			if(r["id"] == nil)
				continue;
			if(r["id"] != id)
				error("unexpected id on chquery channel (on %d, got %d)",
				      id, r["id"]);
			if(r["terminated"])
				return rvs;
			append(rvs, r);
		}
		return rvs;
	}

	@defloc chcollect(rs, field)
	{
		@local l;
		l = [];
		foreach(@lambda(t) { @local v; v = t[field]; if(v) append(l, v); }, rs);
		return l;
	}

	@defloc chfilter(rs, pred)
	{
		@local l;
		l = [];
		foreach(@lambda(t) { if(pred(t)) append(l, t); }, rs);
		return l;
	}

	@defloc chflatten(rs)
	{
		@local rv;
		rv = [:];
		foreach(@lambda(t) { foreach(@lambda(k,v) { rv[k] = v; }, t); }, rs);
		return rv;
	}

	@defloc mkchctl2(dbpath)
	{
		@local endtstamp, lb, rs, nsmap, exedom;
		@local qsfd, qpath, qfd;
		@local nsfd, npath, nfd;

		@defloc _close()
		{
			if(qsfd != nil)
				close(qsfd);
			if(nsfd != nil)
				close(nsfd);
		}

		@defloc bindq()
		{
			if(qfd != nil)
				close(qfd);
			qfd = unixopen(qpath);
			if(qfd == nil)
				error("cannot open unix socket");
			lb = mklinebuf(qfd);
		}

		@defloc bindns()
		{
			if(nfd != nil)
				close(nfd);
			nfd = unixopen(npath);
			if(nfd == nil)
				error("cannot open unix socket");
			nsmap.rebind(nfd);
		}

		@defloc rebind()
		{
//			printf("bindq\n");
//			time(bindq);
//			printf("bindns\n");
//			time(bindns);
			bindq();
			bindns();
		}

		@defloc init()
		{
			qsfd = popen("qsrv", sprintfa("%u", chdegree), dbpath, 2|8);
			qsfd = qsfd[0];
			qpath = fread(qsfd, 6);
			printf("qpath is %B\n", qpath);
		
			bindq();

			rs = chquery(lb, [ "cmd" : "info" ]);
			rs = chcollect(rs, "endTStamp");
			if(length(rs) != 1)
				error("unexpected endTStamp response: %a", rs);
			endtstamp = rs[0];
			if(chverbose)
				printf("*** bound to execution %s; interval [0,%u]\n", db, endtstamp);

			rs = chquery(lb, [ "cmd" : "scan",
					   "map" : "MEM_MAP",
					   "beginTStamp" : 0,
					   "endTStamp" : endtstamp,
					   "ranges" : [ [ "start" : 0,
							  "length" : -1ULL ]] ]);
			rs = chfilter(rs, @lambda(t) { @local v; v = t["filename"]; return v; });
			rs = chfilter(rs, @lambda(t) { @local v; v = t["offset"]; v != nil && v == 0; });
			rs = chfilter(rs, @lambda(t) { @local v; v = t["execute"]; v != nil && v; });
	
			nsfd = popen("sym", 2|4|8);
			nsfd = nsfd[0];
			sctlversion(nsfd);
			nsmap = mknsmap(@lambda(path) { printf("path is %s\n", path); mksctlns(nsfd, path); });

			foreach(@lambda(t){
					@local f, abase, vbase;
					f = t["filename"];
					if(strstr(f, "valgrind") != nil)
						return;
					abase = t["start"];
					vbase = elfloadaddr(f);
					if(vbase == nil)
						return; /* presume it's not an elf */
					printf("\t0x%016p\t0x%016p\t0x%016p\t%s\n", abase, vbase, abase-vbase, f);
					nsmap.add(abase, vbase, f);
				}, rs);
			printf("\tend timestamp: %d\n", endtstamp);
			nsmap.setexebyname("l1"); /* hack */
			exedom = dom(1); /* hack */
			npath = sctlsrv(nsfd, chdegree);
			bindns();
		}

		@defloc scan(kind, rest ...)
		{
			@local beg, end, addr, len, sp, tid;

			@defloc defrange(args)
			{
				if(length(args) == 2){
					beg = args[0];
					end = args[1];
					if(beg > end)
						error("bad interval [%d,%d]", beg, end);
					if(end > endtstamp)
						error("interval exceeds execution");
				}else{
					beg = 0;
					end = endtstamp;
				}
			}

			switch(kind){
			case 'exec:
				addr = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "INSTR_EXEC",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "ranges" : [ [ "start" : addr, "length" : 1 ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'firstexec:
				addr = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "INSTR_EXEC",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "termination" : "findFirst",
						   "ranges" : [ [ "start" : addr, "length" : 1 ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'lastexec:
				addr = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "INSTR_EXEC",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "termination" : "findLast",
						   "ranges" : [ [ "start" : addr, "length" : 1 ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'write:
				addr = pop(rest);
				len = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "MEM_WRITE",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "ranges" : [ [ "start" : addr, "length" : len ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'read:
				addr = pop(rest);
				len = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "MEM_READ",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "ranges" : [ [ "start" : addr, "length" : len ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'firstwrite:
				addr = pop(rest);
				len = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "MEM_WRITE",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "termination" : "findFirst",
						   "ranges" : [ [ "start" : addr, "length" : len ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'firstread:
				addr = pop(rest);
				len = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "MEM_READ",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "termination" : "findFirst",
						   "ranges" : [ [ "start" : addr, "length" : len ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'lastwrite:
				addr = pop(rest);
				len = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "MEM_WRITE",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "termination" : "findLast",
						   "ranges" : [ [ "start" : addr, "length" : len ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'lastread:
				addr = pop(rest);
				len = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "MEM_READ",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "termination" : "findLast",
						   "ranges" : [ [ "start" : addr, "length" : len ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'lastentersp:
				sp = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "ENTER_SP",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "termination" : "findLast",
						   /* it seems we need to bound the query.  assume stack is at most 1MB */
						   "ranges" : [ [ "start" : sp, "length" : sp+10K ]] ]);
				/* FIXME: sometimes this query returns multiple results!
				   is picking the last one the right thing? */
				rs = chfilter(rs, @lambda(t) { @local v; v = t["TStamp"]; return v != nil; });
				if(length(rs) == 0)
					return [nil,nil];
				else{
					rs = reverse(rs)[0];
					return [ rs["TStamp"], rs["start"] ];
				}
			case 'findspgt:
				sp = pop(rest);
				tid = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "findSPGreaterThan",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "thread"    : tid,
						   "threshold" : sp ]);
				return chcollect(rs, "TStamp");
			default:
				error("invalid scan kind: %a", kind);
			}
		}

		@defloc findret(t)
		{
			@local rs, x;

			x = ctx(t);
			rs = chquery(lb, [ "cmd" : "findSPGreaterThan",
					   "beginTStamp" : t,
					   "endTStamp" : endtstamp,
					   "thread"    : x->thread,
					   "threshold" : x->sp ]);
			rs = chcollect(rs, "TStamp");
			if(length(rs) == 0)
				return nil;
			else if(length(rs) > 1)
				error("too many return points");
			else return rs[0]-1;
		}

		@defloc mem(tstamp)
		{
			if(tstamp >= endtstamp)
				error("invalid timestamp");

			@defloc get(this, r)
			{
				@local rs, ts;

				rs = chquery(lb, [ "cmd" : "readMem",
						   "TStamp" : tstamp,
						   "ranges" : [ [ "start"  : rangebeg(r),
								  "length" : rangelen(r) ] ] ]);
				ts = chcollect(rs, "bytes");
				if(length(ts) == 0)
					error("no bytes -- what do i do?");
				if(length(ts) > 1){
					ts = chfilter(rs, @lambda(r) { r["bytes"]; });
					sort(ts, @lambda(r1, r2) { cvalcmp(r1["start"], r2["start"]); });
					ts = chcollect(ts, "bytes");
					return(hextobin(join(ts)));
				}
			
				return hextobin(ts[0]);
			}

			@defloc put(this, r, s)
			{
				error("attempt to write to chronicle address space");
			}

			@defloc map(this)
			{
				return vector(mkrange(0, -1ULL));
			}

			@defloc ismapped(this, r)
			{
				return 1; /* for now */
			}

			return mkas([ "get" : get,
				      "put" : put,
				      "map" : map,
				      "ismapped" : ismapped
					    ]);
		}

		@defloc ctx(tstamp)
		{
			@local rs, rv;
			rs = chquery(lb, [ "cmd" : "readReg",
					   "TStamp" : tstamp,
					   "r15"    : 64,
					   "r14"    : 64,
					   "r13"    : 64,
					   "r12"    : 64,
					   "rbp"    : 64,
					   "rbx"    : 64,
					   "r11"    : 64,
					   "r10"    : 64,
					   "r9"     : 64,
					   "r8"     : 64,
					   "rax"    : 64,
					   "rcx"    : 64,
					   "rdx"    : 64,
					   "rsi"    : 64,
					   "rdi"    : 64,
					   "pc"     : 64,
					   "rsp"    : 64,
					   "thread" : 64,
					     ]);
			rs = chflatten(rs);
			rv = (ns`Ctx*){mkzas(sizeof(ns`Ctx))}0;
			rv->r15 = strton(rs["r15"], 16);
			rv->r14 = strton(rs["r14"], 16);
			rv->r13 = strton(rs["r13"], 16);
			rv->r12 = strton(rs["r12"], 16);
			rv->r11 = strton(rs["r11"], 16);
			rv->r10 = strton(rs["r10"], 16);
			rv->r9  = strton(rs["r9"], 16);
			rv->r8  = strton(rs["r8"], 16);
			rv->rbp = strton(rs["rbp"], 16);
			rv->rbx = strton(rs["rbx"], 16);
			rv->rax = strton(rs["rax"], 16);
			rv->rcx = strton(rs["rcx"], 16);
			rv->rdx = strton(rs["rdx"], 16);
			rv->rsi = strton(rs["rsi"], 16);
			rv->rdi = strton(rs["rdi"], 16);
			rv->rip = strton(rs["pc"], 16);
			rv->rsp = strton(rs["rsp"], 16);
			rv->thread = strton(rs["thread"], 16);
			return rv;
		}
				
		@defloc _ns(arg...)
		{
			@local idx;
			if(length(arg) == 0)
				return nsmap.exe();
			idx = arg[0];
			if(isstring(idx))
				return nsmap.byname(idx);
			if(iscvalue(idx))
				return nsmap.byaddr(idx);
			error("wrong type of index");
		}

		@defloc dom(t, arg...)
		{
			@local n;
			n = apply(_ns, arg);
			if(n == nil)
				return nil;
			return mkdom(n, mem(t));
		}

		@defloc ldom(t, arg...)
		{
			@local x;
			if(length(arg) == 0)
				x = ctx(t);
			else
				x = arg[0];
			return dwlocaldom(x, mem(t), nsmap);
		}

		@defloc unwind(t) { dwunwind(ctx(t), mem(t), nsmap); }

		@defloc looksrc(addr)
		{
			@local n;
			n = _ns(addr);
			if(n == nil)
				return n;
			n.looksrc(addr);
		}

		@defloc _interval()
		{
			return interval(0, endtstamp, nil);
		}

		init();

		return [ 'interval : _interval,
			 'exedom   : exedom,
			 'scan     : scan,
			 'findret  : findret,
			 'mem      : mem,
			 'ctx      : ctx,
			 'nsmap    : nsmap,
			 'ns       : _ns,
			 'dom      : dom,
			 'ldom     : ldom,
			 'unwind   : unwind,
			 'looksrc  : looksrc,
			 'close    : _close,
			 'rebind   : rebind ];
	}


	@record chctl { interval, exedom, scan, findret, mem, ctx, nsmap, ns, dom, ldom, unwind, looksrc };

	@defloc mkchctl(db)
	{
		@local endtstamp, lb, rs, nsmap, exedom;

		lb = chconnect(db);
		rs = chquery(lb, [ "cmd" : "info" ]);
		rs = chcollect(rs, "endTStamp");
		if(length(rs) != 1)
			error("unexpected endTStamp response: %a", rs);
		endtstamp = rs[0];
		if(chverbose)
			printf("*** bound to execution %s; interval [0,%u]\n", db, endtstamp);

		rs = chquery(lb, [ "cmd" : "scan",
				   "map" : "MEM_MAP",
				   "beginTStamp" : 0,
				   "endTStamp" : endtstamp,
				   "ranges" : [ [ "start" : 0,
						  "length" : -1ULL ]] ]);
		rs = chfilter(rs, @lambda(t) { @local v; v = t["filename"]; return v; });
		rs = chfilter(rs, @lambda(t) { @local v; v = t["offset"]; v != nil && v == 0; });
		rs = chfilter(rs, @lambda(t) { @local v; v = t["execute"]; v != nil && v; });
	
		nsmap = mknsmap(atnames);
		foreach(@lambda(t){
				@local f, abase, vbase;
				f = t["filename"];
				if(strstr(f, "valgrind") != nil)
					return;
				abase = t["start"];
				vbase = elfloadaddr(f);
				if(vbase == nil)
					return; /* presume it's not an elf */
				printf("\t0x%016p\t0x%016p\t0x%016p\t%s\n", abase, vbase, abase-vbase, f);
//				printf("\t0x%016p\t%s\n", abase-vbase, f);
				nsmap.add(abase, vbase, f);
			}, rs);
		nsmap.setexebyname("l1"); /* hack */
//		printf("\tend timestamp: %d\n", endtstamp);

		@defloc scan(kind, rest ...)
		{
			@local beg, end, addr, len, sp, tid;

			@defloc defrange(args)
			{
				if(length(args) == 2){
					beg = args[0];
					end = args[1];
					if(beg > end)
						error("bad interval [%d,%d]", beg, end);
					if(end > endtstamp)
						error("interval exceeds execution");
				}else{
					beg = 0;
					end = endtstamp;
				}
			}

			switch(kind){
			case 'exec:
				addr = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "INSTR_EXEC",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "ranges" : [ [ "start" : addr, "length" : 1 ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'firstexec:
				addr = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "INSTR_EXEC",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "termination" : "findFirst",
						   "ranges" : [ [ "start" : addr, "length" : 1 ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'lastexec:
				addr = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "INSTR_EXEC",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "termination" : "findLast",
						   "ranges" : [ [ "start" : addr, "length" : 1 ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'write:
				addr = pop(rest);
				len = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "MEM_WRITE",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "ranges" : [ [ "start" : addr, "length" : len ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'read:
				addr = pop(rest);
				len = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "MEM_READ",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "ranges" : [ [ "start" : addr, "length" : len ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'firstwrite:
				addr = pop(rest);
				len = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "MEM_WRITE",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "termination" : "findFirst",
						   "ranges" : [ [ "start" : addr, "length" : len ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'firstread:
				addr = pop(rest);
				len = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "MEM_READ",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "termination" : "findFirst",
						   "ranges" : [ [ "start" : addr, "length" : len ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'lastwrite:
				addr = pop(rest);
				len = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "MEM_WRITE",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "termination" : "findLast",
						   "ranges" : [ [ "start" : addr, "length" : len ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'lastread:
				addr = pop(rest);
				len = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "MEM_READ",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "termination" : "findLast",
						   "ranges" : [ [ "start" : addr, "length" : len ] ] ]);
				rs = chfilter(rs, @lambda(t) { @local v; v = t["type"]; return v && v == "normal"; });
				return chcollect(rs, "TStamp");
			case 'lastentersp:
				sp = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "scan",
						   "map" : "ENTER_SP",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "termination" : "findLast",
						   /* it seems we need to bound the query.  assume stack is at most 1MB */
						   "ranges" : [ [ "start" : sp, "length" : sp+10K ]] ]);
				/* FIXME: sometimes this query returns multiple results!
				   is picking the last one the right thing? */
				rs = chfilter(rs, @lambda(t) { @local v; v = t["TStamp"]; return v != nil; });
				if(length(rs) == 0)
					return [nil,nil];
				else{
					rs = reverse(rs)[0];
					return [ rs["TStamp"], rs["start"] ];
				}
			case 'findspgt:
				sp = pop(rest);
				tid = pop(rest);
				defrange(rest);
				rs = chquery(lb, [ "cmd" : "findSPGreaterThan",
						   "beginTStamp" : beg,
						   "endTStamp" : end,
						   "thread"    : tid,
						   "threshold" : sp ]);
				return chcollect(rs, "TStamp");
			default:
				error("invalid scan kind: %a", kind);
			}
		}

		@defloc findret(t)
		{
			@local rs, x;

			x = ctx(t);
			rs = chquery(lb, [ "cmd" : "findSPGreaterThan",
					   "beginTStamp" : t,
					   "endTStamp" : endtstamp,
					   "thread"    : x->thread,
					   "threshold" : x->sp ]);
			rs = chcollect(rs, "TStamp");
			if(length(rs) == 0)
				return nil;
			else if(length(rs) > 1)
				error("too many return points");
			else return rs[0]-1;
		}

		@defloc mem(tstamp)
		{
			if(tstamp >= endtstamp)
				error("invalid timestamp");

			@defloc get(this, r)
			{
				@local rs, ts;

				rs = chquery(lb, [ "cmd" : "readMem",
						   "TStamp" : tstamp,
						   "ranges" : [ [ "start"  : rangebeg(r),
								  "length" : rangelen(r) ] ] ]);
				ts = chcollect(rs, "bytes");
				if(length(ts) == 0)
					error("no bytes -- what do i do?");
				if(length(ts) > 1){
					ts = chfilter(rs, @lambda(r) { r["bytes"]; });
					sort(ts, @lambda(r1, r2) { cvalcmp(r1["start"], r2["start"]); });
					ts = chcollect(ts, "bytes");
					return(hextobin(join(ts)));
				}
			
				return hextobin(ts[0]);
			}

			@defloc put(this, r, s)
			{
				error("attempt to write to chronicle address space");
			}

			@defloc map(this)
			{
				return vector(mkrange(0, -1ULL));
			}

			@defloc ismapped(this, r)
			{
				return 1; /* for now */
			}

			return mkas([ "get" : get,
				      "put" : put,
				      "map" : map,
				      "ismapped" : ismapped
					    ]);
		}

		@defloc ctx(tstamp)
		{
			@local rs, rv;
			rs = chquery(lb, [ "cmd" : "readReg",
					   "TStamp" : tstamp,
					   "r15"    : 64,
					   "r14"    : 64,
					   "r13"    : 64,
					   "r12"    : 64,
					   "rbp"    : 64,
					   "rbx"    : 64,
					   "r11"    : 64,
					   "r10"    : 64,
					   "r9"     : 64,
					   "r8"     : 64,
					   "rax"    : 64,
					   "rcx"    : 64,
					   "rdx"    : 64,
					   "rsi"    : 64,
					   "rdi"    : 64,
					   "pc"     : 64,
					   "rsp"    : 64,
					   "thread" : 64,
					     ]);
			rs = chflatten(rs);
			rv = (ns`Ctx*){mkzas(sizeof(ns`Ctx))}0;
			rv->r15 = strton(rs["r15"], 16);
			rv->r14 = strton(rs["r14"], 16);
			rv->r13 = strton(rs["r13"], 16);
			rv->r12 = strton(rs["r12"], 16);
			rv->r11 = strton(rs["r11"], 16);
			rv->r10 = strton(rs["r10"], 16);
			rv->r9  = strton(rs["r9"], 16);
			rv->r8  = strton(rs["r8"], 16);
			rv->rbp = strton(rs["rbp"], 16);
			rv->rbx = strton(rs["rbx"], 16);
			rv->rax = strton(rs["rax"], 16);
			rv->rcx = strton(rs["rcx"], 16);
			rv->rdx = strton(rs["rdx"], 16);
			rv->rsi = strton(rs["rsi"], 16);
			rv->rdi = strton(rs["rdi"], 16);
			rv->rip = strton(rs["pc"], 16);
			rv->rsp = strton(rs["rsp"], 16);
			rv->thread = strton(rs["thread"], 16);
			return rv;
		}
				
		@defloc _ns(arg...)
		{
			@local idx;
			if(length(arg) == 0)
				return nsmap.exe();
			idx = arg[0];
			if(isstring(idx))
				return nsmap.byname(idx);
			if(iscvalue(idx))
				return nsmap.byaddr(idx);
			error("wrong type of index");
		}

		@defloc dom(t, arg...)
		{
			@local n;
			n = apply(_ns, arg);
			if(n == nil)
				return nil;
			return mkdom(n, mem(t));
		}

		@defloc ldom(t, arg...)
		{
			@local x;
			if(length(arg) == 0)
				x = ctx(t);
			else
				x = arg[0];
			return dwlocaldom(x, mem(t), nsmap);
		}

		@defloc unwind(t) { dwunwind(ctx(t), mem(t), nsmap); }

		@defloc looksrc(addr)
		{
			@local n;
			n = _ns(addr);
			if(n == nil)
				return n;
			n.looksrc(addr);
		}

		@defloc _interval()
		{
			return interval(0, endtstamp, nil);
		}

		exedom = dom(1); /* hack */
		return chctl(_interval, exedom, scan, findret, mem, ctx, nsmap, _ns, dom, ldom, unwind, looksrc);
	}

	@define chgetargs(exe, n, t)
	{
		@local ctx, rs, rv, i;
		ctx = exe.ctx(t);

		if(n > 6)
			error("function has too many arguments");

		rv = [];
		rs = [ ctx->rdi,
		       ctx->rsi,
		       ctx->rdx,
		       ctx->rcx,
		       ctx->r8,
		       ctx->r9  ];
		i = 0;
		for(i = 0; i < n; i++)
			append(rv, pop(rs));
		return rv;
	}

	@define callintervals(exe, i, func)
	{
		@local ts, ps;
		ts = exe.scan('exec, func, i.beg, i.end);
		ts = map(@lambda(t){
				@local r;
				r = exe.findret(t);
				if(r == nil)
					error("cannot find return time for %a\n", t);
				return interval(t, r, nil);
			}, ts);
		ps = exe.scan('lastexec, func, 0, i.beg);
		if(length(ps) == 1){
			@local t, r;
			t = ps[0];
			r = exe.findret(t);
			if(r == nil)
				error("cannot find return time for %a\n, t");
			if(length(ts) && r >= ts[0].end)
				/* we seemed to have found overlapping calls */
				error("bug");
			push(ts, interval(t, r, nil));
		}
		return ts;
	}

	@define firstcall(db, iv, fptr)
	{
		@local its;
		its = calls(db, iv, fptr);
		if(length(its) == 0)
			error("no call");
		return its[0];
	}

	@define lastcall(db, iv, fptr)
	{
		@local its;
		its = calls(db, iv, fptr);
		if(length(its) == 0)
			error("no call");
		return its[length(its)-1];
	}

	/* FIXME: redefine firstreturn and lastreturn
	   to search only for desired return time */

	@define firstreturn(db, iv, fptr)
	{
		@local its;
		its = returns(db, iv, fptr);
		if(length(its) == 0)
			error("no return");
		return its[0];
	}

	@define lastreturn(db, iv, fptr)
	{
		@local its;
		its = returns(db, iv, fptr);
		if(length(its) == 0)
			error("no return");
		return its[length(its)-1];
	}

	@define callrets(db, iv, fptr)
	{
		@local ct, rt, ps, n, ivs;
		
		ct = @typeof(fptr);
		if(!isptr(ct) || !isfunc(subtype(ct)))
			error("cannot determine function argument types");
		ps = params(subtype(ct));
		n = length(ps);
		if(n == 1 && paramtype(ps[0]) == @typeof(void))
			n = 0;
		else
			n = length(ps);
		rt = rettype(subtype(ct));
		if(rt == @typeof(void))
			rt = nil;

		ivs = callintervals(db, iv, fptr);
		return map(@lambda(iv){
				@local t, ctx, args, as, i, dom, rv;

				/* arguments */
				as = [];
				if(n > 0){
					t = iv.beg;
					dom = db.dom(t);
					args = chgetargs(db, n, t);
					for(i = 0; i < n; i++)
						append(as, {paramtype(ps[i])}{dom}args[i]);
				}

				/* return value */
				rv = nil;
				if(rt){
					t = iv.end;
					ctx = db.ctx(t);
					rv = {rt}{db.dom(t)}ctx->rax;
				}

				return interval(iv.beg, iv.end, push(as, rv));
			}, ivs);
	}

	@define calls(db, iv, fptr)
	{
		@local ct, xs, ps, n;

		ct = @typeof(fptr);
		if(!isptr(ct) || !isfunc(subtype(ct)))
			error("cannot determine function argument types");
		ps = params(subtype(ct));
		n = length(ps);
		if(n == 1 && paramtype(ps[0]) == @typeof(void))
			n = 0;
		else
			n = length(ps);
		xs = db.scan('exec, fptr, iv.beg, iv.end);
		map(@lambda(t){
				@local args, as, i, dom;
				dom = db.dom(t);
				args = chgetargs(db, n, t);
				as = [];
				for(i = 0; i < n; i++)
					append(as, {paramtype(ps[i])}{dom}args[i]);
				return instant(t, as);
			}, xs);
	}

	@define returns(db, iv, fptr)
	{
		@local ivs, ct, rt;

		ct = @typeof(fptr);
		if(!isptr(ct) || !isfunc(subtype(ct)))
			error("cannot determine function return type");
		rt = rettype(subtype(ct));
		if(rt == @typeof(void))
			rt = nil;
		ivs = callintervals(db, iv, fptr);
		return map(@lambda(iv){
				@local t, ctx;
				t = iv.end;
				ctx = db.ctx(t);
				return instant(t, rt ? {rt}{db.dom(t)}ctx->rax : nil);
			}, ivs);
	}

	@define isincall(db, t, fptr)
	{
		@local c, r;

		c = db.scan('lastexec, fptr, 0, t);
		if(length(c) == 0)
			return nil;
		if(length(c) != 1)
			error("confusion");
		c = c[0];
		r = db.findret(c);
		if(r == nil)
			/* assume it never returned */
			return interval(c, db.interval().end, nil);
		if(r >= t)
			return interval(c, r, nil);
		return nil;
	}

	@define fmtframe(ctl, ctx, t)
	{
		@local s, src;

		s = "";

		/* pc */
		s += sprintfa("%016p", ctx->pc);

		/* symbol */
		s += sprintfa("\t%-30y", {ctl.dom(t, ctx->pc)}ctx->pc);

		/* source */
		src = ctl.looksrc(ctx->pc);
		if(src)
			s += sprintfa("\t%s:%d", src.file, src.line);

		return s;
	}

	@define fmtldom(ctl, ctx, t)
	{
		@local s, ldom;
		s = "";	
		ldom = ctl.ldom(t, ctx);
		if(ldom == nil)
			return s;
		foreach(@lambda(id, l){
				s += sprintfa("\t%016p\t%t\n",
					      symoff(l),
					      l);
			}, ldom.enumsym());
		return s;
	}

	@define uniqstacks(ctl, ts)
	{
		@local pcht, stkht, rv;

		@defloc dofmt(t)
		{
			@local ctxs, ss;
			ctxs = ctl.unwind(t);
			ss = map(@lambda(ctx){ "\t"+fmtframe(ctl, ctx, t)+"\n"; }, ctxs);
			return join(ss);
		}

		pcht = mktab(mklist);
		foreach(@lambda(t){
				@local ctx;
				ctx = ctl.ctx(t);
				append(pcht[ctx->pc], t);
			}, ts);		

		stkht = mktab(mklist);
		foreach(@lambda(pc, ts){
				@local ctxs, t, pcs;
				t = ts[0];
				ctxs = ctl.unwind(t);
				pcs = map(@lambda(ctx){ ctx->pc; }, ctxs);
				stkht[pcs] = concat(stkht[pcs], ts);
			}, pcht);
		rv = [];
		foreach(@lambda(pcs, ts){
				@local t, fmt;
				t = ts[0];
				fmt = dofmt(t);
				append(rv, [ts, fmt]);
			}, stkht);
		return rv;
	}

	@define dumpstack(ctl, t)
	{
		@local ctxs;
		ctxs = ctl.unwind(t);
		foreach(@lambda(ctx){
				printf("%s\n", fmtframe(ctl, ctx, t));
			}, ctxs);
		printf("\n");
	}

	@define dumpstacklocs(ctl, t)
	{
		@local ctxs;
		ctxs = ctl.unwind(t);
		foreach(@lambda(ctx){
				printf("%s\n", fmtframe(ctl, ctx, t));
				printf("%s", fmtldom(ctl, ctx, t));
			}, ctxs);
		printf("\n");
	}

	@defloc entry(exe, t)
	{
		@local te, ts, sp, spe, tid, ctx;

		ctx = exe.ctx(t);
		sp = ctx->sp;
		tid = ctx->thread;

		while(1){
			/* starting at 0 causes trouble */
//		chverbose = 1;
			[te, spe] = exe.scan('lastentersp, sp, 1, t);
			chverbose = 0;
			if(te == nil)
				return nil;
			/* te is the call instruction;
			   te+1 is first insn in new fn */
			ctx = exe.ctx(te);
//		sp = ctx->sp;
//		printf("sp is %d\n", sp);
			ts = exe.scan('findspgt, spe, tid, te+1, t);
			if(length(ts) == 0)
				return te+1;
			if(ts[0] > t)
				return te+1;
			printf("looping %a!\n", ts);
			t = te;
			sp = spe+8;
		}
	}

	/* o'callahan's stack unwinder */
	@define rocdumpstack(exe, t)
	{
		printf("@%-10d %s\n", t, fmtframe(exe, exe.ctx(t), t));
		t = entry(exe, t);
		if(t == nil)
			return;
		printf("@%-10d %s\n", t-1, fmtframe(exe, exe.ctx(t-1), t-1));
		while(t = entry(exe, t-1))
			printf("@%-10d %s\n", t-1, fmtframe(exe, exe.ctx(t-1), t-1));
	}

	@define runchronicle(db, cmd)
	{
		@local fds, buf, args;

		setenv("CHRONICLE_DB", db);
		args = copy(cmd);
		push(args, "--tool=chronicle");
		push(args, chvalgrpath);
		fds = apply(popen, args);
	
		while(buf = read(fds[2], 1024))
//		if(chverbose)
			printf("*** %s", buf);

		while(buf = read(fds[1], 1024))
//		if(chverbose)
			printf("*** %s", buf);

		return mkchctl(db);
	}

	@define chronicledb(db)
	{
		mkchctl2(db);
	}

	/* A and B are the values of two colliding intervals.
	   it would be nice to have the intervals */
//	@defloc nocollide(a, b)
//	{
//		error("interval collision");
//	}

	@define anycalls(db, iv, fns)
	{
		zunionall(map(@lambda(fn){ callintervals(db, iv, fn); }, fns), nil);
	}

	@define anycallsinout(db, iv, fns)
	{
		zunionall(map(@lambda(fn){ callrets(db, iv, fn); }, fns), nil);
	}

	@define it2ivseq(its)
	{
		@local it, nit, i, m, rv;
		m = length(its);
		if(m == 0)
			return [];
		if(m == 1)
			error("only one instant");
		it = its[0];
		rv = [];
		for(i = 1; i < m; i++){
			nit = its[i];
			append(rv, interval(it.t, nit.t, it.val));
			it = nit;
		}
		return rv;
	}

/* split interval sequence into two sequences, before and after.
   before contains intervals before T (i.e., that end no later than T).
   after contains intervals at or after T.
   optional third argument MODE determines what happens
   if T occurs within an interval [B,E,V]:

   'split :    (default) the interval is split into [B,T,V] (which goes into before)
               and [T,E,V] (which goes into after).
   'before :   [B,E,V] is added to before
   'after :    [B,E,V] is added to after
   'fail :     the call returns nil
*/
	@define zsplit(ivs, t, rest ...)
	{
		@local before, mode;

		before = [];

		if(length(rest) > 0){
			if(length(rest) > 1)
				error("too many arguments");
			mode = rest[0];
			if(!ismember(['split, 'before, 'after, 'fail], mode))
				error("unknown mode: %a", mode);
		}else
			mode = 'split;

		@defloc loop(ivs)
		{
			@local iv;
			if(length(ivs) == 0)
				return [before, []];
			iv = ivs[0];
			if(iv.beg >= t)
				return [before, ivs];
			else if(iv.end <= t){
				pop(ivs);
				append(before, iv);
				return loop(ivs);
			}else
				switch(mode){
				case 'split:
					pop(ivs);
					append(before, interval(iv.beg, t, iv.val));
					push(ivs, interval(t, iv.end, iv.val));
					return loop(ivs);
				case 'before:
					pop(ivs);
					append(before, iv);
					return loop(ivs);
				case 'after:
					return [before, ivs];
				case 'fail:
					return [nil, nil];
				default:
					error("bug");
				}
		}
		return loop(copy(ivs));
	}

	@define containsiv(ivs, ivort)
	{
		@defloc lookt(t)
		{
			@local i, iv, m;
			m = length(ivs);
			for(i = 0; i < m; i++){
				iv = ivs[i];
				if(t < iv.beg)
					continue;
				if(t >= iv.beg && t < iv.end)
					return iv;
				if(t >= iv.end)
					continue;
			}
			return nil;
		}

		@defloc lookiv(iv)
		{
			@local x;
			x = containsiv(ivs, iv.beg);
			if(x == nil)
				return nil;
			if(x.end < iv.end)
				return nil;
			return x;
		}

		if(isinterval(ivort))
			return lookiv(ivort);
		else if(isinstant(ivort))
			return lookt(ivort.t);
		else if(iscvalue(ivort))
			return lookt(ivort);
		else
			error("invalid second argument");
	}

/* AVS and BVS are ivseqs.
   subdivide each so that no interval in AVS overlaps with
   one in BVS and vice-versa. */
	@define zshred(avs, bvs)
	{
		@defloc loop(avs, bvs, navs, nbvs, cnt)
		{
			@local av, bv;
			@local ab, ae, bb, be;
			if(length(avs) == 0)
				return [navs, concat(nbvs, bvs)];
			else if(length(bvs) == 0)
				return [concat(navs, avs), nbvs];
			else{
				av = avs[0];
				bv = bvs[0];
				ab = av.beg;
				ae = av.end;
				bb = bv.beg;
				be = bv.end;

				if(ae <= bb){
					append(navs, pop(avs));
					return loop(avs, bvs, navs, nbvs, cnt);
				}else if(ab < bb && ae <= be){
					pop(avs);
					pop(bvs);
					append(navs, interval(ab, bb, av.val));
					append(navs, interval(bb, ae, av.val));
					append(nbvs, interval(bb, ae, bv.val));
					if(ae < be)
						push(bvs, interval(ae, be, bv.val));
					return loop(avs, bvs, navs, nbvs, cnt);
				}else if(ae <= be){
					if(ab == bb && ae == be){
						append(navs, pop(avs));
						append(nbvs, pop(bvs));
						return loop(avs, bvs, navs, nbvs, cnt);
					}else if(ab == bb && ae < be){
						pop(bvs);
						append(navs, pop(avs));
						append(nbvs, interval(bb, ae, bv.val));
						push(bvs, interval(ae, be, bv.val)); 
						return loop(avs, bvs, navs, nbvs, cnt);
					}else if(ab > bb && ae <= be){
						pop(avs);
						pop(bvs);
						append(navs, interval(ab, ae, av.val));
						append(nbvs, interval(bb, ab, bv.val));
						append(nbvs, interval(ab, ae, bv.val));
						if(ae < be)
							push(bvs, interval(ae, be, bv.val));
						return loop(avs, bvs, navs, nbvs, cnt);
					}else
						error("confusion");
				}else{
					/* the remaining cases have symmetry with the above cases */
					[nbvs, navs] = loop(bvs, avs, nbvs, navs, cnt+1);
					return [navs, nbvs];
				}
			}
		}
		return loop(copy(avs), copy(bvs), [], [], 0);
	}

	@define zunion(avs, bvs, f)
	{
		@defloc loop(avs, bvs, rv)
		{
			if(length(avs) == 0)
				return concat(rv, bvs);
			else if(length(bvs) == 0)
				return concat(rv, avs);
			else{
				@local av, bv;
				av = avs[0];
				bv = bvs[0];
				if(av.beg < bv.beg){
					if(av.end > bv.beg)
						error("bug");
					pop(avs);
					append(rv, av);
					return loop(avs, bvs, rv);
				}else if(av.beg > bv.beg){
					if(bv.end > av.beg)
						error("bug");
					pop(bvs);
					append(rv, bv);
					return loop(avs, bvs, rv);
				}else{
					@local val;
					if(av.end != bv.end)
						error("bug");
					pop(avs);
					pop(bvs);
					val = f ? f(av.val, bv.val) : nil;
					append(rv, interval(av.beg, av.end, val));
					return loop(avs, bvs, rv);
				}
			}
		}
		[avs, bvs] = zshred(avs, bvs);
		return loop(avs, bvs, []);
	}

	@define zdiff(avs, bvs)
	{
		@defloc loop(avs, bvs, rv)
		{
			if(length(avs) == 0)
				return rv;
			else if(length(bvs) == 0)
				return concat(rv, avs);
			else{
				@local av, bv;
				av = avs[0];
				bv = bvs[0];
				if(av.beg < bv.beg){
					if(av.end > bv.beg)
						error("bug");
					pop(avs);
					append(rv, av);
					return loop(avs, bvs, rv);
				}else if(av.beg > bv.beg){
					if(bv.end > av.beg)
						error("bug");
					pop(bvs);
					return loop(avs, bvs, rv);
				}else{
					if(av.end != bv.end)
						error("bug");
					pop(avs);
					pop(bvs);
					return loop(avs, bvs, rv);				
				}
			}
		}
		if(!islist(avs))
			return zdiff([avs], bvs);
		if(!islist(bvs))
			return zdiff(avs, [bvs]);
		[avs, bvs] = zshred(avs, bvs);
		return loop(avs, bvs, []);
	}

	@define zunionall(all, f)
	{
		@local rv;
		rv = [];
		foreach(@lambda(ivs){ rv = zunion(rv, ivs, f); }, all);
		return rv;
	}

	@define zdump(ivs, fmt, args ...)
	{
		apply(printf, fmt, args);
		foreach(@lambda(iv){ printf("\t%a\n", iv); }, ivs);
	}

	@define mkpicktype(type)
	{
		@defloc pick(iv)
		{
			@local i, m;
			m = length(iv.val);
			for(i = 0; i < m; i++)
				if(iv.val[i] && @typeof(iv.val[i]) == type)
					return interval(iv.beg, iv.end, iv.val[i]);
				else if(iv.val[i])
					printf("rejecting idx %d of type %t\n", i, @typeof(iv.val[i]));
			error("no value of type %t", type);
		}
		return pick;
	}

	@define mkpickn(n)
	{
		@defloc pick(iv)
		{
			if(n > length(iv.val))
				error("no value at index %d\n", n);
			return interval(iv.beg, iv.end, iv.val[n]);
		}
		return pick;
	}
}
