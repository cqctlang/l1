

@defstx @init_profile() {
	@global profiles, profentries,elist_length,elist_slice,elist_map;
	profiles = mktab(@lambda() {
			 	return [0,  // count
					0,  // time
					0,  // expansions
					nil]; // location
			 });
	profentries = [:];
	elist_length = @lambda(el) {
		@local x;

		x=0;
		while(el != #[]) {
			x++;
			el=el[1];
		}
		return x;
	};
	elist_slice = @lambda(el, start, finish) {
		@local x,l,stx;

		x=0;
		while( (el != #[]) && (x<start)) {
			x++;
			el=el[1];	
		}
		if(x<start)
			error("elist_slice: elist too short for start");
		l=[];
		while( (el != #[]) && (x<finish)) {
			x++;
			append(l,el[0]);
		}
		if(x<finish)
			error("elist_slice: elist too short for finish");
		l=reverse(l);
		stx=#[];
		foreach(@lambda(v) {
			stx=mkstx('elist,v,stx);
		},l);
		return stx;
	};
	elist_map = @lambda(fn,el) {
		@local l,stx;

		l=[];
		while( el != #[] ) {
			append(l,el[0]);
			el = el[1];
		}
		l=map(fn,l);
		l=reverse(l);
		stx=#[];
		foreach(@lambda(v) {
			stx=mkstx('elist,v,stx);
		},l);
		return stx;
	};
	return #[];
}
@init_profile();

@defstx @profile(rest ...) body {

	@local ssym, rsym, lsym, nsym, bsym, csym, name, src, elist;
	@local goto_ret_block, have_ret;
	@local goto_break_block, have_break;
	@local goto_continue_block, have_continue;
	@local warp_block,unwarp_block;
	@local accounting_block;
	@local multi_rewriter;
	
	src = stxsrc(body);
		
	if(rest[0]) {
		name = rest[0];
		if(stxkind(name) != 'val)
			error("@profile: arg 0 must be a value");
	} else {
		if(isnil(src[1]))
			name = sprintfa("%s",src[0]);
		else
			name = sprintfa("%s:%d",src[0],src[1]);
		name=mkstxval(name);
	}

	if(stxkind(body[0][0]) != 'null) {
		error("error: %s%s syntax error: no bindings in profile body without a new block",
			src[0],
			isnil(src[1])?"":sprintfa(":%d", src[1]));
	}

	ssym=mkstxval(stxid(gensym()));
	lsym=gensym();
	nsym=gensym();
	rsym=gensym();
	bsym=gensym();
	csym=gensym();

	profiles[stxval(name)][2]++;
	profiles[stxval(name)][3] = src;

	elist = body[0][1];

	// todo:
	// handle break in switch
	// handle continue in loops
	// handle escapes with dynamic wind
	// handle recursion
	
	multi_rewriter = @lambda(v,isinner) {
		if(stxkind(v) == 'ret) {
			have_ret = 1;
			#`{ #,(rsym) = #,(v[0]); goto #,(lsym); };
		} else if( (stxkind(v) == 'break) && !isinner) {
			have_break = 1;
			#`{ goto #,(bsym); };	
		} else if( (stxkind(v) == 'continue) && !isinner) {
			have_continue = 1;
			#`{ goto #,(csym); };	
		} else if(stxkind(v) == 'scope) {
			#scope(multi_rewriter(v[0],isinner));
		} else if(stxkind(v) == 'block) {
			// return, continue, break are keywords
			// we don't need to check for aliases
			#block(v[0], multi_rewriter(v[1],isinner));
		} else if(stxkind(v) == 'if) {
			if(v[2])
				#if(v[0], multi_rewriter(v[1],isinner),
					  multi_rewriter(v[2],isinner));
			else
				#if(v[0], multi_rewriter(v[1],isinner));
		} else if(stxkind(v) == 'while) {
			#while(v[0], multi_rewriter(v[1],1));
		} else if(stxkind(v) == 'for) {
			#for(v[0], v[1], v[2], multi_rewriter(v[3],1));
		} else if(stxkind(v) == 'do) {
			#do(multi_rewriter(v[0],isinner,1), v[1]);
		} else if(stxkind(v) == 'elist) {
			elist_map(@lambda(v) { multi_rewriter(v,isinner); }, v);
		} else
			v;
		// comma forms can't contain statements. no
		// need to check there.
	};
	elist = elist_map(@lambda(v) { multi_rewriter(v, 0); }, elist);

	accounting_block = #`{
		{
			@local t,l;
	
			t = profiles[#,(name)];
			l = profentries[#,(ssym)];
			t[0]++;
			if(!isnil(l))
				t[1] += gettimeofday()-l;
			else
				fprintf(stderr,"@profile: accounting disrupted by non-local entry\n");
		}
	};

	if(have_ret)
		goto_ret_block=#`{
			#,(lsym):
				#,(accounting_block);
				return #,(rsym);
		};
	else
		goto_ret_block=#[];

	if(have_break) {
		goto_break_block=#`{
			#,(bsym):	
				#,(accounting_block);
				break;
		};
	} else
		goto_break_block=#[];

	if(have_continue) {
		goto_continue_block=#`{
			#,(csym):	
				#,(accounting_block);
				continue;
		};
	} else
		goto_continue_block=#[];

	if(have_ret || have_break || have_continue) {
		warp_block=#`{
			goto #,(nsym);
		};
		unwarp_block=#`{
			#,(nsym): ;
		};
	} else {
		warp_block=#[];
		unwarp_block=#[];
	}

	return #`{
		profentries[#,(ssym)]=gettimeofday();
		{ @global #,(rsym); }
		// just the elist, not the scope
		//#,(elist_pre);
		#,(rsym) = #,(elist); // this is unsound for recursive functions without dynamic wind
		#,(accounting_block);
		#,(warp_block);
		#,(goto_ret_block);
		#,(goto_break_block);
		#,(goto_continue_block);
		#,(unwarp_block);
		#,(rsym);
	};
}
