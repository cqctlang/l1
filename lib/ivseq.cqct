@global
	it2ivseq,
	ivseqdump,
	ivseqshred,
	ivseqjoin,
	ivseqlook,
	ivseqout,
	ivseqsplit,
	ivsequnion,
	ivsequnionall
;

rdsetfmt(@record instant { t, val },
	 @lambda(r) { sprintfa("@%d%s", r.t,
			       r.val == nil ? "" :
			       sprintfa(" %a", r.val)); });
rdsetfmt(@record interval { beg, end, val },
	 @lambda(r) { sprintfa("<@%d - @%d%s>", r.beg, r.end,
			       r.val == nil ? "" :
			       isprocedure(r.val) ? " *" :
			       sprintfa(" %a", r.val)); });
{

@define it2ivseq(its)
{
	@local it, nit, i, m, rv;
	m = length(its);
	if(m == 0)
		return [];
	if(m == 1)
		error("only one instant");
	it = its[0];
	rv = [];
	for(i = 1; i < m; i++){
		nit = its[i];
		append(rv, interval(it.t, nit.t, it.val));
		it = nit;
	}
	return rv;
}

/* split interval sequence into two sequences, before and after.
   before contains intervals before T (i.e., that end no later than T).
   after contains intervals at or after T.
   optional third argument MODE determines what happens
   if T occurs within an interval [B,E,V]:

   	'split :    it is split into [B,T,V] (which goes into before)
	            and [T,E,V] (which goes into after).
	'before :   [B,E,V] is added to before
	'after :    [B,E,V] is added to after
	'fail :     the call returns nil
*/
@define ivseqsplit(ivs, t, rest ...)
{
	@local before, mode;

	before = [];

	if(length(rest) > 0){
		if(length(rest) > 1)
			error("too many arguments");
		mode = rest[0];
		if(!ismember(['split, 'before, 'after, 'fail], mode))
			error("unknown mode: %a", mode);
	}else
		mode = 'split;

	@defloc loop(ivs)
	{
		@local iv;
		if(length(ivs) == 0)
			return [before, []];
		iv = ivs[0];
		if(iv.beg >= t)
			return [before, ivs];
		else if(iv.end <= t){
			pop(ivs);
			append(before, iv);
			return loop(ivs);
		}else
			switch(mode){
			case 'split:
				pop(ivs);
				append(before, interval(iv.beg, t, iv.val));
				push(ivs, interval(t, iv.end, iv.val));
				return loop(ivs);
			case 'before:
				pop(ivs);
				append(before, iv);
				return loop(ivs);
			case 'after:
				return [before, ivs];
			case 'fail:
				return [nil, nil];
			default:
				error("bug");
			}
	}
	return loop(copy(ivs));
}

@define ivseqlook(ivs, t)
{
	@local i, iv, m;
	m = length(ivs);
	for(i = 0; i < m; i++){
		iv = ivs[i];
		if(t < iv.beg)
			continue;
		if(t >= iv.beg && t < iv.end)
			return iv;
		if(t >= iv.end)
			continue;
	}
	return nil;
}

/* AVS and BVS are ivseqs.
   subdivide each so that no interval in AVS overlaps with
   one in BVS and vice-versa. */
@define ivseqshred(avs, bvs)
{
	@defloc loop(avs, bvs, navs, nbvs, cnt)
	{
		@local av, bv;
		@local ab, ae, bb, be;
		if(length(avs) == 0)
			return [navs, concat(nbvs, bvs)];
		else if(length(bvs) == 0)
			return [concat(navs, avs), nbvs];
		else{
			av = avs[0];
			bv = bvs[0];
			ab = av.beg;
			ae = av.end;
			bb = bv.beg;
			be = bv.end;

			if(ae <= bb){
				append(navs, pop(avs));
				return loop(avs, bvs, navs, nbvs, cnt);
			}else if(ab < bb && ae <= be){
				pop(avs);
				pop(bvs);
				append(navs, interval(ab, bb, av.val));
				append(navs, interval(bb, ae, av.val));
				append(nbvs, interval(bb, ae, bv.val));
				if(ae < be)
					push(bvs, interval(ae, be, bv.val));
				return loop(avs, bvs, navs, nbvs, cnt);
			}else if(ae <= be){
				if(ab == bb && ae == be){
					append(navs, pop(avs));
					append(nbvs, pop(bvs));
					return loop(avs, bvs, navs, nbvs, cnt);
				}else if(ab == bb && ae < be){
					pop(bvs);
					append(navs, pop(avs));
					append(nbvs, interval(bb, ae, bv.val));
					push(bvs, interval(ae, be, bv.val)); 
					return loop(avs, bvs, navs, nbvs, cnt);
				}else if(ab > bb && ae <= be){
					pop(avs);
					pop(bvs);
					append(navs, interval(ab, ae, av.val));
					append(nbvs, interval(bb, ab, bv.val));
					append(nbvs, interval(ab, ae, bv.val));
					if(ae < be)
						push(bvs, interval(ae, be, bv.val));
					return loop(avs, bvs, navs, nbvs, cnt);
				}else
					error("confusion");
			}else{
				/* the remaining cases have symmetry with the above cases */
				[nbvs, navs] = loop(bvs, avs, nbvs, navs, cnt+1);
				return [navs, nbvs];
			}
		}
	}
	return loop(copy(avs), copy(bvs), [], [], 0);
}

@define ivsequnion(avs, bvs, f)
{
	@defloc loop(avs, bvs, rv)
	{
		if(length(avs) == 0)
			return concat(rv, bvs);
		else if(length(bvs) == 0)
			return concat(rv, avs);
		else{
			@local av, bv;
			av = avs[0];
			bv = bvs[0];
			if(av.beg < bv.beg){
				if(av.end > bv.beg)
					error("bug");
				pop(avs);
				append(rv, av);
				return loop(avs, bvs, rv);
			}else if(av.beg > bv.beg){
				if(bv.end > av.beg)
					error("bug");
				pop(bvs);
				append(rv, bv);
				return loop(avs, bvs, rv);
			}else{
				@local val;
				if(av.end != bv.end)
					error("bug");
				pop(avs);
				pop(bvs);
				val = f ? f(av.val, bv.val) : nil;
				append(rv, interval(av.beg, av.end, val));
				return loop(avs, bvs, rv);
			}
		}
	}
	[avs, bvs] = ivseqshred(avs, bvs);
	return loop(avs, bvs, []);
}

@define ivseqout(avs, bvs)
{
	@defloc loop(avs, bvs, rv)
	{
		if(length(avs) == 0)
			return rv;
		else if(length(bvs) == 0)
			return concat(rv, avs);
		else{
			@local av, bv;
			av = avs[0];
			bv = bvs[0];
			if(av.beg < bv.beg){
				if(av.end > bv.beg)
					error("bug");
				pop(avs);
				append(rv, av);
				return loop(avs, bvs, rv);
			}else if(av.beg > bv.beg){
				if(bv.end > av.beg)
					error("bug");
				pop(bvs);
				return loop(avs, bvs, rv);
			}else{
				if(av.end != bv.end)
					error("bug");
				pop(avs);
				pop(bvs);
				return loop(avs, bvs, rv);				
			}
		}
	}
	[avs, bvs] = ivseqshred(avs, bvs);
	return loop(avs, bvs, []);
}

@define ivsequnionall(all, f)
{
	@local rv;
	rv = [];
	foreach(@lambda(ivs){ rv = ivsequnion(rv, ivs, f); }, all);
	return rv;
}

@define ivseqdump(ivs, fmt, args ...)
{
	apply(printf, fmt, args);
	foreach(@lambda(iv){ printf("\t%a\n", iv); }, ivs);
}


}

//	/* assume is is contained in iv */
//	@define invert(is, iv)
//	{
//		@local rv, b, e;
//		b = iv.beg;
//		e = iv.end;
//		rv = [];
//		foreach(@lambda(i){
//				if(i.beg < b)
//					error("bug");
//				if(i.end > e)
//					error("bug");
//				if(i.beg == b)
//					b = i.end;
//				else{
//					append(rv, interval(b, i.beg));
//					b = i.end;
//				}
//			}, is);
//		if(b < e)
//			append(rv, interval(b, e));
//		return rv;
//	}
//
//	@define clip(is, iv)
//	{
//		@local rv, b, e;
//		b = iv.beg;
//		e = iv.end;
//		rv = [];
//		foreach(@lambda(i){
//				/* draw a picture; there are six cases */
//				if(i.end <= b)
//					return;
//				if(i.beg >= e)
//					return;
//				if(i.beg >= b && i.end <= e)
//					append(rv, i);
//				else if(i.beg <= b && i.end >= e)
//					append(rv, interval(b, e));
//				else if(i.beg <= b && i.end < e)
//					append(rv, interval(b, i.end));
//				else if(i.beg < e && i.end >= e)
//					append(rv, interval(i.beg, e));
//				else
//					error("confusion");
//			}, is);
//		return rv;
//	}
//
//	@define indexof(is, t)
//	{
//		@defloc loop(is, n)
//		{
//			@local iv;
//			if(length(is) == 0)
//				return nil;
//			iv = pop(is);
//			if(t >= iv.beg && t < iv.end)
//				return n;
//			loop(is, n+1);
//		}
//		loop(copy(is), 0);
//	}
//
//	@define lookinterval(is, t)
//	{
//		@local i, iv, m;
//		m = length(is);
//		for(i = 0; i < m; i++){
//			iv = is[i];
//			if(t < iv.beg)
//				continue;
//			if(t >= iv.beg && t < iv.end)
//				return iv;
//			if(t >= iv.end)
//				continue;
//		}
//		return nil;
//	}
//
//	/* this function assumes the intervals are disjoint */
//	@define mergeivs(as, bs)
//	{
//		@local rv, a, b;
//	
//		as = copy(as);
//		bs = copy(bs);
//		rv = [];
//		a = pop(as);
//		b = pop(bs);
//		while(a && b){
//			if(a.beg < b.beg){
//				append(rv, a);
//				a = pop(as);
//			}else{
//				append(rv, b);
//				b = pop(bs);
//			}
//		}
//		while(a){
//			append(rv, a);
//			a = pop(as);
//		}
//		while(b){
//			append(rv, b);
//			b = pop(bs);
//		}
//		return rv;
//	}
//
