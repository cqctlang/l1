
packns = @names c32be {
	struct pack_header {
		@0x0	uint32 hdr_signature;
	       	@0x4	uint32 hdr_version;
		@0x8	uint32 hdr_entries;
		@0xc;
	};

	enum object_type {
		OBJ_BAD = -1,
		OBJ_NONE = 0,
		OBJ_COMMIT = 1,
		OBJ_TREE = 2,
		OBJ_BLOB = 3,
		OBJ_TAG = 4,
		/* 5 for future expansion */
		OBJ_OFS_DELTA = 6,
		OBJ_REF_DELTA = 7,
		OBJ_ANY,
		OBJ_MAX,
	};

	typedef char sha1[20];
};

gittypename = [ "", "commit", "tree", "blob", "tag", "",
		"ofsdelta", "refsdelta" ];

define dumppack(pack)
{
	@local p, q, i, c, b, type, size, zsize, infl, obj, off;

	p = (struct pack`pack_header*){pack}0;
	q = (char*)&p->hdr_signature;
	printf("signature: ");
	for(i = 0; i < 4; i++)
		printf("%c", q[i]);
	printf("\n");
	printf("version: %d\n", (char*)p->hdr_version);
	printf("entries: %d\n", (char*)p->hdr_entries);

	q = (unsigned char*)(p+1);
	for(i = 0; i < p->hdr_entries; i++){
		off = q;
		c = *q++;
		type = (c>>4)&7;
		size = (c&15);
		shift = 4;
		while(c&0x80){
//			printf("c = %x, size=%d, shift=%d\n", c, size, shift);
			c = *q++;
			size += (c&0x7f)<<shift;
			shift += 7;
		}
		if(type == pack`OBJ_REF_DELTA)
			q += 20; /* skip base sha1 */
		else if(type == pack`OBJ_OFS_DELTA){
			/* consume base offset.
			   this is not documented in the git pack format
			   documentation. */
			b = *q++;
			while(b&128)
				b = *q++;
		}
		infl = inflate(q);
		obj = infl[0];
		if(strlen(obj) != size)
			error("deflated object is %d bytes, expected %d",
			      size, strlen(obj));
		zsize = infl[1]+(q-off);
		q += infl[1];
		printf("%s %s %d %d %d\n",
		       sha1(sprintfa("%s %u\0%s",
				     gittypename[type],
				     size,
				     obj)),
		       gittypename[type],
		       size,
		       zsize,
		       off);
	}
}

as = mksas(mapfile(".git/objects/pack/pack-69e85119a854fd6a2ee39492c89badfbcea253c1.pack"));
pack = mkdom(packns, as);
dumppack(pack);

