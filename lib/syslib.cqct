/* native syscall replacements for system functions in l1 */
@include <sys.cqct>

mapfile = @lambda(filename, rest ...) {
  @local fd,st,p,r,s,m,f,fm;

  m = 0;
  f = unix`MAP_PRIVATE;
  if(length(rest) > 0) {
    @local mode;
    mode = rest[0];
    if(!isstring(mode)) {
	error("mode is not a string");
    }

    if(!isnil(strstr(mode,"p"))) f = unix`MAP_PRIVATE;
    if(!isnil(strstr(mode,"s"))) f = unix`MAP_SHARED;

    if(!isnil(strstr(mode,"r"))) m |= unix`PROT_READ;
    if(!isnil(strstr(mode,"w"))) m |= unix`PROT_WRITE;
  } else {
    m = unix`PROT_READ | unix`PROT_WRITE;
  }

  if( (f == unix`MAP_SHARED) && (m & unix`PROT_WRITE) )
  	if ( (m & unix`PROT_READ) || (m & unix`PROT_EXEC) )
		fm = unix`O_RDWR;
	else
		fm = unix`O_WRONLY;
  else if ( (m & unix`PROT_READ) || (m & unix`PROT_EXEC) )
	fm = unix`O_RDONLY;
  else
	error("mapping is neither shared nor for r or x. your arguments make no sense");
	
  fd=sys_open(filename,fm);
  if(0 > fd) {
    error("cannot open %s",filename);
  }

  st = (struct unix`stat *)malloc(sizeof(struct unix`stat));
  if(!st) {
    sys_close(fd);
    error("couldn't allocate stat buf");
  }

  if(0 > sys_fstat(fd,st)) {
    sys_close(fd);
    error("couldn't stat %s",filename);
  } 

  if(S_ISBLK(st)) {
    @local sb,r;

    sb=(uint64 *)malloc(8);
    if(!sb) {
      sys_close(fd);
      error("malloc failure");
    }
    *sb=0;
    if(looksym(unix,'BLKGETSIZE)) {
    	r=sys_ioctl(fd, unix`BLKGETSIZE, sb);
   	 if(r) {
                sys_close(fd);
    	 	error("couldn't determine size of block device %s", filename);
   	 }
    } else if(looksym(unix,'DKIOCGETBLOCKCOUNT)) {
    	r=sys_ioctl(fd, unix`DKIOCGETBLOCKCOUNT, sb);
   	 if(r) {
                sys_close(fd);
    	 	error("couldn't determine size of block device %s", filename);
   	 }
    }
    s=*sb * 512;
  } else {
    s = st->st_size;
  }

  p = sys_mmap(0, s, m, f, fd, 0);
  if(p == -1) {
    // we can try with noreserve on a platform that supports it
    if(looksym(unix,'MAP_NORESERVE)) {
      p = sys_mmap(0, s, m, unix`MAP_NORESERVE|f, fd, 0); 
    }
  }

  sys_close(fd);
  if(p == -1) {
    error("could not map %s",filename);
  }

  r=mkstrm(p, s);

  finalize(r,@lambda(args ...) {
    sys_munmap(p,s);
    nil;
  });

  r;

};

@global iohash;

iohash=[:];

open = @lambda(filename, mode) {
  @local flags,fd,newmode,nfd;

  if(!isstring(filename)) 	error("open: filename is not a string");
  if(!isstring(mode)) 		error("open: mode is not a string");
  if(1 > strlen(mode)) 		error("open: mode cannot be empty");

  if(    ( strstr(mode,"r") && strstr(mode,"w") )
      || ( strstr(mode,"r") && strstr(mode,"a") )
      || ( strstr(mode,"w") && strstr(mode,"a") ) )
    error("open: modes \"a\", \"w\", and \"r\" are exclusive");

  flags = 0;

  switch(mode[0]) {
  case 'r':
    if(strstr(mode,"+"))
      flags = unix`O_RDWR;
    else
      flags = unix`O_RDONLY;
    break;
  case 'w':
    if(strstr(mode,"+"))
      flags = unix`O_RDWR	| unix`O_CREAT	| unix`O_TRUNC;
    else
      flags = unix`O_WRONLY 	| unix`O_CREAT 	| unix`O_TRUNC;
    break;
  case 'a':
    if(strstr(mode,"+"))
      flags = unix`O_RDWR 	| unix`O_CREAT 	| unix`O_APPEND;
    else
      flags = unix`O_WRONLY 	| unix`O_CREAT 	| unix`O_APPEND;
    break;
  default:
    error("open: invalid mode: %a",mode);
  }
  
  fd=sys_open(filename,flags,0777);
  if(0 > fd) {
    return nil;
  } 

  newmode="";
  if( ((flags & unix`O_WRONLY) == unix`O_WRONLY) || 
      ((flags & unix`O_RDWR) == unix`O_RDWR) || 
      ((flags & unix`O_APPEND) == unix`O_APPEND) )
    newmode+="w";
  if( ((flags & unix`O_RDONLY) == unix`O_RDONLY) ||
      ((flags & unix`O_RDWR) == unix`O_RDWR) )
    newmode+="r";

  nfd=fdopen(fd,newmode);

  if(isnil(nfd)) {
    return nil;
  } else {
    @local k;

    k=weakcons(nfd,nil); 
    iohash[k]=fd;

    finalize(nfd,@lambda(args ...) {
      tabdelete(iohash,k);
      sys_close(fd);
    });
    
    return nfd;
  }

};

seek = @lambda(fd,pos,whence) {
  @local sfd,r;

  sfd=iohash[cons(fd,nil)];
  if(!isnil(sfd)) {
    r=sys_lseek(sfd,pos,whence); 
  } else {
    error("seek: seeking a cinquecento fd with no unix fd");
  }

  return r;
};

close = @lambda(fd) {
  @local sfd;

  sfd=iohash[cons(fd,nil)];
  if(!isnil(sfd)) {
    sys_close(sfd); 
  } else {
    error("close: closing a cinquecento fd with no unix fd");
  }
};

unlink = sys_unlink;

/* LINUX_REBOOT_CMD_RESTART RB_AUTOBOOT 0x1234567 */
/* LINUX_REBOOT_CMD_HALT RB_HALT_SYSTEM 0xcdef0123 */
/* LINUX_REBOOT_CMD_POWER_OFF 0x4321fedc */
/* LINUX_REBOOT_CMD_RESTART2 0xa1b2c3d4 */
/* LINUX_REBOOT_CMD_CAD_ON RB_ENABLE_CAD 0x89abcdef */
/* LINUX_REBOOT_CMD_CAD_OFF RB_DISABLE_CAD, 0 */
reboot = @lambda(cmd) {
  return sys_reboot(0xfee1dead,672274793,cmd,0);
};
