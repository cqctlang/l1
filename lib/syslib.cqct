/* native syscall replacements for system functions in l1 */
@include <sys.cqct>

mapfile = @lambda(filename, rest ...) {
  @local fd,st,p,r,s,m,f,fm;

  m = 0;
  f = unix`MAP_PRIVATE;
  if(length(rest) > 0) {
    @local mode;
    mode = rest[0];
    if(!isstring(mode)) {
	error("mode is not a string");
    }

    if(!isnil(strstr(mode,"p"))) f = unix`MAP_PRIVATE;
    if(!isnil(strstr(mode,"s"))) f = unix`MAP_SHARED;

    if(!isnil(strstr(mode,"r"))) m |= unix`PROT_READ;
    if(!isnil(strstr(mode,"w"))) m |= unix`PROT_WRITE;
  } else {
    m = unix`PROT_READ | unix`PROT_WRITE;
  }

  if( (f == unix`MAP_SHARED) && (m & unix`PROT_WRITE) )
  	if ( (m & unix`PROT_READ) || (m & unix`PROT_EXEC) )
		fm = unix`O_RDWR;
	else
		fm = unix`O_WRONLY;
  else if ( (m & unix`PROT_READ) || (m & unix`PROT_EXEC) )
	fm = unix`O_RDONLY;
  else
	error("mapping is neither shared nor for r or x. your arguments make no sense");
	
  fd=sys_open(filename,fm);
  if(0 > fd) {
    error("cannot open %s",filename);
  }

  st = (struct unix`stat *)malloc(sizeof(struct unix`stat));
  if(!st) {
    sys_close(fd);
    error("couldn't allocate stat buf");
  }

  if(0 > sys_fstat(fd,st)) {
    sys_close(fd);
    error("couldn't stat %s",filename);
  } 

  if(S_ISBLK(st)) {
    @local sb,r;

    sb=(uint64 *)malloc(8);
    if(!sb) {
      sys_close(fd);
      error("malloc failure");
    }
    *sb=0;
    if(looksym(unix,'BLKGETSIZE)) {
    	r=sys_ioctl(fd, unix`BLKGETSIZE, sb);
   	 if(r) {
                sys_close(fd);
    	 	error("couldn't determine size of block device %s", filename);
   	 }
    } else if(looksym(unix,'DKIOCGETBLOCKCOUNT)) {
    	r=sys_ioctl(fd, unix`DKIOCGETBLOCKCOUNT, sb);
   	 if(r) {
                sys_close(fd);
    	 	error("couldn't determine size of block device %s", filename);
   	 }
    }
    s=*sb * 512;
  } else {
    s = st->st_size;
  }

  if (s == 0)
  {
    //empty file, length zero mapping
    sys_close(fd);
    return "";
  }

  p = sys_mmap(0, s, m, f, fd, 0);
  if(p == -1) {
    // we can try with noreserve on a platform that supports it
    if(looksym(unix,'MAP_NORESERVE)) {
      p = sys_mmap(0, s, m, unix`MAP_NORESERVE|f, fd, 0); 
    }
  }

  sys_close(fd);
  if(p == -1) {
    error("could not map %s",filename);
  }

  r=mkstrm(p, s);

  finalize(r,@lambda(args ...) {
    sys_munmap(p,s);
    nil;
  });

  r;

};

@global iohash;

iohash=[:];

open = @lambda(filename, mode) {
  @local flags,oflags,fd,newmode,nfd;

  if(!isstring(filename)) 	error("open: filename is not a string");
  if(!isstring(mode)) 		error("open: mode is not a string");
  if(1 > strlen(mode)) 		error("open: mode cannot be empty");

  flags = 0;
  oflags = 0;

  if(!isnil(strstr(mode,"r")))
    flags |= 1;
  if((!isnil(strstr(mode,"w"))) || (!isnil(strstr(mode,"a"))))
    flags |= 2;
  if(!isnil(strstr(mode,"w")))
    oflags |= unix`O_CREAT|unix`O_TRUNC;
  if((flags&1) && (flags&2))                                     
    oflags |= unix`O_RDWR;                                               
  else if(flags&1)                                                    
    oflags |= unix`O_RDONLY;                                             
  else if(flags&2)                                                   
    oflags |= unix`O_WRONLY;                 

  fd=sys_open(filename,oflags,0777);
  if(0 > fd) {
    return nil;
  } 

  if((flags&1) && (flags&2)) {
    newmode="rw";
  } else if(flags&1) {
    newmode="r";
  } else if(flags&2) {
    newmode="w";
  } else {
    error("invalid mode");
  }

  nfd=fdopen(fd,newmode);

  if(isnil(nfd)) {
    return nil;
  } else {
    @local k;

    k=weakcons(nfd,nil); 
    iohash[k]=fd;

    finalize(nfd,@lambda(args ...) {
      tabdelete(iohash,k);
      sys_close(fd);
    });
    
    return nfd;
  }

};

seek = @lambda(fd,pos,whence) {
  @local sfd,r;

  sfd=iohash[cons(fd,nil)];
  if(!isnil(sfd)) {
    r=sys_lseek(sfd,pos,whence); 
  } else {
    error("seek: seeking a cinquecento fd with no unix fd");
  }

  return r;
};

close = @lambda(fd) {
  @local sfd;

  sfd=iohash[cons(fd,nil)];
  if(!isnil(sfd)) {
    sys_close(sfd); 
  } else {
    error("close: closing a cinquecento fd with no unix fd");
  }
};

unlink = sys_unlink;

/* LINUX_REBOOT_CMD_RESTART RB_AUTOBOOT 0x1234567 */
/* LINUX_REBOOT_CMD_HALT RB_HALT_SYSTEM 0xcdef0123 */
/* LINUX_REBOOT_CMD_POWER_OFF 0x4321fedc */
/* LINUX_REBOOT_CMD_RESTART2 0xa1b2c3d4 */
/* LINUX_REBOOT_CMD_CAD_ON RB_ENABLE_CAD 0x89abcdef */
/* LINUX_REBOOT_CMD_CAD_OFF RB_DISABLE_CAD, 0 */
reboot = @lambda(cmd) {
  return sys_reboot(0xfee1dead,672274793,cmd,0);
};

dirlist=@lambda(dirname) {
	@local readdir_size;
	@local buf;
	@local fd;
	@local ddom;
	@local count;
	@local l;
	@local start,end;
	
	readdir_size=512;

	buf=malloc(readdir_size);
	if(!buf) return nil;

	fd=sys_open(dirname,unix`O_RDONLY);
	if(fd==-1)
		return nil;

	ddom=mkdom(unix,asof(buf));
	buf={ddom}buf;

	l=[];

	while((count=(int)syscall(unix`getdents,fd,buf,readdir_size)) > 0) {

		start=buf;
		end=((unsigned char *)buf)+count;
		while(start<end) {
			start=(struct linux_dirent *)start;
			append(l,getbytes(start->d_name,strlen(start->d_name)));
			start=(struct linux_dirent *)(((unsigned char *)start)
				+ start->d_reclen);
		}	
	}

	return l;
};
