/* sctl messages */

@include <xsas.cqct>

sctl = @names clp64le {
	typedef
	enum Mkind {
		Reserved0 = 0,
		Rerror,
		Reserved2,
		Aevent,
		Tversion,
		Rversion,
		Tping,
		Rping,
		Tps,
		Rps,
		Tlaunch,
		Rlaunch,
		Tattach,
		Rattach,
		Tstat,
		Rstat,
		Tcont,
		Rcont,
		Tstop,
		Rstop,
		Tstep,
		Rstep,
		Tsnap,
		Rsnap,
		Tkill,
		Rkill,
		Tdetach,
		Rdetach,
		Ttrace,
		Rtrace,
		Tsettrap,
		Rsettrap,
		Tclrtrap,
		Rclrtrap,
		Tgetctx,
		Rgetctx,
		Tsetctx,
		Rsetctx,
		Tread,
		Rread,
		Twrite,
		Rwrite,
		Tlooksym,
		Rlooksym,
		Tenumsym,
		Renumsym,
		Tlooktype,
		Rlooktype,
		Tenumtype,
		Renumtype,
		Tlookaddr,
		Rlookaddr,
		Tenumloc,
		Renumloc,
		Tunwind,
		Runwind,
		Tenumseg,
		Renumseg,
		Tnames,
		Rnames,
	} Mkind;

	enum Mode {
		/* trap modes */
		Mbrk	= 0,
		Msnap	= 1,
	};
	enum Flags {
		/* launch flags */
		Fstdin   = 1,		  /* redirect stdin */
		Fstdout  = (Fstdin<<1),   /* redirect stdout */
		Fstderr  = (Fstdout<<1),  /* redirect stderr */
	};

	typedef
	enum Event {
		Eclear	 = 0,
		Eset	 = 1,
		Esyscall = (Eset<<1),
		Eexec	 = (Esyscall<<1),
		Efork    = (Eexec<<1),
		Eclone   = (Efork<<1),
		Esignal  = (Eclone<<1),
		Eexit    = (Esignal<<1),
		Etrap    = (Eexit<<1),
		Esnap	 = (Etrap<<1),
		Estepctx = (Esnap<<1),
		Eload	 = (Estepctx<<1),
		Eunload	 = (Eload<<1),
	} Event;

	typedef
	enum Prot {
		PROT_READ	= 0x1,		/* Page can be read.  */
		PROT_WRITE	= 0x2,		/* Page can be written.  */
		PROT_EXEC	= 0x4,		/* Page can be executed.  */
	} Prot;

	typedef
	enum Attrval {
		Astr,
		Acid,
		Auint,
	} Attrval;

	typedef
	enum Cbase
	{
		Vundef=0,
		Vlo,
		Vbool=Vlo,
		Vchar,
		Vshort,
		Vint,
		Vlong,
		Vvlong,
		Vuchar,
		Vushort,
		Vuint,
		Vulong,
		Vuvlong,
		Vfloat,
		Vdouble,
		Vlongdouble,
		Vnbase,
		Vptr = Vnbase,		/* alias for some other base type */
		Vvoid,
		Vnallbase,
	} Cbase;

	/* base type representations */
	typedef
	enum Rkind
	{
		Rundef,
		Ru08le,
		Ru16le,
		Ru32le,
		Ru64le,
		Rs08le,
		Rs16le,
		Rs32le,
		Rs64le,
		Ru08be,
		Ru16be,
		Ru32be,
		Ru64be,
		Rs08be,
		Rs16be,
		Rs32be,
		Rs64be,
		Rf32,
		Rf64,
		Rf128,
		Rnrep,
	} Rkind;
	
	typedef
	enum Tkind
	{
		Tvoid = 0,
		Tbase = 1,
		Tstruct = 2,
		Tunion = 3,
		Tenum = 4,
		Tptr = 5,
		Tarr = 6,
		Tfun = 7,
		Ttypedef = 8,
		Tbitfield = 9,
		Tconst = 10,
		Txaccess = 11,		/* unused */
		Tundef = 12,
	} Tkind;

	enum Stype
	{
		Sundef = 1,
		Sdata = Sundef<<1,
		Stext = Sdata<<1,
		Sro = Stext<<1,
		Senum = Sro<<1,
		Sinline = Senum<<1,
	};

	enum ELF_SHN {
		SHN_UNDEF	= 0,
		SHN_ABS		= 0xfff1,
		SHN_COMMON	= 0xfff2,
	};

	/* FIXME: this type needs to be a parameter of the name space
	   (maybe it goes in the parent?) */
	typedef
	struct Ctx {
		/* kernel's register set */
		@0x0	uint64 r15;
		@0x8	uint64 r14;
		@0x10	uint64 r13;
		@0x18	uint64 r12;
		@0x20	uint64 rbp;
		@0x28	uint64 rbx;
		@0x30	uint64 r11;
		@0x38	uint64 r10;
		@0x40	uint64 r9;
		@0x48	uint64 r8;
		@0x50	uint64 rax;
		@0x58	uint64 rcx;
		@0x60	uint64 rdx;
		@0x68	uint64 rsi;
		@0x70	uint64 rdi;
		@0x78	uint64 orig_rax;
		@0x80	uint64 rip;
		@0x88	uint64 cs;
		@0x90	uint64 eflags;
		@0x98	uint64 rsp;
		@0xa0	uint64 ss;
		@0xa8	uint64 fs_base;
		@0xb0	uint64 gs_base;
		@0xb8	uint64 ds;
		@0xc0	uint64 es;
		@0xc8	uint64 fs;
		@0xd0	uint64 gs;

		/* current signal number */
		@0xd8	uint64 sig;
		@0xe0; /* 224 */
	} Ctx;

	struct Tversion{
		@0	uint8 op;
		@1	uint32 tag;
		@5;
	};
	typedef struct Tversion Tversion;
	typedef struct Tversion Rversion;

	struct Rerror{
		@0	uint8 op;
		@1	uint32 tag;
		@5	char err[0];
		@5	char bytes[0];
		@5;
	};
	typedef struct Rerror Rerror;
	typedef struct Rerror Rread;

	struct Rcont {
		@0	uint8 op;
		@1	uint32 tag;
		@5;
	};
	typedef struct Rcont Rcont;
	typedef struct Rcont Rclrtrap;
	typedef struct Rcont Rdetach;
	typedef struct Rcont Rkill;
	typedef struct Rcont Rsetctx;
	typedef struct Rcont Rtrace;

	struct Rstop {
		@0	uint8 op;
		@1	uint32 tag;
		@5	Ctx ctx;
		@229;
	};
	typedef struct Rstop Rstop;
	typedef struct Rstop Rgetctx;

	struct Rstep {
		@0	uint8 op;
		@1	uint32 tag;
		@5	Ctx ctx;
		@229;
	};
	typedef struct Rstep Rstep;

	struct Tlaunch{
		@0	uint8 op;
		@1	uint32 tag;
		@5;
	};
	typedef struct Tlaunch Tlaunch;
	typedef struct Tlaunch Tps;
	typedef struct Tlaunch Rps;

	struct Ttrace{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@13;
	};
	typedef struct Ttrace Ttrace;

	struct Rlaunch{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@13	Ctx ctx;
		@237;
	};
	typedef struct Rlaunch Rlaunch;
	typedef struct Rlaunch Rattach;
	typedef struct Rlaunch Tsetctx;

	struct Tcont{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@5	uint64 cnt;
		@13;
	};
	typedef struct Tcont Tcont;
	typedef struct Tcont Tstop;
	typedef struct Tcont Tattach;
	typedef struct Tcont Tkill;
	typedef struct Tcont Tsnap;
	typedef struct Tcont Tdetach;
	typedef struct Tcont Tstep;
	typedef struct Tcont Tstat;
	typedef struct Tcont Rwrite;
	typedef struct Tcont Rping;
	typedef struct Tcont Tgetctx;

	struct Tsettrap{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@13;
	};
	typedef struct Tsettrap Tsettrap;

	struct Tclrtrap{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@13	uint64 tid;
		@21;
	};
	typedef struct Tclrtrap Tclrtrap;

	struct Rsettrap{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 tid;
		@13;
	};
	typedef struct Rsettrap Rsettrap;

	struct Rsnap{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 cid;
		@13	Ctx ctx;
		@237;
	};
	typedef struct Rsnap Rsnap;

	struct Aevent{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@13	uint64 flags;
		@21;
	};
	typedef struct Aevent Aevent;

	struct Esyscall {
		@0	Ctx ctx;
		@224;
	};
	typedef struct Esyscall Esyscall;

	struct Eexit {
		@0;
	};
	typedef struct Eexit Eexit;

	struct Etrap {
		@0	uint64 tid;
		@8	Ctx ctx;
		@232;
	};
	typedef struct Etrap Etrap;
	typedef struct Etrap Eexec;

	struct Esnap {
		@0	uint64 tid;
		@8	uint64 cid;
		@16	Ctx ctx;
		@240;
	};
	typedef struct Esnap Esnap;

	struct Esignal {
		@0	Ctx ctx;
		@224;
	};
	typedef struct Esignal Esignal;

	struct Efork {
		@0	uint64 cid;
		@8	Ctx ctx;
		@232	Ctx cctx;
		@456;
	};
	typedef struct Efork Efork;
	typedef struct Efork Eclone;

	struct Eload {
		/* parse by hand */
		@0;
	};
	typedef struct Eload Eload;

	struct Eunload {
		/* parse by hand */
		@0;
	};
	typedef struct Eunload Eunload;

	struct Tread{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@13	uint64 fd;
		@21     uint64 addr;
		@29	uint64 cnt;
		@37;
	};
	typedef struct Tread Tread;

	struct Twrite{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;
		@13	uint64 fd;
		@21     uint64 addr;
		@29	char bytes[0];
		@29;
	};
	typedef struct Twrite Twrite;

	struct Rstat{
		@0	uint8 op;
		@1	uint32 tag;
		@5	char bytes[0];
		@5;
	};
	typedef struct Rstat Rstat;
	typedef struct Rstat Tping;

	struct Tns{
		@0	uint8 op;
		@1	uint32 tag;
		@5	char bytes[0];
		@5;
	};
	typedef struct Tns Tlooksym;
	typedef struct Tns Tenumsym;
	typedef struct Tns Tlooktype;
	typedef struct Tns Tenumtype;
	typedef struct Tns Tlookaddr;
	typedef struct Tns Tenumloc;
	typedef struct Tns Tunwind;
	typedef struct Tns Tenumseg;
	typedef struct Tns Tnames;
	typedef struct Tns Rlooksym;
	typedef struct Tns Renumsym;
	typedef struct Tns Rlooktype;
	typedef struct Tns Renumtype;
	typedef struct Tns Rlookaddr;
	typedef struct Tns Renumloc;
	typedef struct Tns Runwind;
	typedef struct Tns Renumseg;

	struct Rnames{
		@0	uint8 op;
		@1	uint32 tag;
		@5	uint64 id;		
		@13;
	};
	typedef struct Rnames Rnames;
};

@record region {
	file,
	addr,
	len,
	flags,
};

@record dll {
	id,
	path,
	base,
};

@record loc {
	id,
	sz,
	ltype,
	loc,
	type,
};

@record seg {
	addr,
	len,
	name,
};

@record symrec {
	id,
	flags,
	val,
	attrs,
	sz,
	type,
};

@define encodes(p, s)
{
	@local m;
	m = strlen(s);
	p = (`uint64*)p;
	*p++ = m;
	p = (char*)p;
	putbytes(p, s);
	p += m;
	return p;
}

@define decodes(p)
{
	@local sz, s;
	p = (`uint64*)p;
	sz = *p++;
	s = getbytes(p, sz);
	p = (`uint8*)((char*)p+sz);
	return [s, p];
}

@define encodeattrs(p, attrs)
{
	@local na;

	@defloc canencode(v)
	{
		/* never encode an attribute named "offset" */
		if(v == "offset" || v == 'offset)
			return 0;
		return (iscvalue(v) || isstring(v) || iscid(v));
	}

	@defloc encodev(p, v)
	{
		p = (`uint8*)p;
		if(iscvalue(v)){
			*p++ = sctl`Auint;
			p = (`uint64*)p;
			*p++ = (`uint64)v;
		}else if(isstring(v)){
			*p++ = sctl`Astr;
			p = encodes(p, v);
		}else if(iscid(v)){
			*p++ = sctl`Acid;
			p = encodes(p, cid2str(v));
		}else
			error("cannot encode value %a", v);
		return p;
	}

	p = (`uint64*)p;

	/* parameter attributes may be nil (we'll
	   decode them as empty tables because we
	   separate the offset for field and symbol
	   attributes) */
	if(attrs == nil){
		*p++ = 0;
		return p;
	}

	na = 0;
	foreach(@lambda(k, v){ if(canencode(k) && canencode(v)) na++; }, attrs);
	*p++ = na;

	foreach(@lambda(k, v) { 
			if(!canencode(k) || !canencode(v))
				return;
			p = encodev(p, k);
			p = encodev(p, v);
		}, attrs);
	return p;
}

@define decodeattrs(p)
{
	@local tab, na, i, k, v;

	@defloc decodev(p)
	{
		@local e, v;
		p = (`uint8*)p;
		e = *p++;
		switch(e){
		case sctl`Auint:
			p = (`uint64*)p;
			v = *p++;
			return [v, p];
		case sctl`Astr:
			return decodes(p);
		case sctl`Acid:
			[v, p] = decodes(p);
			return [mkcid(v), p];
		default:
			error("unrecognized attribute value type: %d", e);
		}
	}

	tab = [:];
	p = (`uint64*)p;
	na = *p++;
	for(i = 0; i < na; i++){
		[k, p] = decodev(p);
		[v, p] = decodev(p);
		tab[k] = v;
	}
	return [tab, p];
}

@define encodesym(p, sym)
{
	@local flags;
	p = (`uint64*)p;

	/* id */
	p = encodes(p, cid2str(symid(sym)));
	
	/* flags */
	flags = (`uint8)0;
	if(isenumconst(symtype(sym)))
		flags |= sctl`Senum;
	p = (`uint8*)p;
	*p++ = flags;
	
	/* val */
	p = (`uint64*)p;
	*p++ = symoff(sym);

	/* attrs */
	p = encodeattrs(p, symattr(sym));

	/* size */
	*p++ = 0;
	
	/* typename */
	p = encodetname(p, symtype(sym));

	return p;
}

@define decodesym(p)
{
	@local id, f, v, sz, t, at;

	p = (`uint64*)p;
	[id, p] = decodes(p);
	p = (`uint8*)p;
	f = *p++;
	p = (`uint64*)p;
	v = *p++;
	[at, p] = decodeattrs(p);
	at["offset"] = v;
	sz = *p++;
	[t, p] = decodetname(p);
	return [symrec(mkcid(id), f, v, at, sz, t), p];
}

@define encodefield(p, f)
{
	p = (`uint64*)p;
	*p++ = fieldoff(f);
	p = encodeattrs(p, fieldattr(f));
	p = encodes(p, cid2str(fieldid(f)));
	p = encodetname(p, fieldtype(f));
	return p;
}

@define decodefield(p)
{
	@local off, at, id, st;
	p = (`uint64*)p;
	off = *p++;
	[at, p] = decodeattrs(p);
	[id, p] = decodes(p);
	[st, p] = decodetname(p);
	at["offset"] = off;
	return [mkfield(st, mkcid(id), at), p];
}

@define encodeparam(p, par)
{
	@local id;
	p = encodeattrs(p, paramattr(par));
	id = paramid(par);
	if(id == nil)
		p = encodes(p, "");
	else
		p = encodes(p, cid2str(id));
	p = encodetname(p, paramtype(par));
	return p;
}

@define decodeparam(p)
{
	@local sid, at, pt, par;
	[at, p] = decodeattrs(p);
	[sid, p] = decodes(p);
	[pt, p] = decodetname(p);
	par = mkparam(pt, strlen(sid) > 0 ? mkcid(sid) : nil, at);
	return [par, p];
}

@define encodetname(p, t)
{
	@local m;
	p = (`uint8*)p;
	if(isbase(t)){
		*p++ = cqct`Tbase;
		*p++ = (`uint8)basebase(t);
		return p;
	}else if(issu(t) || isenum(t)){
		if(isstruct(t))
			*p++ = cqct`Tstruct;
		else if(isunion(t))
			*p++ = cqct`Tunion;
		else if(isenum(t))
			*p++ = cqct`Tenum;
		else
			error("bug");
		return encodes(p, cid2str(suetag(t)));
	}else if(istypedef(t)){
		*p++ = cqct`Ttypedef;
		return encodes(p, cid2str(typedefid(t)));
	}else if(isptr(t)){
		*p++ = cqct`Tptr;
		return encodetname(p, subtype(t));
	}else if(isarray(t)){
		*p++ = cqct`Tarr;
		p = (`uint64*)p;
		m = arraynelm(t);
		if(m == nil)
			*p++ = 0; /* FIXME: maybe want escape */
		else
			*p++ = m;
		return encodetname(p, subtype(t));
	}else if(isfunc(t)){
		*p++ = cqct`Tfun;
		p = encodetname(p, rettype(t));
		p = (`uint64*)p;
		*p++ = length(params(t));
		foreach(@lambda(par){ p = encodeparam(p, par); }, params(t));
		return p;
	}else if(isvoid(t)){
		*p++ = cqct`Tbase;
		*p++ = (`uint8)cqct`Vvoid;
		return p;
	}else if(isundeftype(t)){
		*p++ = cqct`Tundef;
		return encodetname(p, subtype(t));
	}else if(isenumconst(t)){
		*p++ = cqct`Tconst;
		return encodetname(p, subtype(t));
	}else if(isbitfield(t)){
		*p++ = cqct`Tbitfield;
		p = (`uint8*)p;
		*p++ = bitfieldwidth(t);
		*p++ = bitfieldpos(t);
		p = encodetname(p, bitfieldcontainer(t));
		return p;
	}else
		error("unhandled type name %t", t);
}

@define encodetdef(p, t)
{
	printf("encoding %t\n", t);

	p = (`uint8*)p;
	if(isbase(t)){
		*p++ = cqct`Tbase;
		*p++ = (`uint8)basebase(t);
		*p++ = (`uint8)baserep(t);
		return p;
	}else if(issu(t)){
		if(isstruct(t))
			*p++ = cqct`Tstruct;
		else if(isunion(t))
			*p++ = cqct`Tunion;
		p = encodes(p, cid2str(suetag(t)));
		p = (`uint64*)p;
		*p++ = susize(t);
		p = encodeattrs(p, suattr(t));
		*p++ = length(fields(t));
		foreach(@lambda(f){ p = encodefield(p, f); }, fields(t));
		return p;
	}else if(isenum(t)){
		*p++ = cqct`Tenum;
		p = encodes(p, cid2str(suetag(t)));
		p = (`uint8*)p;
		*p++ = baserep(subtype(t));
		p = (`uint64*)p;
		*p++ = length(enumconsts(t));
		foreach(@lambda(ec){
				p = encodes(p, cid2str(ec[0]));
				p = (`uint64*)p;
				*p++ = ec[1];
			}, enumconsts(t));
		return p;
	}else if(istypedef(t)){
		*p++ = cqct`Ttypedef;
		p = encodes(p, cid2str(typedefid(t)));
		p = encodetname(p, typedeftype(t));
		return p;
	}else if(isptr(t)){
		if(!isvoid(subtype(t)))
			error("unhandled type definition %t", t);
		/* void* is special case of Tbase */
		*p++ = cqct`Tbase;
		*p++ = (`uint8)basebase(t);
		*p++ = (`uint8)baserep(t);
		return p;
	}else
		error("unhandled type definition %t", t);
}

@define decodetname(q)
{
	@local k, cb, id, w, pos, st, par, n, v, i;

	q = (`uint8*)q;
	k = *q++;
	switch(k){
	case cqct`Tbase:
		cb = *q++;
		return [mkctype_base(cb), q];
	case cqct`Tstruct:
		[id, q] = decodes(q);
		return [mkctype_struct(mkcid(id)), q];
	case cqct`Tunion:
		[id, q] = decodes(q);
		return [mkctype_union(mkcid(id)), q];
	case cqct`Tenum:
		[id, q] = decodes(q);
		return [mkctype_enum(mkcid(id)), q];
	case cqct`Ttypedef:
		[id, q] = decodes(q);
		return [mkctype_typedef(mkcid(id)), q];
	case cqct`Tptr:
		[st, q] = decodetname(q);
		return [mkctype_ptr(st), q];
	case cqct`Tconst:
		[st, q] = decodetname(q);
		return [mkctype_const(st), q];
	case cqct`Tarr:
		q = (`uint64*)q;
		n = *q++;
		[st, q] = decodetname(q);
		return [mkctype_array(st, n), q];
	case cqct`Tfun:
		[st, q] = decodetname(q);
		q = (`uint64*)q;
		n = *q++;
		v = mkvec(n);
		for(i = 0; i < n; i++){
			[par, q] = decodeparam(q);
			v[i] = par;
		}
		return [mkctype_fn(st, v), q];
	case cqct`Tbitfield:
		q = (`uint8*)q;
		w = *q++;
		pos = *q++;
		[st, q] = decodetname(q);
		return [mkctype_bitfield(st, w, pos), q];
	case cqct`Tundef:
		[st, q] = decodetname(q);
		return [mkctype_undef(st), q];
	default:
		error("decodetname: unhandled case %d", k);
	}
}

@define decodetdef(ns, q)
{
	@local k, cb, rep, sz, n, i, v, f, par, id, sid, c, mk, at, st;
	@local w, pos;

	q = (`uint8*)q;
	k = *q++;
	switch(k){
	case cqct`Tbase:
		cb = *q++;
		rep = *q++;
		return [mkctype_base(cb, rep), q];
	case cqct`Tstruct:
	case cqct`Tunion:
		if(k == cqct`Tstruct)
			mk = mkctype_struct;
		else
			mk = mkctype_union;
		[id, q] = decodes(q);
		q = (`uint64*)q;
		sz = *q++;
		[at, q] = decodeattrs(q);
		q = (`uint64*)q;
		n = *q++;
		v = mkvec(n);
		for(i = 0; i < n; i++){
			[f, q] = decodefield(q);
			v[i] = f;
		}
		at["offset"] = sz;
		return [mk(mkcid(id), v, at), q];
	case cqct`Tenum:
		[id, q] = decodes(q);
		q = (`uint8*)q;
		rep = *q++;
		q = (`uint64*)q;
		n = *q++;
		st = nsreptype(ns, rep);
		if(st == nil)
			error("no base type for rep %d", rep);
		v = mkvec(n);
		for(i = 0; i < n; i++){
			[sid, q] = decodes(q);
			q = (`uint64*)q;
			c = *q++;
			v[i] = vector(mkcid(sid), {st}c);
		}
		return [mkctype_enum(mkcid(id), v, st), q];
	case cqct`Tptr:
		[st, q] = decodetname(q);
		return [mkctype_ptr(st, nsptr(ns)), q];
	case cqct`Tconst:
		[st, q] = decodetname(q);
		return [mkctype_const(st), q];
	case cqct`Tarr:
		q = (`uint64*)q;
		n = *q++;
		[st, q] = decodetname(q);
		return [mkctype_array(st, n), q];
	case cqct`Tfun:
		[st, q] = decodetname(q);
		q = (`uint64*)q;
		n = *q++;
		v = mkvec(n);
		for(i = 0; i < n; i++){
			[par, q] = decodeparam(q);
			v[i] = par;
		}
		return [mkctype_fn(st, v), q];
	case cqct`Ttypedef:
		[id, q] = decodes(q);
		[st, q] = decodetname(q);
		return [mkctype_typedef(mkcid(id), st), q];
	case cqct`Tbitfield:
		q = (`uint64*)q;
		w = *q++;
		pos = *q++;
		[st, q] = decodetname(q);
		return [mkctype_bitfield(st, w, pos), q];
	default:
		error("decodetdef: unhandled case %d", k);
	}
}

@define buf2msg(p)
{
	@local op;
	op = (enum sctl`Mkind)*(sctl`uint8*)p;
	switch(op){
	case sctl`Aevent:
		return (sctl`Aevent*)p;
	case sctl`Rerror:
		return (sctl`Rerror*)p;
	case sctl`Tversion:
		return (sctl`Tversion*)p;
	case sctl`Rversion:
		return (sctl`Rversion*)p;
	case sctl`Tps:
		return (sctl`Tps*)p;
	case sctl`Rps:
		return (sctl`Rps*)p;
	case sctl`Tlaunch:
		return (sctl`Tlaunch*)p;
	case sctl`Rlaunch:
		return (sctl`Rlaunch*)p;
	case sctl`Tcont:
		return (sctl`Tcont*)p;
	case sctl`Rcont:
		return (sctl`Rcont*)p;
	case sctl`Tstop:
		return (sctl`Tstop*)p;
	case sctl`Rstop:
		return (sctl`Rstop*)p;
	case sctl`Tkill:
		return (sctl`Tkill*)p;
	case sctl`Rkill:
		return (sctl`Rkill*)p;
	case sctl`Tdetach:
		return (sctl`Tdetach*)p;
	case sctl`Rdetach:
		return (sctl`Rdetach*)p;
	case sctl`Tsettrap:
		return (sctl`Tsettrap*)p;
	case sctl`Rsettrap:
		return (sctl`Rsettrap*)p;
	case sctl`Tclrtrap:
		return (sctl`Tclrtrap*)p;
	case sctl`Rclrtrap:
		return (sctl`Rclrtrap*)p;
	case sctl`Tread:
		return (sctl`Tread*)p;
	case sctl`Rread:
		return (sctl`Rread*)p;
	case sctl`Tsnap:
		return (sctl`Tsnap*)p;
	case sctl`Rsnap:
		return (sctl`Rsnap*)p;
	case sctl`Twrite:
		return (sctl`Twrite*)p;
	case sctl`Rwrite:
		return (sctl`Rwrite*)p;
	case sctl`Tgetctx:
		return (sctl`Tgetctx*)p;
	case sctl`Rgetctx:
		return (sctl`Rgetctx*)p;
	case sctl`Tsetctx:
		return (sctl`Tsetctx*)p;
	case sctl`Rsetctx:
		return (sctl`Rsetctx*)p;
	case sctl`Tattach:
		return (sctl`Tattach*)p;
	case sctl`Rattach:
		return (sctl`Rattach*)p;
	case sctl`Tping:
		return (sctl`Tping*)p;
	case sctl`Rping:
		return (sctl`Rping*)p;
	case sctl`Tstep:
		return (sctl`Tstep*)p;
	case sctl`Rstep:
		return (sctl`Rstep*)p;
	case sctl`Ttrace:
		return (sctl`Ttrace*)p;
	case sctl`Rtrace:
		return (sctl`Rtrace*)p;
	case sctl`Tstat:
		return (sctl`Tstat*)p;
	case sctl`Rstat:
		return (sctl`Rstat*)p;
	case sctl`Tlooksym:
		return (sctl`Tlooksym*)p;
	case sctl`Rlooksym:
		return (sctl`Rlooksym*)p;
	case sctl`Tenumsym:
		return (sctl`Tenumsym*)p;
	case sctl`Renumsym:
		return (sctl`Renumsym*)p;
	case sctl`Tenumtype:
		return (sctl`Tenumtype*)p;
	case sctl`Renumtype:
		return (sctl`Renumtype*)p;
	case sctl`Tunwind:
		return (sctl`Tunwind*)p;
	case sctl`Runwind:
		return (sctl`Runwind*)p;
	case sctl`Tnames:
		return (sctl`Tnames*)p;
	case sctl`Rnames:
		return (sctl`Rnames*)p;
	case sctl`Tlooktype:
		return (sctl`Tlooktype*)p;
	case sctl`Rlooktype:
		return (sctl`Rlooktype*)p;
	case sctl`Tlookaddr:
		return (sctl`Tlookaddr*)p;
	case sctl`Rlookaddr:
		return (sctl`Rlookaddr*)p;
	case sctl`Tenumloc:
		return (sctl`Tenumloc*)p;
	case sctl`Renumloc:
		return (sctl`Renumloc*)p;
	case sctl`Tenumseg:
		return (sctl`Tenumseg*)p;
	case sctl`Renumseg:
		return (sctl`Renumseg*)p;
	default:
		error("unknown op %e", op);
	}
}

nexttag = 0;
@define freshtag()
{
	return nexttag++;
}

@define fmtmsg(msg, sz)
{
	@local s, q, tn, td, nsid, id, n, a;
	@local f, val, xsz;

	msg = buf2msg(msg);
	s = sprintfa("%e %d (%d bytes)",
		     (enum sctl`Mkind)msg->op, msg->tag, sz);
	switch((enum sctl`Mkind)msg->op){
	case sctl`Aevent:
	case sctl`Tps:
	case sctl`Rps:
	case sctl`Tlaunch:
	case sctl`Rlaunch:
	case sctl`Tcont:
	case sctl`Rcont:
	case sctl`Tstop:
	case sctl`Rstop:
	case sctl`Tkill:
	case sctl`Rkill:
	case sctl`Tdetach:
	case sctl`Rdetach:
	case sctl`Tsettrap:
	case sctl`Rsettrap:
	case sctl`Tclrtrap:
	case sctl`Rclrtrap:
	case sctl`Tread:
	case sctl`Rread:
	case sctl`Tsnap:
	case sctl`Rsnap:
	case sctl`Twrite:
	case sctl`Rwrite:
	case sctl`Tgetctx:
	case sctl`Rgetctx:
	case sctl`Tsetctx:
	case sctl`Rsetctx:
	case sctl`Tattach:
	case sctl`Rattach:
	case sctl`Tstep:
	case sctl`Rstep:
	case sctl`Ttrace:
	case sctl`Rtrace:
	case sctl`Tstat:
	case sctl`Rstat:
	case sctl`Tping:
	case sctl`Rping:
		break;
	case sctl`Rerror:
		s += sprintfa(" %s", getbytes(msg+1, sz-sizeof(sctl`Rerror)));
		break;
	case sctl`Tversion:
		s += sprintfa(" %s", getbytes(msg+1, sz-sizeof(sctl`Tversion)));
		break;
	case sctl`Rversion:
		s += sprintfa(" %s", getbytes(msg+1, sz-sizeof(sctl`Rversion)));
		break;
	case sctl`Tlooksym:
		q = msg+1;
		q = (`uint64*)q;
		nsid = *q++;
		[id, q] = decodes(q);
		s += sprintfa(" nsid=%u sym=%s", nsid, id);
		break;
	case sctl`Rlooksym:
		q = msg+1;
		[id, q] = decodes(q);
		q = (`uint8*)q;
		f = *q++;
		q = (`uint64*)q;
		val = *q++;
		xsz = *q++;
		[tn, q] = decodetname(q);
		s += sprintfa(" id=%s flags=%x val=%x sz=%x tname=%t",
			      id, f, val, xsz, tn);
		break;
	case sctl`Renumsym:
		q = msg+1;
		q = (`uint64*)q;
		n = *q++;
		s += sprintfa(" ns=%u syms=...", n);
		break;
	case sctl`Tenumsym:
	case sctl`Tenumtype:
		q = msg+1;
		q = (`uint64*)q;
		id = *q++;
		s += sprintfa(" nsid=%u", id);
		break;
	case sctl`Renumtype:
		q = msg+1;
		q = (`uint64*)q;
		n = *q++;
		s += sprintfa(" nt=%u tdefs=...", n);
		break;
	case sctl`Tunwind:
	case sctl`Runwind:
		break;
	case sctl`Tnames:
		q = msg+1;
		[id, q] = decodes(q);
		s += sprintfa(" path=%s", id);
		break;
	case sctl`Rnames:
		s += sprintfa(" nsid=%u", msg->id);
		break;
	case sctl`Tlooktype:
		q = msg+1;
		q = (`uint64*)q;
		id = *q++;
		[tn, q] = decodetname(q);
		s += sprintfa(" nsid=%u tname=%t", id, tn);
		break;
	case sctl`Rlooktype:
		q = msg+1;
		/* pass arbitrary name space to allow decode to occur */
		[td, q] = decodetdef(clp64le, q);
		s += sprintfa(" tdef=%t", td);
		break;
	case sctl`Tlookaddr:
		q = msg+1;
		q = (`uint64*)q;
		id = *q++;
		a = *q++;
		s += sprintfa(" nsid=%u addr=%x", id, a);
		break;
	case sctl`Rlookaddr:
	case sctl`Tenumloc:
	case sctl`Renumloc:
	case sctl`Tenumseg:
	case sctl`Renumseg:
		break;
	default:
		error("unknown op %e", (enum sctl`Mkind)msg->op);
	}
	return s;
}

@define sendmsg(fd, arg ...)
{
	@local p, sz;
	p = arg[0];
	switch(length(arg)){
	case 1:
		sz = sizeof(*p);
		break;
	case 2:
		sz = arg[1];
		break;
	default:
		error("bad sendmsg");
	}
	printf("(send) %s\n", fmtmsg(p, sz));
	write(fd, cval2str((`uint64)sz));
	write(fd, getbytes(p, sz));
}

@define recvmsg(fd)
{
	@local s, sz, p, msg, dat;
	s = read(fd, sizeof(`uint64));
	if(s == nil)
		return [nil, 'closed];
	sz = *(`uint64*)s;
	p = read(fd, sz);
	msg = buf2msg(p);
	if(sz > sizeof(*msg))
		dat = getbytes(msg+1, sz-sizeof(*msg));
	else
		dat = "";
	printf("(recv) %s\n", fmtmsg(msg, sz));
	return [msg, dat];
}

@define checkreply(rep, op)
{
	switch(rep->op){
	case op:
		break;
	case sctl`Rerror:
		error("sctl: while waiting for %e: %s",
		      op, rep->bytes);
	default:
		error("sctl: while waiting for %e: received %e",
		      op, (sctl`Mkind)rep->op);
	}
}

@define rerror(fd, tag, fmt, arg ...)
{
	@local p, sz, err;
	err = apply(sprintfa, fmt, arg);
	sz = sizeof(sctl`Rerror)+strlen(err);
	p = (sctl`Rerror*)malloc(sz);
	p->op = sctl`Rerror;
	p->tag = tag;
	putbytes(p+1, err);
	sendmsg(fd, p, sz);
}

@define ping(fd, cnt)
{
	@local p, rep, dat, sz;

	sz = sizeof(sctl`Tping)+cnt;
	p = (sctl`Tping*)malloc(sz);
	p->op = sctl`Tping;
	p->tag = freshtag();
	sendmsg(fd, p, sz);

	[rep, dat] = recvmsg(fd);
	if(rep == nil)
		error("ping failed: %a", dat);
	checkreply(rep, sctl`Rping);
	if(rep->cnt != cnt)
		error("ping reply acknowledged %d bytes, not %d",
		      rep->cnt, cnt);
}

@define version(fd)
{
	@local p, rep, dat, sz, version, os, s;

	version = "sctl-2010:x86-linux-2010,x86-win-2010";

	sz = sizeof(sctl`Tversion)+strlen(version);
	p = (sctl`Tversion*)malloc(sz);
	p->op = sctl`Tversion;
	p->tag = freshtag();
	putbytes(p+1, version);
	sendmsg(fd, p, sz);

	[rep, dat] = recvmsg(fd);
	if(rep == nil)
		error("version failed: %a", dat);
	checkreply(rep, sctl`Rversion);
	s = split(dat, ":");
	if(length(s) != 2)
		error("unknown remote sctl version: %s", dat);
	os = s[1];
	os = substr(os, 0, strlen(os)); /* chop NUL */
	printf("version is %s %s\n", s[0], os);
}

@define names(fd, path)
{
	@local p, q, rep, dat, sz;

	sz = sizeof(sctl`Tnames);
	sz += sizeof(sctl`uint64)+strlen(path); /* path */
	p = (sctl`Tnames*)malloc(sz);
	p->op = sctl`Tnames;
	p->tag = freshtag();
	q = (`uint64*)(p+1);
	*q++ = strlen(path);
	q = (char*)q;
	putbytes(q, path);
	q += strlen(path);
	sendmsg(fd, p, sz);

	[rep, dat] = recvmsg(fd);
	if(rep == nil)
		error("names failed: %a", dat);
	checkreply(rep, sctl`Rnames);
	printf("nsid for %s is %u\n", path, rep->id);
	return rep->id;
}

@define sctllooktype(fd, nsid, ns, tn)
{
	@local p, m, rep, dat;

	m = p = mkxs();
	p = (sctl`Tlooktype*)p;
	p->op = sctl`Tlooktype;
	p->tag = freshtag();
	p = (`uint64*)(p+1);
	*p++ = nsid;
	p = encodetname(p, tn);
	sendmsg(fd, m, (char*)p-m);

	[rep, dat] = recvmsg(fd);
	if(rep == nil)
		error("looktype failed: %a", dat);
	switch(rep->op){
	case sctl`Rlooktype:
		break;
	case sctl`Rerror:
		if(rep->bytes == "no such thing")
			return nil;
		error("sctl: error while waiting for %e: %s",
		      sctl`Rlooktype, rep->bytes);
	default:
		error("sctl: while waiting for %e: received %e",
		      sctl`Rlooktype, (sctl`Mkind)rep->op);
	}
	return decodetdef(ns, (char*)dat)[0];
}

@define sctlenumtype(fd, nsid, ns)
{
	@local p, m, rep, dat, ss, q, i, t;

	m = p = mkxs();
	p = (sctl`Tlooktype*)p;
	p->op = sctl`Tenumtype;
	p->tag = freshtag();
	p = (`uint64*)(p+1);
	*p++ = nsid;
	p = (char*)p;
	sendmsg(fd, m, p-m);

	[rep, dat] = recvmsg(fd);
	checkreply(rep, sctl`Renumtype);
	ss = [:];
	q = (`uint64*)dat;
	m = *q++;
	for(i = 0; i < m; i++){
		[t, q] = decodetdef(ns, q);
		ss[typename(t)] = t;
	}
	return ss;
}

@define sctllooksym(fd, nsid, id)
{
	@local p, m, rep, dat, sym;

	p = m = mkxs();
	p = (sctl`Tlooksym*)p;
	p->op = sctl`Tlooksym;
	p->tag = freshtag();
	p++;
	p = (`uint64*)p;
	*p++ = nsid;
	p = encodes(p, cid2str(id));
	p = (char*)p;
	sendmsg(fd, m, p-m);
	
	[rep, dat] = recvmsg(fd);
	switch(rep->op){
	case sctl`Rlooksym:
		break;
	case sctl`Rerror:
		if(rep->bytes == "no such thing")
			return nil;
		error("sctl: error while waiting for %e: %s",
		      sctl`Rlooksym, rep->bytes);
	default:
		error("unexpected response: %e", rep->op);
	}

	[sym, _] = decodesym(dat);
	return sym;
}

@define sctlenumsym(fd, nsid)
{
	@local p, m, q, rep, dat, i, ss, sym;

	p = m = mkxs();
	p = (sctl`Tenumsym*)p;
	p->op = sctl`Tenumsym;
	p->tag = freshtag();
	p++;
	p = (`uint64*)p;
	*p++ = nsid;
	p = (char*)p;
	sendmsg(fd, m, p-m);

	/* wait for reply */
	[rep, dat] = recvmsg(fd);
	checkreply(rep, sctl`Renumsym);

	ss = [];
	q = (`uint64*)dat;
	m = *q++;
	for(i = 0; i < m; i++){
		[sym, q] = decodesym(q);
		append(ss, sym);
	}
	return ss;
}

@define sctllookaddr(fd, nsid, addr)
{
	@local p, m, rep, dat, sym;

	p = m = mkxs();
	p = (sctl`Tlookaddr*)p;
	p->op = sctl`Tlookaddr;
	p->tag = freshtag();
	p++;
	p = (`uint64*)p;
	*p++ = nsid;
	*p++ = addr;
	sendmsg(fd, m, (char*)p-m);
	
	[rep, dat] = recvmsg(fd);
	checkreply(rep, sctl`Rlookaddr);
	
	[sym, _] = decodesym(dat);
	return sym;
}

@define mkresolve(cache, undef, lt)
{
	@local resolve, undefined, ptr, ptrrep;
	@local typepos;

	typepos = 0;   // FIXME: should be opaque

	ptr = lt(mkctype_base(sctl`Vptr));
	if(ptr == nil)
		error("no pointer type");
	ptrrep = baserep(ptr);

	@define undefined(tn)
	{
		@local td;
		td = mkctype_undef(tn);
		cache[typename(tn)] = td;
		undef[typename(tn)] = td;
		return td;
	}

	@define resolve(tn)
	{
		@local td, i, m, s, v, st;

		td = cache[typename(tn)];
		if(td != nil)
			return td;

		if(isbase(tn)){
			td = lt(tn);
			if(td == nil)
				error("name space does not define %t", tn);
			cache[typename(tn)] = td;
			return td;
		}else if(issu(tn)){
			td = lt(tn);
			if(td == nil)
				return undefined(tn);
			cache[typename(tn)] = td; // terminate cycles
			s = fields(td);
			m = length(s);
			for(i = 0; i < m; i++){
				v = s[i];
				v[typepos] = resolve(v[typepos]);
			}
			return td;
		}else if(isenum(tn)){
			td = lt(tn);
			if(td == nil)
				return undefined(tn);
			cache[typename(tn)] = td;
			return td;
		}else if(istypedef(tn)){
			td = lt(tn);
			if(td == nil)
				return undefined(tn);
			cache[typename(tn)] = td; // terminate cycles
			settypedeftype(td, resolve(typedeftype(td)));
			return td;
		}else if(isptr(tn)){
			td = mkctype_ptr(resolve(subtype(tn)), ptrrep);
			/* FIXME: cannot cache into cache because
			   we return that as enumtype.  but we could
		           create a separate ptrcache. */
			// cache[typename(tn)] = td; // why not?
			return td;
		}else if(isenumconst(tn)){
			td = mkctype_const(resolve(subtype(tn)));
			return td;
		}else if(isfunc(tn)){
			s = params(tn);
			m = length(s);
			for(i = 0; i < m; i++){
				v = s[i];
				v[typepos] = resolve(v[typepos]);
			}
			td = mkctype_fn(resolve(rettype(tn)), s);
			return td;
		}else if(isarray(tn)){
			return mkctype_array(resolve(subtype(tn)),
					     arraynelm(tn));
		}else if(isvoid(tn)){
			cache[typename(tn)] = mkctype_void();
		}else if(isbitfield(tn)){
			st = resolve(bitfieldcontainer(tn));
			return mkctype_bitfield(st,
						bitfieldwidth(tn),
						bitfieldpos(tn));
		}else if(isundeftype(tn)){
			cache[typename(tn)] = tn;
		}else
			error("type resolution on unexpected type: %t", tn);
	}
	
	return resolve;
}

@define mksctlns(fd, nsid)
{
	@local type, sym, addr, undef;
	@local lt, ls, et, es, la, ns;
	@local psym2sym;
	@local ltresolve;
		
	@defloc resetltr()
	{
		ltresolve = mkresolve(type, undef,
				      @lambda(tn){
					      sctllooktype(fd, nsid, ns, tn);
				      });
	}

	type = [:];
	sym = [:];
	addr = [:];
	undef = [:];
	resetltr();

	@define lt(this, tn)
	{
		@local t;
		t = ltresolve(tn);
		if(isundeftype(t))
			return nil;
		return t;
	}

	@define et(this)
	{
		@local resolve, ts;

		// FIXME: maybe only muxenumtype if we haven't before

		/* reset cache */
		type = [:];
		undef = [:];
		resetltr();

		ts = sctlenumtype(fd, nsid, ns);
		resolve = mkresolve(type, undef,
				    @lambda(tn){
					    return ts[typename(tn)];
				    });
		foreach(@lambda(k, v){
				resolve(k);
			}, ts);
		if(length(undef) > 0){
			printf("%d unresolved\n", length(undef));
			foreach(@lambda(k, v){
					printf("\t%t\n", k);
				}, undef);
		}
		return type;
	}

	@define psym2sym(psym)
	{
		@local at, v, t;
			
		if(psym.flags&sctl`Sundef)
			return nil;
		if(psym.flags&sctl`Sinline)
			return nil;
		t = ltresolve(psym.type);
		v = psym.val;
		if(psym.flags&sctl`Senum)
			v = {subtype(t)}v;
		at = psym.attrs;
		at["offset"] = v;
		return mksym(t, psym.id, at);
	}
		
	@define ls(this, name)
	{
		@local psym, s;
		s = sym[name];
		if(s != nil)
			return s;
		psym = sctllooksym(fd, nsid, name);
		if(psym == nil)
			return nil;
		s = psym2sym(psym);
		if(s != nil){
			sym[symid(s)] = s;
			addr[symoff(s)] = s;
		}
		return s;
	}

	@define es(this)
	{
		@local ss, s;

		/* reset cache */
		sym = [:];

		ss = sctlenumsym(fd, nsid);
		foreach(@lambda(psym){
				s = psym2sym(psym);
				if(s != nil)
					sym[psym.id] = s;
			}, ss);
		return sym;
	}

	@define la(this, a)
	{
		@local psym, s;
		s = addr[a];
		if(s != nil)
			return s;
		psym = sctllookaddr(fd, nsid, a);
		if(psym == nil)
			return nil;
		s = psym2sym(psym);
		if(s != nil)
			addr[a] = s;
		return s;
	}

	ns = mkns([ "looktype" : lt,
		    "enumtype" : et,
		    "looksym"  : ls,
		    "enumsym"  : es,
		    "lookaddr" : la ]);
	return ns;
}
