@include <chronicle.cqct>
@include <l1-debug.cqct>
@include <l1-list.cqct>
@include <l1-mem.cqct>

@global db;

@define whine(str, iv, ws)
{
	@local stks;
	printf("... %s in interval @%d-@%d\n", str, iv.beg, iv.end);
	if(!ws || length(ws) == 0)
		return;
	stks = uniqstacks(db, ws);
	printf("...... %d unique context%s\n", length(stks),
	       length(stks) > 1 ? "s" : "");
	foreach(@lambda(e){
			printf("...... %d writes occurred here (example @%d)\n",
			       length(e[0]), e[0][0]);
			printf("%s", e[1]);
		}, stks);
}

@define assertunaccessed(iv)
{
	@local addr, len, s;
//	printf("... assert unaccessed: %a\n", iv);
	[addr, len] = iv.val;
	s = db.scan('write, addr, len, iv.beg, iv.end);
	if(length(s) != 0)
		whine("write to unwritten data", iv, s);
	s = db.scan('read, addr, len, iv.beg, iv.end);
	if(length(s) != 0)
		whine("read to unwritten data", iv, s);
}

@define assertunwritten(iv)
{
	@local addr, len, ws;
//	printf("... assert unwritten: %a\n", iv);
	[addr, len] = iv.val;
	ws = db.scan('write, addr, len, iv.beg, iv.end);
	if(length(ws) != 0)
		whine("write to unwritten data", iv, ws);
}

@define assertlive(iv)
{
	@local life;
//	printf("... assert live: %a\n", iv);
	life = vallifetime(db, iv.val, iv.beg);
	if(!containsiv(life, iv))
		whine("reference to stale object", iv, nil);
}

@define l1db(file)
{
	printf("'db':\n");
	db = chronicledb(file);
	printf("\n");

	return nil;
}

@define forkwithdb(db, fn)
{
	@local pid;
	db.rebind();
	switch(pid = fork()){
	case -1:
		error("fork failed");
	case 0:
		switch(fork()){
		case -1:
			error("fork failed");
		default:
			exit(0);
		case 0:
			fn();
			exit(0);
		default:
			waitpid(pid, 0);
			return;
		}
	}
}

@define exitonerror(fn)
{
	@local err;

	@defloc myerr(msg)
	{
		callcc(@lambda(errk){
				printf("error: %s\n", msg);
				kbacktrace(continuationstack(errk));
				exit(0);
			});
	}
	dynamicwind(@lambda(){
			err = errorhandler;
			errorhandler = myerr;
		    },
		    fn,
		    @lambda(){ errorhandler = err; });
}

@define foreachpar(db, fn, vs)
{
	@local fds, rvs;
	fds = [];

	@defloc fork1(v)
	{
		@local pid, ch;
		ch = sockpair();
		switch(pid = fork()){
		case -1:
			error("fork failed");
		case 0:
			switch(fork()){
			case -1:
				error("fork failed");
			default:
				exit(0);
			case 0:
				close(ch[1]);
				if(db)
					db.rebind();
				exitonerror(@lambda() { fn(v); });
				exit(0);
			}
		default:
			waitpid(pid, 0);
			break;
		}
		close(ch[0]);
		append(fds, ch[1]);
	}

	foreach(fork1, vs);
	while(length(fds)){
		rvs = select(fds, [], []);
		foreach(@lambda(fd){ delete(fds, fd); close(fd); }, rvs[0]);
	}
}

@define xforeachpar(db, fn, vs)
{
	foreach(fn, vs);
}
