ns9p = @names c32le {
enum
{
	// these 9P and 9P2000.u definitions come from plan9port
	OREAD	 	= 0,		// open for read
	OWRITE	 	= 1,		// write
	ORDWR	 	= 2,		// read and write
	OEXEC	 	= 3,		// execute, == read but check execute
				   	//   permission
	OTRUNC	 	= 16,		// or'ed in (except for exec),
				   	//   truncate file first
	OCEXEC	 	= 32,		// or'ed in, close on exec
	ORCLOSE	 	= 64,		// or'ed in, remove on close
	ODIRECT	 	= 128,		// or'ed in, direct access
	ONONBLOCK	=  256,		// or'ed in, non-blocking call
	OEXCL	 	= 0x1000,	// or'ed in, exclusive use (create only)
	OLOCK	 	= 0x2000,	// or'ed in, lock after opening
	OAPPEND	 	= 0x4000,	// or'ed in, append only
	
	// bits in Qid.type
	QTDIR		= 0x80,		// type bit for directories
	QTAPPEND	= 0x40,		// type bit for append only files
	QTEXCL		= 0x20,		// type bit for exclusive use files
	QTMOUNT		= 0x10,		// type bit for mounted channel
	QTAUTH		= 0x08,		// type bit for authentication file
	QTTMP		= 0x04,		// type bit for non-backed-up file
	QTSYMLINK	= 0x02,		// type bit for symbolic link
	QTFILE		= 0x00,		// type bits for plain file

	// 9P mode bits
	DMDIR		= 0x80000000,	// mode bit for directories
	DMAPPEND	= 0x40000000,	// mode bit for append only files
	DMEXCL		= 0x20000000,	// mode bit for exclusive use files
	DMMOUNT		= 0x10000000,	// mode bit for mounted channel
	DMAUTH		= 0x08000000,	// mode bit for authentication file
	DMTMP		= 0x04000000,	// mode bit for non-backed-up file

	// 9P2000.u mode bits
	DMSYMLINK	= 0x02000000,	// mode bit for symbolic link
	DMDEVICE	= 0x00800000,	// mode bit for device file
	DMNAMEDPIPE	= 0x00200000,	// mode bit for named pipe
	DMSOCKET	= 0x00100000,	// mode bit for socket
	DMSETUID	= 0x00080000,	// mode bit for setuid
	DMSETGID	= 0x00040000,	// mode bit for setgid

	DMREAD		= 0x4,		// mode bit for read permission
	DMWRITE		= 0x2,		// mode bit for write permission
	DMEXEC		= 0x1,		// mode bit for execute permission
};

enum P9Pmsg
{
	Tversion =	100,
	Rversion,
	Tauth =		102,
	Rauth,
	Tattach =	104,
	Rattach,
	Terror =	106,	/* illegal */
	Rerror,
	Tflush =	108,
	Rflush,
	Twalk =		110,
	Rwalk,
	Topen =		112,
	Ropen,
	Tcreate =	114,
	Rcreate,
	Tread =		116,
	Rread,
	Twrite =	118,
	Rwrite,
	Tclunk =	120,
	Rclunk,
	Tremove =	122,
	Rremove,
	Tstat =		124,
	Rstat,
	Twstat =	126,
	Rwstat,
	Tmax,
};

// fields are in wire format
typedef struct Qid {
	@0x00	uint8	type;
	@0x01	uint32	vers;
	@0x05	uint64	path;
	@0x13;
} Qid;

// fields through length are in wire format
typedef struct Dir {
	@0x00	uint16	type;
	@0x02	uint32	dev;
	@0x06	Qid	qid;
	@0x13	uint32	mode;
	@0x17	uint32	atime;
	@0x1b	uint32	mtime;
	@0x1f	uint64	length;
	@0x27	char	*name;
	@0x2b	char	*uid;
	@0x2f	char	*gid;
	@0x33	char	*muid;
	@0x37;
} Dir;

};

@const NOTAG   = (`uint16)~0;
@const NOFID   = (`uint32)~0;
@const BIT8SZ  = 1;
@const BIT16SZ = 2;
@const BIT32SZ = 4;
@const BIT64SZ = 8;
@const QIDSZ   = BIT8SZ+BIT32SZ+BIT64SZ;

dom9p = mkdom(ns9p, mknas());

define charstar(ns, s)
{
	return (unsigned char*){mkdom(ns,mksas(s))}0;
}

define push1(p, v)
{
	*(`uint8*)p = v;
	return p+1;
}

define push2(p, v)
{
	*(`uint16*)p = v;
	return p+2;
}

define push4(p, v)
{
	*(`uint32*)p = v;
	return p+4;
}

define pushn(p, s)
{
	@local m;
	if(s == nil)
		return push2(p, 0);
	m = length(s);
	p = push2(p, m);
	putbytes(p, s);
	return p+m;
}

define lenn(s)
{
	@local sz;
	sz = 2;
	if(s == nil)
		return sz;
	else
		return sz+length(s);
}

define read9pmsg(fd)
{
	@local s, p, n;
	s = read(fd, 4);
	if(s == nil)
		return nil;
	if(length(s) != 4)
		error("bad 9P2000 message");
	p = charstar(ns9p, s);
	n = *(`uint32*)p;
	if(n <= 4)
		error("bad length in 9P2000 message header");
	s = read(fd, n-4);
	if(s == nil || length(s) < n-4)
		return nil;
	return s;
}

define tversion(tag, msize, version)
{
	@local sz, s, p;
	// size[4] Tversion tag[2] msize[4] version[s]
	sz = 4+1+2+4+lenn(version);
	s = mkstr(sz);
	p = charstar(ns9p, s);
	p = push4(p, sz);
	p = push1(p, dom9p`Tversion);
	p = push2(p, tag);
	p = push4(p, msize);
	p = pushn(p, version);
	return s;
}

define tattach(tag, fid, afid, uname, aname)
{
	@local sz, s, p;
	// size[4] Tattach tag[2] fid[4] afid[4] uname[s] aname[s]
	sz = 4+1+2+4+4+lenn(uname)+lenn(aname);
	s = mkstr(sz);
	p = charstar(ns9p, s);
	p = push4(p, sz);
	p = push1(p, dom9p`Tattach);
	p = push2(p, tag);
	p = push4(p, fid);
	p = push4(p, afid);
	p = pushn(p, uname);
	p = pushn(p, aname);
	return s;
}

define tstat(tag, fid)
{
	@local sz, s, p;
	// size[4] Tstat tag[2] fid[4]
	sz = 4+1+2+4;
	s = mkstr(sz);
	p = charstar(ns9p, s);
	p = push4(p, sz);
	p = push1(p, dom9p`Tstat);
	p = push2(p, tag);
	p = push4(p, fid);
	return s;
}

define twstat(tag, fid, stat)
{
	@local sz, s, p;
	// size[4] Tstat tag[2] fid[4] stat[n]
	sz = 4+1+2+4+lenn(stat);
	s = mkstr(sz);
	p = charstar(ns9p, s);
	p = push4(p, sz);
	p = push1(p, dom9p`Tstat);
	p = push2(p, tag);
	p = push4(p, fid);
	p = pushn(p, stat);
	return s;
}

define tclunk(tag, fid)
{
	@local sz, s, p;
	// size[4] Tclunk tag[2] fid[4]
	sz = 4+1+2+4;
	s = mkstr(sz);
	p = charstar(ns9p, s);
	p = push4(p, sz);
	p = push1(p, dom9p`Tclunk);
	p = push2(p, tag);
	p = push4(p, fid);
	return s;
}

define tflush(tag, oldtag)
{
	@local sz, s, p;
	// size[4] Tflush tag[2] oldtag[2]
	sz = 4+1+2+2;
	s = mkstr(sz);
	p = charstar(ns9p, s);
	p = push4(p, sz);
	p = push1(p, dom9p`Tflush);
	p = push2(p, tag);
	p = push2(p, oldtag);
	return s;
}

define rversion(sz, p)
{
	@local tag, msize, len, version;
	// (size[4]) Rversion tag[2] msize[4] version[s]
	if(sz <= 1+2+4+2)
		error("Rversion is too short");
	p += 1;  // Rversion
	tag = *(`uint16*)p;
	p += 2;	
	msize = *(`uint32*)p;
	p += 4;
	len = *(`uint16*)p;
	p += 2;
	if(sz != 1+2+4+2+len)
		error("bad Rversion");
	version = getbytes(p, len);
	printf("Rversion: tag=%u msize=%u version=%s\n", tag, msize, version);
}

define rattach(sz, p)
{
	@local tag, type, vers, path;
	// (size[4]) Rattach tag[2] qid[13]
	if(sz != 1+2+13)
		error("bad Rattach");
	p += 1;  // Rattach
	tag = *(`uint16*)p;
	p += 2;	
	type = *(`uint8*)p;
	p += 1;
	vers = *(`uint32*)p;
	p += 4;
	path = *(`uint64*)p;
	p += 8;
	printf("Rattach: tag=%u qid=%x.%u.%x\n", tag, type, vers, path);
}

define convM2D(p)
{
	@local s, q, r, slen;
	sz = *(`uint16*)p;
	p += 2;
	s = mkstr(sz+4*4+4);    // four field ptrs, four NULL bytes in fields
	q = charstar(ns9p, s);
	memcpy(q, p, 0x27); // offsetof(Dir, name)
	p += 0x27;
	q = (`Dir*)q;
	r = (char*)(q+1);

	slen = *(`uint16*)p;
	p += 2;
	q->name = r;
	memcpy(r, p, slen);
	printf("name %d\n", slen);
	p += slen;
	r += slen;
	*r++ = 0;
	
	slen = *(`uint16*)p;
	p += 2;
	q->uid = r;
	memcpy(r, p, slen);
	printf("uid %d\n", slen);
	p += slen;
	r += slen;
	*r++ = 0;

	slen = *(`uint16*)p;
	p += 2;
	q->gid = r;
	memcpy(r, p, slen);
	printf("gid %d\n", slen);
	p += slen;
	r += slen;
	*r++ = 0;

	slen = *(`uint16*)p;
	p += 2;
	q->muid = r;
	memcpy(r, p, slen);
	printf("muid %d\n", slen);
	p += slen;
	r += slen;
	*r++ = 0;

	return q;
}

define rstat(sz, p)
{
	@local tag, stat;
	// (size[4]) Rstat tag[2] stat[n]
	if(sz <= 1+2+2)
		error("Rstat is too short");
	p += 1;  // Rstat
	tag = *(`uint16*)p;
	p += 2;	
	len = *(`uint16*)p;
	p += 2;
	if(sz != 1+2+2+len)
		error("bad Rstat");
	stat = convM2D(p);
	printf("Rstat tag=%u len=%u mode=%o at=%u mt=%u "
	       "name=%s uid=%s gid=%s muid=%s\n",
	       tag, stat->length, stat->mode,
	       stat->atime, stat->mtime,
	       stat->name, stat->uid, stat->gid, stat->muid);
}

define rwstat(sz, p)
{
	@local tag;
	// (size[4]) Rwstat tag[2]
	if(sz != 1+2)
		error("bad Rwstat");
	p += 1; // Rwstat
	tag = *(`uint16*)p;
	printf("Rwstat: tag=%u\n", tag);
}

define rclunk(sz, p)
{
	@local tag;
	// (size[4]) Rclunk tag[2]
	if(sz != 1+2)
		error("bad Rclunk");
	p += 1; // Rclunk
	tag = *(`uint16*)p;
	printf("Rclunk: tag=%u\n", tag);
}

define rflush(sz, p)
{
	@local tag;
	// (size[4]) Rflush tag[2]
	if(sz != 1+2)
		error("bad Rflush");
	p += 1; // Rflush
	tag = *(`uint16*)p;
	printf("Rflush: tag=%u\n", tag);
}

define rerror(sz, p)
{
	@local tag, len, ename;
	// (size[4]) Rerror tag[2] ename[s]
	if(sz <= 1+2+2)
		error("Rerror is too short");
	p += 1; // Rerror
	tag = *(`uint16*)p;
	p += 2;
	len = *(`uint16*)p;
	p += 2;
	if(sz != 1+2+2+len)
		error("bad Rerror");
	ename = getbytes(p, len);
	printf("Rerror: tag=%u ename=\"%s\"\n", tag, ename);
}

define session9p(fd)
{
	@local m, p, sz;
	write(fd[0], tversion(NOTAG, 8192, "9P2000.u"));
	m = read9pmsg(fd[1]);
	if(m == nil)
		error("unexpected end-of-file");
	sz = length(m);
	p = charstar(ns9p, m);
	if(*p == dom9p`Rversion)
		rversion(sz, p);
	else if(*p == dom9p`Rerror)
		rerror(sz, p);
	else
		error("i got %e", (enum dom9p`P9Pmsg)*p);
}

define attach9p(fd, uname)
{
	@local m, p, sz;
	write(fd[0], tattach(0, 0, NOFID, uname, ""));
	m = read9pmsg(fd[1]);
	if(m == nil)
		error("unexpected end-of-file");
	sz = length(m);
	p = charstar(ns9p, m);
	if(*p == dom9p`Rattach)
		rattach(sz, p);
	else if(*p == dom9p`Rerror)
		rerror(sz, p);
	else
		error("i got %e", (enum dom9p`P9Pmsg)*p);
}

define stat9p(fd, fid)
{
	@local m, p, sz;
	write(fd[0], tstat(0, fid));
	m = read9pmsg(fd[1]);
	if(m == nil)
		error("unexpected end-of-file");
	sz = length(m);
	p = charstar(ns9p, m);
	if(*p == dom9p`Rstat)
		rstat(sz, p);
	else if(*p == dom9p`Rerror)
		rerror(sz, p);
	else
		error("i got %e", (enum dom9p`P9Pmsg)*p);
}

define clunk9p(fd, fid)
{
	@local m, p, sz;
	write(fd[0], tclunk(0, fid));
	m = read9pmsg(fd[1]);
	if(m == nil)
		error("unexpected end-of-file");
	sz = length(m);
	p = charstar(ns9p, m);
	if(*p == dom9p`Rclunk)
		rclunk(sz, p);
	else if(*p == dom9p`Rerror)
		rerror(sz, p);
	else
		error("i got %e", (enum dom9p`P9Pmsg)*p);
}

define flush9p(fd, oldtag)
{
	@local m, p, sz;
	write(fd[0], tflush(0, oldtag));
	m = read9pmsg(fd[1]);
	if(m == nil)
		error("unexpected end-of-file");
	sz = length(m);
	p = charstar(ns9p, m);
	if(*p == dom9p`Rflush)
		rflush(sz, p);
	else if(*p == dom9p`Rerror)
		rerror(sz, p);
	else
		error("i got %e", (enum dom9p`P9Pmsg)*p);
}

define newvac(name)
{
	@local vac;
	// empty string lets us create an empty vac
	fd = popen("vac", "-h", "localhost", "");
	vac = read(fd[1], 100);
	return vac;
}

define vaccons(vac, name, bytes)
{
}

define mountvac(vac)
{
	@local fd, i;
	fd = popen("vacfs", "-d", "-h", "localhost", "-i", vac);
	session9p(fd);	
	attach9p(fd, getenv("USER"));
	for(i = 0; i < 100; i++)
		stat9p(fd, 0);
	clunk9p(fd, 0);
	close(fd[0]);
}

define test()
{
	@local fd;
	fd = popen(getenv("HOME")+"/src/u9fs/u9fs",
		   "-D",
		   "-a", "none",
		   "-n",
		   "-u", getenv("USER"));
	session9p(fd);
	attach9p(fd, getenv("USER"));
	stat9p(fd, 0);
	clunk9p(fd, 0);
	flush9p(fd, 1);
	close(fd[0]);
}
