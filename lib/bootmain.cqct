/* bootmain.cqct -- bootstrap compiler and evaluator
   this file expects to be included by boot.cqct.
*/

@global
	args,
	debug,
	eval,
	expand,
	l1path,
	load,
	compile,
	callfn,
	repl,
	$repllevel,
	$l1start,
	dumpk,
	withnullcont
	;

@defloc topwrap(e)
{
	return #lambda(#[], #ret(#g(#id('$$), #block(#[], e))), stxsrc(e));
}

@defloc mkcompiler(passes)
{
	@local npass;
	npass = length(passes);
	@define compile(e)
	{
		@local err;
		e = topwrap(e);
		callcc(@lambda(done){
				@defloc myerr(msg)
				{
					printf("%s\n", msg);
					done(nil);
				}
				dynamicwind(@lambda(){
						err = errorhandler;
						errorhandler = myerr;
					    },
					    @lambda(){
						    @local i;
						    for(i = 0; i < npass; i++)
							    e = passes[i](e);
						    return e;
					    },
					    @lambda(){
						    errorhandler = err;
					    });
			});
	}
}

mkcompiler(bootcompilerpasses());

@defloc _eval(str, whence, line)
{
	@local fn, in;
	in = parse(str, whence, line);
	if(in == nil)
		return nil;
	fn = compile(in);
	if(fn == nil)
		return nil;
	fn();
}

@define eval(str)
{
	_eval(str, "<eval-input>", 1);
}

@defloc findfileinpath(file, path)
{
	@local try;
	while(!isempty(path)){
		try = pop(path)+"/"+file;
		if(access(try, "r"))
			return try;
	}
	return nil;
}

@define load(file)
{
	@local path, str;
	if(file[0] == '/')
		path = file;
	else if(file[0] == '.')
		path = file;
	else
		path = findfileinpath(file, loadpath());
	if(path == nil)
		error("cannot find %s in load path", file);
	str = mapfile(path);
	_eval(str, file, 1);
}

load("expand.cqct");
mkcompiler(push(bootcompilerpasses(), expand));
load("prelude.cqct");

@define callfn(fn, args ...)
{
	callcc(@lambda(ret){
			currentreset = ret;
			return apply(fn, args);
    	       }); 
}

@defloc replerror(msg)
{
	callcc(@lambda(errk){
			printf("error: %s\n", msg);
			kbacktrace(continuationfr(errk));
			currentreset(nil);
		});
}

@defloc replinterrupt()
{
	callcc(@lambda(k){
		printf("\ninterrupted\n");
		$debug(k);
	});
}

@defloc batcherror(msg)
{
	callcc(@lambda(errk){
			printf("error: %s\n", msg);
			kbacktrace(continuationfr(errk));
			currentabort();
		});
}

@defloc batchinterrupt()
{
	callcc(@lambda(k){
		printf("\ninterrupted\n");
		kbacktrace(continuationfr(k));
	});
}

@defloc $debug(k)
{
	@defloc help()
	{
		printf("l1 debugger commands\n");
		printf("help, h, ?         display this help\n");
		printf("bt                 display current backtrace\n");
		printf("r, reset           reset repl\n");
		printf("new                start new repl\n");
		printf("EOF, exit, quit, q resume execution\n");
		printf("a, abort           abort l1\n");
	}

	@defloc debugloop()
	{
		@local s, tok;
		printf("debug> ");
		s = read(stdin, 1024);
		if(s == nil){
			printf("\n");
			return;
		}
		if(s == "")
			debugloop();
		tok = split(s);
		switch(tok[0]){
		case "h":
		case "?":
		case "help":
			help();
			break;
		case "bt":
			kbacktrace(continuationfr(k));
			break;
		case "r":
		case "reset":
			currentreset(nil);
			break;
		case "new":
			repl();
			break;
		case "q":
		case "exit":
		case "quit":
			return;
		case "a":
		case "abort":
			currentabort();
		        break;
		default:
			printf("unrecognized command\n");
			break;
		}
		debugloop();
	}
	debugloop();
}

@define debug()
{
	callcc($debug);
}

@define dumpk(k)
{
	kbacktrace(continuationfr(k));
}

$repllevel = 0;
@define repl()
{
	@local prompt, level;

	@defloc mkprompt()
	{
		@local i;
		prompt = "";
		for(i = 0; i < level; i++)
			prompt += ";";
	}

	@defloc $loop()
	{
		@local s, v;
		printf("%s ", prompt);
		s = read(stdin, 1024);
		if(s == nil){
			$repllevel--;
			printf("\n");
			currentreturn(nil);
			error("unexpected return from return\n");
		}
		v = _eval(s, "(stdin)", 1);
		if(v != nil)
			printf("%a\n", v);
		$loop();
	}

	level = ++$repllevel;
	mkprompt();
	callcc(@lambda(done){
			@local oldret, olderr, oldint, oldreset, thisreset;
			withnullcont(@lambda(){
					dynamicwind(
						@lambda(){
							oldret = currentreturn;
							olderr = errorhandler;
							oldint = interrupthandler;
							oldreset = currentreset;
							$repllevel = level;
							currentreturn = done;
							errorhandler = replerror;
							interrupthandler = replinterrupt;
							currentreset = thisreset;
						},
						@lambda(){ 
							callcc(@lambda(reset){
									currentreset = thisreset = reset;
								});
							$loop();
						},
						@lambda(){
							currentreturn = oldret;
							errorhandler = olderr;
							interrupthandler = oldint;
							currentreset = oldreset;
						});
				});
	       });
}

@defloc parseargs(args)
{
	@local arg;
	@local forms, cmd, entry;

	l1path = pop(args);
	forms = [];
	cmd = [];
	entry = nil;
	while(length(args)){
		arg = pop(args);
		if(arg == "--")
			break;
		if(arg[0] != '-'){
			push(args, arg); /* command file */
			break;
		}
		if(arg == "-x"){
			if(length(args) == 0)
				error("missing form for -x");
			append(forms, pop(args));
			continue;
		}
		if(arg == "-e"){
			if(length(args) == 0)
				error("missing symbol for -e");
			if(entry)
				error("multiple uses of -e");
			entry = mkcid(pop(args));
			continue;
		}
		/* else eat option */
	}
	cmd = args;
	if(entry && length(cmd) == 0)
		error("entry specified without a script");
	return [forms, entry, cmd];
}

@define $l1start(arg ...)
{
	@local forms, entry, cmd, file, rv;
	callcc(@lambda(root){
			withnullcont = root;
			return @lambda(){
				[forms, entry, cmd] = parseargs(arg);
				if(length(cmd) == 0 && length(forms) == 0)
					return repl();
				callcc(@lambda(done){
						currentreturn = done;
						errorhandler = batcherror;
						interrupthandler = batchinterrupt;
						while(length(forms)){
							@local form;
							form = pop(forms);
							rv = eval(form);
						}
						if(length(cmd) == 0)
							return rv;
						file = cmd[0];
						if(entry == nil){
							args = cmd;
							return load(file);
						}else{
							@local f;
							load(file);
							f = toplevel[entry];
							if(f == nil)
								error("entry %a is undefined",
								      entry);
							if(!isprocedure(f))
								error("entry %a is not a function",
								      entry);
							return apply(f, cmd);
						}
					});
			};})();
}
