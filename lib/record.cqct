/* this is a compatibility shim to bring record-bearing
 * forward easily.
 */

@global rds;
rds = [:];

@global rdsym;
@global _tmprd;

@defstx @rec(recname, fields ...) {
	@local foo, x, c;

	@global rdsym;
	if(!rdsym)
		rdsym = gensym();

	if(stxkind(fields) == 'null)
		error("record has no fields");

	foo = #[];
	c = fields;
	x = 0;
	while(c[1]) {
		foo = stxsplice(foo, #`{ t.#,(c[0]) = (l <= #,x)?nil:vals[#,x];});

		c = c[1];
		x++;
	}

	return #`{
		_tmprd = @lambda() {
			@local constructor, rd;

			rd = [:];

			constructor = @lambda(vals ...) {
				@local t, l;

				l = length(vals);
				if(l > #,x) {
					error("too many values for record type");
				}

				t = mktab(@lambda() {
					error("record has no such field");
				});

				#,foo;

				mktabpriv(t, "record");
				t.#,rdsym = rd;

				tabsetfmt(t, @lambda(v) {
					@local f;

					f = rd.fmt;
					if(f)
						return f(v);
					else
						return f;
				});
				return t;
			};

			rds[constructor] = rd;

			rd.constructor = constructor;
			mktabpriv(rd, "rd");

			return rd;
		}(), #,recname = rdmk(_tmprd), _tmprd;
	};
}

rdsetfmt = @lambda(rd, fmt) {
	rd.fmt = fmt;
};

rdof = @lambda(rec) {
	return rec[stxid(rdsym)];
};

rdgettab = @lambda(rd) {
	printf("GETTING THE TAB FROM AN RD!\n");
};

rdsettab = @lambda(rd) {
	printf("SETTING THE TAB FROM AN RD!\n");
};

rdmk = @lambda(rd) {
	printf("GETTING THE CONSTRUCTOR FROM THE RECORD DESCRIPTOR! %a\n", rd);
	if(!rd || !rd.constructor) {
		error("THIS ISN'T A RECORD DESCRIPTOR!\n");
	}
	return rd.constructor;
};
