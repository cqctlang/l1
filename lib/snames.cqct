#!/usr/bin/env l1
!#
@include <sctl.cqct>

@global prefix;
@global path2nsid;
@global nsid2ns;
@global Enone;

Enone = "no such thing";

sns = @names clp64be {
	typedef short unsigned int sa_family_t;
	typedef uint16 in_port_t;
	typedef uint32 in_addr_t;

	struct in_addr {
		@0x0	in_addr_t s_addr;
		@0x4;
	};

	struct sockaddr_in {
		@0x0	sa_family_t sin_family;
		@0x2	in_port_t sin_port;
		@0x4	struct in_addr sin_addr;
		@0x8	unsigned char sin_zero[0x8];
		@0x10;
	};
};

@define fmtsa(sa)
{
	@local p;
	sa = (struct sns`sockaddr_in*)sa;
	p = (`uint8*)&sa->sin_addr.s_addr;
	return sprintfa("%u.%u.%u.%u:%u",
			p[0], p[1], p[2], p[3],
			sa->sin_port);
}

@define notimpl(fd, msg, dat)
{
	rerror(fd, msg->tag, "server does not support %e", (sctl`Mkind)msg->op);
	return 'badop;
}

@define botch(fd, tag)
{
	rerror(fd, tag, "protocol botched");
	return 'badop;
}

@define tnames(fd, msg, dat)
{
	@local p, sz, nsid;
	@local q, path;

	q = (`uint64*)dat;
	[path, q] = decodes(q);

	nsid = openns(path);
	if(nsid == nil){
		rerror(fd, msg->tag, "invalid name space");
		return 'badop;
	}
	sz = sizeof(sctl`Rnames);
	p = (sctl`Rnames*)malloc(sz);
	p->op = sctl`Rnames;
	p->tag = msg->tag;
	p->id = nsid;
	sendmsg(fd, p);
	return 'ok;
}

@define tping(fd, msg, dat)
{
	@local p, sz;
	sz = sizeof(sctl`Rping);
	p = (sctl`Rping*)malloc(sz);
	p->op = sctl`Rping;
	p->tag = msg->tag;
	p->cnt = length(dat);
	sendmsg(fd, p);
	return 'ok;
}

@define tversion(fd, msg, dat)
{
	@local p, sz, s;
	s = split(dat, ":");
	if(length(s) < 1){
		botch(fd, msg->tag);
		return 'badop;
	}
	if(s[0] != "sctl-2010"){
		rerror(fd, msg->tag, "unsupported version");
		return 'badop;
	}
	if(length(s) != 2){
		botch(fd, msg->tag);
		return 'badop;
	}
	sz = sizeof(sctl`Rversion)+strlen(dat);
	p = (sctl`Rversion*)malloc(sz);
	p->op = sctl`Rversion;
	p->tag = msg->tag;
	printf("data is %s\n", dat);
	putbytes(p+1, dat);
	sendmsg(fd, p, sz);
	return 'ok;
}

@define tlooktype(fd, msg, dat)
{
	@local p, m, nsid, tn, ns, td;
	p = (`uint64*)dat;
	nsid = *p++;
	[tn, p] = decodetname(p);
	ns = nsid2ns[nsid];
	if(ns == nil){
		rerror(fd, msg->tag, "unknown name space");
		return 'badop;
	}
	td = ns.looktype(tn);
	if(td == nil){
       		rerror(fd, msg->tag, Enone);
		return 'badop;
	}
	m = p = (sctl`Rlooktype*)mkxs();
	p->op = sctl`Rlooktype;
	p->tag = msg->tag;
	p++;
	p = encodetdef(p, td);
	sendmsg(fd, m, (char*)p-(char*)m);
	return 'ok;
}

@define tenumtype(fd, msg, dat)
{
	@local p, m, nsid, ns, ts, nt;
	p = (`uint64*)dat;
	nsid = *p++;
	ns = nsid2ns[nsid];
	if(ns == nil){
		rerror(fd, msg->tag, "unknown name space");
		return 'badop;
	}
	ts = ns.enumtype();
	nt = length(ts);
	m = p = (sctl`Renumtype*)mkxs();
	p->op = sctl`Renumtype;
	p->tag = msg->tag;
	p++;
	p = (`uint64*)p;
	*p++ = nt;
	foreach(@lambda(tn, td){ p = encodetdef(p, td); }, ts);
	sendmsg(fd, m, (char*)p-(char*)m);
	return 'ok;
}

@define encodesym(p, sym)
{
	@local flags;
	p = (`uint64*)p;

	/* id */
	p = encodes(p, cid2str(symid(sym)));
	
	/* flags */
	flags = (`uint8)0;
	if(isenumconst(symtype(sym)))
		flags |= sctl`Senum;
	p = (`uint8*)p;
	*p++ = flags;
	
	/* val */
	p = (`uint64*)p;
	*p++ = symoff(sym);

	/* size */
	*p++ = 0;
	
	/* typename */
	p = encodetname(p, symtype(sym));

	return p;
}

@define tlooksym(fd, msg, dat)
{
	@local p, m, nsid, id, ns, sym;

	p = (`uint64*)dat;
	nsid = *p++;
	[id, p] = decodes(p);
	ns = nsid2ns[nsid];
	if(ns == nil){
		rerror(fd, msg->tag, "unknown name space");
		return 'badop;
	}
	sym = looksym(ns, mkcid(id));
	if(sym == nil){
		rerror(fd, msg->tag, Enone);
		return 'badop;
	}

	m = p = (sctl`Rlooksym*)mkxs();
	p->op = sctl`Rlooksym;
	p->tag = msg->tag;
	p++;
	p = encodesym(p, sym);
	sendmsg(fd, m, (char*)p-(char*)m);
	return 'ok;
}

@define tenumsym(fd, msg, dat)
{
	@local p, m, nsid, ns, n, ss;

	p = (`uint64*)dat;
	nsid = *p++;
	ns = nsid2ns[nsid];
	if(ns == nil){
		rerror(fd, msg->tag, "unknown name space");
		return 'badop;
	}

	ss = ns.enumsym();
	n = length(ss);
	m = p = (sctl`Renumsym*)mkxs();
	p->op = sctl`Renumsym;
	p->tag = msg->tag;
	p++;
	p = (`uint64*)p;
	*p++ = n;
	foreach(@lambda(id, sym) { p = encodesym(p, sym); }, ss);
	sendmsg(fd, m, (char*)p-(char*)m);
	return 'ok;
}

@define tlookaddr(fd, msg, dat)
{
	@local p, m, nsid, ns, addr, sym;

	p = (`uint64*)dat;
	nsid = *p++;
	addr = *p++;

	ns = nsid2ns[nsid];
	if(ns == nil){
		rerror(fd, msg->tag, "unknown name space");
		return 'badop;
	}
	sym = ns.lookaddr(addr);
	m = p = (sctl`Rlookaddr*)mkxs();
	p->op = sctl`Rlookaddr;
	p->tag = msg->tag;
	p++;
	p = encodesym(p, sym);
	sendmsg(fd, m, (char*)p-(char*)m);
	return 'ok;
}

/* FIXME: resolve issues in equivalence that led us to
   explicitly unify types of handle keys */
handle = [
	(sctl`Mkind)sctl`Tversion  : tversion,
	(sctl`Mkind)sctl`Tping     : tping,
	(sctl`Mkind)sctl`Tps       : notimpl,
	(sctl`Mkind)sctl`Tlaunch   : notimpl,
	(sctl`Mkind)sctl`Tattach   : notimpl,
	(sctl`Mkind)sctl`Tstat     : notimpl,
	(sctl`Mkind)sctl`Tcont     : notimpl,
	(sctl`Mkind)sctl`Tstop     : notimpl,
	(sctl`Mkind)sctl`Tstep     : notimpl,
	(sctl`Mkind)sctl`Tsnap     : notimpl,
	(sctl`Mkind)sctl`Tkill     : notimpl,
	(sctl`Mkind)sctl`Tdetach   : notimpl,
	(sctl`Mkind)sctl`Ttrace    : notimpl,
	(sctl`Mkind)sctl`Tsettrap  : notimpl,
	(sctl`Mkind)sctl`Tclrtrap  : notimpl,
	(sctl`Mkind)sctl`Tgetctx   : notimpl,
	(sctl`Mkind)sctl`Tsetctx   : notimpl,
	(sctl`Mkind)sctl`Tread     : notimpl,
	(sctl`Mkind)sctl`Twrite    : notimpl,
	(sctl`Mkind)sctl`Tlooksym  : tlooksym,
	(sctl`Mkind)sctl`Tenumsym  : tenumsym,
	(sctl`Mkind)sctl`Tlooktype : tlooktype,
	(sctl`Mkind)sctl`Tenumtype : tenumtype,
	(sctl`Mkind)sctl`Tlookaddr : tlookaddr,
	(sctl`Mkind)sctl`Tenumloc  : notimpl,
	(sctl`Mkind)sctl`Tunwind   : notimpl,
	(sctl`Mkind)sctl`Tenumseg  : notimpl,
	(sctl`Mkind)sctl`Tnames    : tnames,
];

@define tdispatch(fd)
{
	@local msg, dat, fn;
	[msg, dat] = recvmsg(fd);
	if(msg == nil)
		return dat;
	fn = handle[(sctl`Mkind)msg->op];
	if(fn == nil)
		return 'badop;
	return fn(fd, msg, dat);
}

@global nextnsid;
nextnsid = 1;
@define openns(path)
{
	@local id;
	id = path2nsid[path];
	if(id)
		return id;
	printf("opening %s (%s)\n", path, prefix+path);
	evalk(sprintfa("@names clp64le { @include \"%s\" };", prefix+path),
//	evalk(sprintfa("@names clp64le {  };", prefix+path),
	      @lambda(ns){
		      printf("success!\n");
		      id = (`uint64)nextnsid++;
		      nsid2ns[id] = ns;
		      path2nsid[path] = id;
		      return id;
	      },
	      @lambda(){ return nil; });
}

@define main(port)
{
	@local lfd, fd, fds, rs, x;
	lfd = tcplisten(sprintfa(":%u", port));
	fds = [ lfd ];
	prefix = getenv("HOME")+"/src/l1/";
	path2nsid = [:];
	nsid2ns = [:];
	while(1){
		[rs, _, _] = select(fds, [], []);
		foreach(@lambda(r){
				if(r == lfd){
					fd = tcpaccept(lfd);
					printf("accepted connection from ");
					printf("%s\n", fmtsa(getpeername(fd)));
					append(fds, fd);
					return;
				}
				switch(x = tdispatch(r)){
				case 'closed:
					printf("closing %s\n",
					       fmtsa(getpeername(r)));
					close(r);
					delete(fds, r);
					break;
				case 'badop:
					printf("bad op!\n");
					close(r);
					delete(fds, r);
					break;
				case 'ok:
					break;
				default:
					printf("??tdispatch?? %a\n", x);
					break;
				}
			}, rs);
	}
}

main(30000);
