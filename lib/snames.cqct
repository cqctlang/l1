#!/usr/bin/env l1
!#
@include <ns9p.cqct>   /* Diru */
@include <sctl.cqct>
@include <sctlclt.cqct>

@global nsid2path;
@global path2nsid;
@global nsid2ns;
@global prefix;
@global vars;
@global index;
@global history;
@global rootns;
@global mode;

sns = @names clp64be {
	typedef short unsigned int sa_family_t;
	typedef uint16 in_port_t;
	typedef uint32 in_addr_t;

	struct in_addr {
		@0x0	in_addr_t s_addr;
		@0x4;
	};

	struct sockaddr_in {
		@0x0	sa_family_t sin_family;
		@0x2	in_port_t sin_port;
		@0x4	struct in_addr sin_addr;
		@0x8	unsigned char sin_zero[0x8];
		@0x10;
	};
};

@define fmtsa(sa)
{
	@local p;
	sa = (struct sns`sockaddr_in*)sa;
	p = (uint8*)&sa->sin_addr.s_addr;
	return sprintfa("%u.%u.%u.%u:%u",
			p[0], p[1], p[2], p[3],
			sa->sin_port);
}

@define notimpl(fd, msg, dat)
{
	sctlrerror(fd, msg->tag,
		   "server does not support %e", (sctl`Mkind)msg->op);
	return 'badop;
}

@define botch(fd, tag)
{
	sctlrerror(fd, tag, "protocol botched");
	return 'badop;
}

@define tnames(fd, msg, dat)
{
	@local p, sz, nsid;
	@local q, path;

	q = (uint64*)dat;
	[path, q] = decodes(q);

	nsid = openns(prefix+path);
	if(nsid == nil){
		sctlrerror(fd, msg->tag, Enone);
		return 'ok;
	}
	sz = sizeof(sctl`Rnames);
	p = (sctl`Rnames*)malloc(sz);
	p->op = sctl`Rnames;
	p->tag = msg->tag;
	p->id = nsid;
	sendmsg(fd, p);
	return 'ok;
}

@define tping(fd, msg, dat)
{
	@local p, sz;
	sz = sizeof(sctl`Rping);
	p = (sctl`Rping*)malloc(sz);
	p->op = sctl`Rping;
	p->tag = msg->tag;
	p->cnt = length(dat);
	sendmsg(fd, p);
	return 'ok;
}

@define tversion(fd, msg, dat)
{
	@local p, sz, s;
	s = split(dat, ":");
	if(length(s) < 1){
		botch(fd, msg->tag);
		return 'badop;
	}
	if(s[0] != "sctl-2010"){
		sctlrerror(fd, msg->tag, "unsupported version");
		return 'badop;
	}
	if(length(s) != 2){
		botch(fd, msg->tag);
		return 'badop;
	}
	sz = sizeof(sctl`Rversion)+strlen(dat);
	p = (sctl`Rversion*)malloc(sz);
	p->op = sctl`Rversion;
	p->tag = msg->tag;
	putbytes(p+1, dat);
	sendmsg(fd, p, sz);
	return 'ok;
}

@define tlooktype(fd, msg, dat)
{
	@local p, m, nsid, tn, ns, td;
	p = (uint64*)dat;
	nsid = *p++;
	[tn, p] = decodetname(p);
	ns = looknsid(nsid);
	if(ns == nil){
		sctlrerror(fd, msg->tag, "unknown name space");
		return 'ok;
	}
	td = ns.looktype(tn);
	if(td == nil){
       		sctlrerror(fd, msg->tag, Enone);
		return 'ok;
	}
	m = p = (sctl`Rlooktype*)mkxs();
	p->op = sctl`Rlooktype;
	p->tag = msg->tag;
	p++;
	p = encodetdef(p, td);
	sendmsg(fd, m, (char*)p-(char*)m);
	return 'ok;
}

@define tenumtype(fd, msg, dat)
{
	@local p, m, nsid, ns, ts, nt;
	p = (uint64*)dat;
	nsid = *p++;
	ns = looknsid(nsid);
	if(ns == nil){
		sctlrerror(fd, msg->tag, "unknown name space");
		return 'ok;
	}
	ts = ns.enumtype();
	nt = length(ts);
	m = p = (sctl`Renumtype*)mkxs();
	p->op = sctl`Renumtype;
	p->tag = msg->tag;
	p++;
	p = (uint64*)p;
	*p++ = nt;
	foreach(@lambda(tn, td){ p = encodetdef(p, td); }, ts);
	sendmsg(fd, m, (char*)p-(char*)m);
	return 'ok;
}

@define tlooksym(fd, msg, dat)
{
	@local p, m, nsid, id, ns, sym;

	p = (uint64*)dat;
	nsid = *p++;
	[id, p] = decodes(p);
	ns = looknsid(nsid);
	if(ns == nil){
		sctlrerror(fd, msg->tag, "unknown name space");
		return 'ok;
	}
	sym = looksym(ns, mkcid(id));
	if(sym == nil){
		sctlrerror(fd, msg->tag, Enone);
		return 'ok;
	}

	m = p = (sctl`Rlooksym*)mkxs();
	p->op = sctl`Rlooksym;
	p->tag = msg->tag;
	p++;
	p = encodesym(p, sym);
	sendmsg(fd, m, (char*)p-(char*)m);
	return 'ok;
}

@define tenumsym(fd, msg, dat)
{
	@local p, m, nsid, ns, n, ss;

	p = (uint64*)dat;
	nsid = *p++;
	ns = looknsid(nsid);
	if(ns == nil){
		sctlrerror(fd, msg->tag, "unknown name space");
		return 'ok;
	}

	ss = ns.enumsym();
	n = length(ss);
	m = p = (sctl`Renumsym*)mkxs();
	p->op = sctl`Renumsym;
	p->tag = msg->tag;
	p++;
	p = (uint64*)p;
	*p++ = n;
	foreach(@lambda(id, sym) { p = encodesym(p, sym); }, ss);
	sendmsg(fd, m, (char*)p-(char*)m);
	return 'ok;
}

@define tlookaddr(fd, msg, dat)
{
	@local p, m, nsid, ns, addr, sym;

	p = (uint64*)dat;
	nsid = *p++;
	addr = *p++;

	ns = looknsid(nsid);
	if(ns == nil){
		sctlrerror(fd, msg->tag, "unknown name space");
		return 'ok;
	}
	sym = ns.lookaddr(addr);
	if(sym == nil){
       		sctlrerror(fd, msg->tag, Enone);
		return 'ok;
	}
	m = p = (sctl`Rlookaddr*)mkxs();
	p->op = sctl`Rlookaddr;
	p->tag = msg->tag;
	p++;
	p = encodesym(p, sym);
	sendmsg(fd, m, (char*)p-(char*)m);
	return 'ok;
}

@define tunwind1(fd, msg, dat)
{
	@local m, p, nsid, ctx, ns, rs;

	p = (uint64*)dat;
	nsid = *p++;
	ctx = p;

	ns = looknsid(nsid);
	if(ns == nil){
		sctlrerror(fd, msg->tag, "unknown name space");
		return 'ok;
	}

	/* FIXME: we should not expose the Ctx type,
	   but it is needed to tell sctlunwind1 how
	   big the Ctx buffer is */
	rs = ns.unwind1((sctl`Ctx*)ctx);
	if(rs == nil){
		sctlrerror(fd, msg->tag, Enone);
		return 'ok;
	}
	m = p = (sctl`Runwind1*)mkxs();
	p->op = sctl`Runwind1;
	p->tag = msg->tag;
	p++;
	p = (char*)p;
	putbytes(p, rs);
	p += length(rs);
	sendmsg(fd, m, (char*)p-(char*)m);
	return 'ok;
}

@define tlooksrc(fd, msg, dat)
{
	@local m, p, nsid, ctx, ns, rs;

	p = (uint64*)dat;
	nsid = *p++;
	ctx = p;

	ns = looknsid(nsid);
	if(ns == nil){
		sctlrerror(fd, msg->tag, "unknown name space");
		return 'ok;
	}

	/* FIXME: we should not expose the Ctx type,
	   but it is needed to tell sctllooksrc how
	   big the Ctx buffer is */
	rs = ns.looksrc((sctl`Ctx*)ctx);
	if(rs == nil){
		sctlrerror(fd, msg->tag, Enone);
		return 'ok;
	}
	m = p = (sctl`Rlooksrc*)mkxs();
	p->op = sctl`Rlooksrc;
	p->tag = msg->tag;
	p++;
	p = (char*)p;
	putbytes(p, rs);
	p += length(rs);
	sendmsg(fd, m, (char*)p-(char*)m);
	return 'ok;
}

@define tenumloc(fd, msg, dat)
{
	@local m, p, nsid, ctx, ns, ls;

	p = (uint64*)dat;
	nsid = *p++;
	ctx = p;

	ns = looknsid(nsid);
	if(ns == nil){
		sctlrerror(fd, msg->tag, "unknown name space");
		return 'ok;
	}

	/* FIXME: we should not expose the Ctx type,
	   but it is needed to tell sctlenumloc how
	   big the Ctx buffer is */
	ls = ns.enumloc((sctl`Ctx*)ctx);
	if(ls == nil){
		sctlrerror(fd, msg->tag, Enone);
		return 'ok;
	}

	m = p = (sctl`Renumloc*)mkxs();
	p->op = sctl`Renumloc;
	p->tag = msg->tag;
	p++;
	p = (uint64*)p;
	*p++ = length(ls);
	foreach(@lambda(l){
			p = encodes(p, cid2str(l.id));
			p = encodetname(p, l.type);
			p = (uint8*)p;
			*p++ = l.ltype;
			p = encodelexpr(p, l.loc);
		}, ls);
	sendmsg(fd, m, (char*)p-(char*)m);
	return 'ok;
}

/* FIXME: resolve issues in equivalence that led us to
   explicitly unify types of handle keys */
handle = [
	(sctl`Mkind)sctl`Tversion  : tversion,
	(sctl`Mkind)sctl`Tping     : tping,
	(sctl`Mkind)sctl`Tps       : notimpl,
	(sctl`Mkind)sctl`Tlaunch   : notimpl,
	(sctl`Mkind)sctl`Tattach   : notimpl,
	(sctl`Mkind)sctl`Tstat     : notimpl,
	(sctl`Mkind)sctl`Tcont     : notimpl,
	(sctl`Mkind)sctl`Tstop     : notimpl,
	(sctl`Mkind)sctl`Tstep     : notimpl,
	(sctl`Mkind)sctl`Tsnap     : notimpl,
	(sctl`Mkind)sctl`Tkill     : notimpl,
	(sctl`Mkind)sctl`Tdetach   : notimpl,
	(sctl`Mkind)sctl`Ttrace    : notimpl,
	(sctl`Mkind)sctl`Tsettrap  : notimpl,
	(sctl`Mkind)sctl`Tclrtrap  : notimpl,
	(sctl`Mkind)sctl`Tgetctx   : notimpl,
	(sctl`Mkind)sctl`Tsetctx   : notimpl,
	(sctl`Mkind)sctl`Tread     : notimpl,
	(sctl`Mkind)sctl`Twrite    : notimpl,
	(sctl`Mkind)sctl`Tlooksym  : tlooksym,
	(sctl`Mkind)sctl`Tenumsym  : tenumsym,
	(sctl`Mkind)sctl`Tlooktype : tlooktype,
	(sctl`Mkind)sctl`Tenumtype : tenumtype,
	(sctl`Mkind)sctl`Tlookaddr : tlookaddr,
	(sctl`Mkind)sctl`Tenumloc  : tenumloc,
	(sctl`Mkind)sctl`Tunwind   : notimpl,
	(sctl`Mkind)sctl`Tunwind1  : tunwind1,
	(sctl`Mkind)sctl`Tlooksrc  : tlooksrc,
	(sctl`Mkind)sctl`Tenumseg  : notimpl,
	(sctl`Mkind)sctl`Tnames    : tnames,
];

@define tdispatch(fd)
{
	@local msg, dat, fn;
	[msg, dat] = recvmsg(fd);
	if(msg == nil)
		return dat;
	fn = handle[(sctl`Mkind)msg->op];
	if(fn == nil)
		return 'badop;
	return fn(fd, msg, dat);
}

@define remember()
{
	@local s;
	if(!access(history, "r"))
		return;
	s = mapfile(history);
	foreach(@lambda(l){
			@local vs;
			vs = split(l, " ");
			nsid2path[(uint64)strton(vs[0])] = vs[1];
		}, split(s, "\n"));
}

@define record()
{
	@local fd;
	fd = open(history, "w");
	foreach(@lambda(nsid, path){
			fprintf(fd, "%u %s\n", nsid, path);
		}, nsid2path);
	close(fd);
}

@define bindns(id, path, ns)
{
	nsid2ns[id] = ns;
	path2nsid[path] = id;
	nsid2path[(uint64)id] = path;
	record();
}

@define opennsnames(path)
{
	@local id, s, a, nc, st;
	id = path2nsid[path];
	if(id)
		return id;
	if(!access(path, "r"))
		return nil;
	st = (ns9p`Diru*)stat(path);
	s = "@lambda(";
	a = "}(";
	nc = 1;
	foreach(@lambda(v) {
			@local fmts, fmta;
			if(nc){
				nc = 0;
				fmts = "%s";
				fmta = "%u";
			}else{
				fmts = ", %s";
				fmta = ", %u";
			}
			s += sprintfa(fmts, v);
			a += sprintfa(fmta, 0);
		}, vars);
	s += "){\n";
	a += ");\n";
	s += sprintfa("\t@names %s { @include \"%s\" };\n", rootns, path);
	s += a;
//	printf("evaluating ...\n%s\n", s);
	evalk(s,
	      @lambda(ns){
		      id = st->qid.path;
		      bindns(id, path, ns);
		      return id;
	      },
	      @lambda(){ return nil; });
}

@global nextid;
nextid = 0;

@define opennssctl(path)
{
	@local id, ns;
	id = path2nsid[path];
	if(id)
		return id;
	ns = atnames(path);
	if(ns == nil)
		return nil;
	id = ++nextid;
	bindns(id, path, ns);
	return id;
}

@global openns;

@define looknsid(nsid)
{
	@local ns, path;
	ns = nsid2ns[nsid];
	if(ns)
		return ns;
	path = nsid2path[nsid];
	if(path){
		openns(path);
		ns = nsid2ns[nsid]; /* maybe nil */
	}
	return nil;
}

@define main(port, pref, vs)
{
	@local lfd, fd, fds, rs, x;
	lfd = tcplisten(sprintfa(":%u", port));
	fds = [ lfd ];
	path2nsid = [:];
	nsid2ns = [:];
	nsid2path = [:];
	history = "/tmp/snames."+getenv("USER");
	remember();
	prefix = pref;
	vars = vs;
	if(length(prefix) && prefix[strlen(prefix)-1] != '/')
		prefix += "/";
	while(1){
		[rs, _, _] = select(fds, [], []);
		foreach(@lambda(r){
				if(r == lfd){
					fd = tcpaccept(lfd);
//					printf("accepted connection from ");
//					printf("%s\n", getpeername(fd));
					append(fds, fd);
					return;
				}
				switch(x = tdispatch(r)){
				case 'closed:
//					printf("closing %s\n", getpeername(r));
					close(r);
					delete(fds, r);
					break;
				case 'badop:
//					printf("bad op!\n");
					close(r);
					delete(fds, r);
					break;
				case 'ok:
					break;
				default:
					printf("??tdispatch?? %a\n", x);
					break;
				}
			}, rs);
	}
}

@define watchdog(fn)
{
	@local pid, s;
	while(1){
		pid = fork();
		if(pid == 0){
			fn();
			exit(1);
		}
		[_, s] = waitpid(pid, 0);
		printf("pid has failed (status=%x) ... restarting\n", s);
	}
}

if(length(args) < 4){
	printf("usage: %s PORT ROOTNS MODE PREFIX [VAR ...] \n", "snames.cqct");
	exit(1);
}

pop(args);
port = strton(pop(args));
rootns = pop(args);
mode = pop(args);
prefix = pop(args);
if(mode == "sctl")
	openns = opennssctl;
else if(mode == "names")
	openns = opennsnames;
else{
	printf("%s: mode must be \"sctl\" or \"names\"\n");
	exit(1);
}
	
watchdog(@lambda(){ main(port, prefix, args); });
