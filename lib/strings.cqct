
@global strtoupper, strtolower, ucs2_to_ascii, ucs2n_to_ascii;
{

@define strtoupper(s) {
	@local i,l,ret;

	l = length(s);
	ret = mkstr(l);
	for (i = 0; i < l; i++)
		ret[i] = toupper(s[i]);

	return ret;
}


@define strtolower(s) {
	@local i,l,ret;

	l = length(s);
	ret = mkstr(l);
	for (i = 0; i < l; i++)
		ret[i] = tolower(s[i]);

	return ret;
}

// this works through the miracle of truncation
@define ucs2n_to_ascii(ptr,units) {
	@local retstr, i;
	@local v;

	ptr=(unsigned char *)ptr;
	if( (*ptr == 0x00) && (*(ptr+1) == 0x00) )
		return "";	// easy
	else if( (*ptr == 0xfe) && (*(ptr+1) == 0xff) )
		ptr=(unsigned short *){mkdom(c32be,asof(ptr))}ptr; // correct
	else if( (*ptr == 0xff) && (*(ptr+1) == 0xfe) )
		ptr=(unsigned short *){mkdom(c32le,asof(ptr))}ptr; // correct
	else
		ptr=(unsigned short *)ptr; // hope for the best

	retstr = mkstr(units);
	
	for(i=0;i<units;i++) {
		v=*(ptr+i);
		if( (  (v>=0x0000) && (v<=0xd7ff ) )
		    || (v>=0xe000) && (v<=0xffff ) )
			retstr[i]=v&0xff;
		else
			error("invalid UCS2 code point U+%04X",v);
	}

	return retstr;
}

@define ucs2_to_ascii(ptr) {
	@local c;

	ptr=(unsigned short *)ptr;

	c=ptr;
	while(*c) c++;

	return ucs2n_to_ascii(ptr,c-ptr);
}

/*
// Convert a string of 8 bit chars to one of 16 bit chars

// Convert a string of 8 bit chars to one of 16 bit chars
//  where each new char has second 8 bits all 0
@define utf8toutf16(ptr,len...) {
    @local retstr, i;

    if (length(len) > 0) {
        len = len[0];
    } else if (isstring(ptr)) {
        len = length(ptr);
    } else {
        len = nil;
    }

    ptr = (char *)ptr;
    retstr = mkstr(2*len);
    for (i=0; i<len; i+=1) {
        retstr[i*2] = ptr[i];
        retstr[i*2+1] = 0;
    }

    return retstr;
}
*/

}
