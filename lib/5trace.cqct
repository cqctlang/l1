@include <ctlmux.cqct>
@global freqms;

@define sym2addr(dom, sym)
{
	@local t;
	t = mkctype_ptr(symtype(sym), nsptr(dom));
	return {dom}{t}symoff(sym);
}

@define basename(cmd)
{
	@local l;
	l = split(cmd, "/");
	return l[length(l)-1];
}

@define msec()
{
	return gettimeofday()/1000;
}

@define coresize(pid)
{
	@local fd, pf, s, sz;
	pf = sprintfa("/proc/%d/statm", pid);
	if(access(pf, "r") == 0)
		return "0";
	fd = open(pf, "r");
	s = read(fd, 100);
	close(fd);
	sz = strton(split(s, " ")[0])*4096;
	return sprintfa("%u", sz);
}

@define main(cmd, entries, exits)
{
	@local mux, ctl, dom, fd, evs, pid, name, out, beg;
	@local boths;

	evs = [];
	@defloc trace(kind, id)
	{
		append(evs, [ msec() - beg, coresize(pid), kind, id ]);
	}

	@defloc settrap(tf, kind, id){
		@local sym;
		sym = dom.looksym(id);
		if(sym == nil){
			printf("target does not define %s\n", id);
			return;
		}
		tf(sym2addr(dom, sym),
		   @lambda(ctl, arg ...){
			   trace(kind, id);
		   });
	}

	@defloc settrapboth(id){
		@local sym;
		sym = dom.looksym(id);
		if(sym == nil){
			printf("target does not define %s\n", id);
			return;
		}
		printf("setting both trap for %s\n", id);
		brbrk(sym2addr(dom, sym),
		      @lambda(ctl, arg ...){
			      trace('entry, id);
			      return @lambda(ctl, arg ...){
				      trace('exit, id);
			      };
		      });
	}

	@defloc findboths(entries, exits)
	{
		@local boths;
		boths = [];
		foreach(@lambda(id){
				if(ismember(entries, id)){
					delete(entries, id);
					delete(exits, id);
					append(boths, id);
				}
			}, copy(exits));
		return [entries, exits, boths];
	}

	name = mkcid(basename(cmd[0]));
	mux = mkctlmux_local();
	ctl = mux.launch(cmd, 0);
	dom = mkdom(ctl.ns(), ctl.mem());
	pid = ctl.id;
	[entries, exits, boths] = findboths(entries, exits);
	foreach(@lambda(id){ settrap(brk, 'entry, id); }, entries);
	foreach(@lambda(id){ settrap(rbrk, 'exit, id); }, exits);
	foreach(@lambda(id){ settrapboth(id); }, boths);
	beg = msec();
	mux.settimer(100,
		     @lambda(){
			     trace('mem, 'something);
		     });
	trace('launch, name);
	dom.xcont();
	mux.run();
	trace('exit, name);
	out = sprintfa("%s.%d", name, pid);
	fd = open(out, "w");
	foreach(@lambda(e){
			fprintf(fd, "%20u %20s %8s %20s\n",
				e[0], e[1], e[2], e[3]);
		}, evs);
	close(fd);
	printf("%s\n", out);
}

main(["/home/vic/src/l1/l1", "/home/vic/src/l1/names-load1.cqct" ],
     [ 'initvm, 'mknsraw,
       '_gc,
       'doparse,
       'docompileq, 'docompilen, 'docompilea, 'docompile0, 'docompileg,
       'docompilel, 'docompilei, 'docompile1, 'docompileb, 'docompilev ],
     [ 'finivm, 'mknsraw,
       'doparse,
       'docompileq, 'docompilen, 'docompilea, 'docompile0, 'docompileg,
       'docompilel, 'docompilei, 'docompile1, 'docompileb, 'docompilev ]
	);
