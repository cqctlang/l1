@include <chronicle.cqct>

@global Segsize;

Segsize = 1ULL<<20;

@define showargs(exe, n, t)
{
	@local args;

	args = chgetargs(exe, n, t);
	printf("args:");
	foreach(@lambda(a) { printf(" %d", a); }, args);
	printf("\n");
}

@define vkind(p)
{
	p = (Head*)p;
	(p->bits>>1)&0x1f;
}

@define dumpguards(exe, t)
{
	@local dom, H, i, p, o, k;
	dom = exe.dom(t);
	H = &dom`H;
	printf("@%d user guard list\n", t);
	for(i = 0; i < 4; i++){
		p = H->ug.gd[i];
		printf("gen %d user guard list:\n", i);
		while(vkind(p) != 1){
			k = vkind(xcar(xcar(p)));
			printf("\t%p %d", p, k);
			printf(" %s", fmtseg(p));
			if(k == 15){
				o = xcar(xcar(p));
				printf(" (object is %p pair(%d,%d))", o, vkind(xcar(o)), vkind(xcdr(o)));
				printf("\n");
			}
			p = (Pair*)p->cdr;
		}
	}
}

rdsetfmt(@record copyevent { time, from, to },
	 @lambda(r) { sprintfa("<copy @%d %p -> %p>", r.time, r.from, r.to); });

rdsetfmt(@record freesegevent { time, range },
	 @lambda(r) { sprintfa("<freeseg @%d %a >", r.time, r.range); });

rdsetfmt(@record malevent { time, addr },
	 @lambda(r) { sprintfa("<mal @%d of %p>", r.time, r.addr); });

rdsetfmt(@record valinterval { val, interval },
	 @lambda(r) { sprintfa("%a %a", r.interval, r.val); });


@define dumpvalpath(exe, cs)
{
	@local is, exedom;

	exedom = exe.exedom;
	is = callintervals(exe, exe.intvl(), &exedom`_gc);
	foreach(@lambda(c){
			@local ndx;
			if(ismalevent(c))
				printf("@%d mal %p\n", c.time, c.addr);
			else if(iscopyevent(c)){
				ndx = indexof(is, c.time);
				printf("@%d (gc #%d) %a\n", c.time, ndx, c);
//				dumpstack(exe, c.time);
//				uncovercopy(exe, c);
			}else if(isfreesegevent(c)){
				ndx = indexof(is, c.time);
				printf("@%d (gc #%d) %a\n", c.time, ndx, c);
			}else
				printf("unknown event %a\n", c);
			ndx = 0;
		}, cs);
}

/* T should be time of a call to freeseg in EXE.
   return range specifying range of addresses freed.
*/
@define freesegrange(exe, t)
{
	@local s, ctx, dom, a;
	dom = exe.dom(t);
	ctx = exe.ctx(t);
	s = (Seg*){dom}ctx->rdi;
	a = s2a(s);
	return mkrange(a, Segsize);
}

/* determine the future of the value at ADDR at time T */
@define valfuture(exe, addr, t)
{
	@local exedom;
	@local gcs, copyt, rvs;

	exedom = exe.exedom;

	/* find all intervals of gc execution */
	gcs = callintervals(exe, exe.intvl(), &exedom`_gc);
	
	@defloc findcopy(addr, t)
	{
		@local is, wi;
		/* clip gc history to those up to T */
		is = clipbeg(gcs, t);

		/* find next write to value header by a gc in forward order */
		foreach(@lambda(gc){
				@local ws;
				if(wi)
					return; /* shitty control logic */
				ws = exe.scan('write, addr, sizeof(exedom`Head), gc.beg, gc.end);
				if(length(ws) == 0)
					return;
				if(length(ws) > 1){
					printf("valfuture picking first of %d writes for %p in gc interval:\n", length(ws), addr);
					foreach(@lambda(w){
							printf("@%d\n", w);
							dumpstack(exe, w);
							printf("\n");
						}, ws);
				}
				wi = ws[0];
			}, is);

		return wi;
	}

	@defloc findfreeseg(addr, t)
	{
		@local is, rv;
		is = clipbeg(gcs, t);
		foreach(@lambda(gc){
				@local xs;
				if(rv)
					return;
//				printf("scanning freesegs in %a\n", gc);
				xs = exe.scan('exec, &exedom`freeseg, gc.beg, gc.end);
				if(length(xs) == 0)
					return;
//				printf("%d freesegs in gc %a\n", length(xs), gc);
				foreach(@lambda(t){
						@local r;
						r = freesegrange(exe, t);
						if(rangebeg(r) <= addr && addr < rangebeg(r)+rangelen(r))
							rv = freesegevent(t, r);
					}, xs);
//				printf("scanned freesegs ranges\n");
			}, is);
		return rv;
	}

	/* find the sequence of copies of this value */
	rvs = [];
	printf("1. finding copy of %p\n", addr);
	while(copyt = findcopy(addr, t)){
		@local fwd, ldom, ev;
//		printf("found copy %d\n", t);
		ldom = exe.ldom(copyt);
		fwd = ldom`nh;
//		printf("read domain %d\n", t);
		ev = copyevent(copyt, addr, fwd);
		append(rvs, ev);
		addr = fwd;
		t = copyt;
		printf("i. finding copies of %p\n", addr);
	}

//	printf("finding freeseg\n");
	/* find the freeseg containing ADDR after T */
	append(rvs, findfreeseg(addr, t));
//	printf("found freeseg\n");

//	dumpvalpath(exe, rvs);

	return rvs;
}

/* determine the history of the value at ADDR at time T */
@define valhistory(exe, addr, t)
{
	@local exedom;
	@local gcs;
	@local ev, evs, ms;
	@local orig, origt;

	exedom = exe.exedom;

	/* find all intervals of gc execution */
	gcs = callintervals(exe, exe.intvl(), &exedom`_gc);
//	printf("%d calls to _gc\n", length(gcs));

	@defloc findcopy(addr, t)
	{
		@local is, wi, copyt, ts, m, args, dom, p;

		/* clip gc history to those up to T */
		is = clipend(gcs, t);

		/* find last write to value header by a gc in reverse order */
		m = length(is);
		foreach(@lambda(gc){
				@local ws;

				m--;
				if(wi)
					return; /* shitty control logic */

				ws = exe.scan('write, addr, sizeof(exedom`Head), gc.beg, gc.end);
				if(length(ws) == 0)
					return;

//				printf("found %d writes to header for %p in gc %d\n", length(ws), addr, m);
//				printf("write at %-16d:\n", ws[0]);
//				dumpstack(exe, ws[0]);
				/* whack this interval to prevent detection of
				   later write event to the from pointer */
				gc.end = ws[0];

				/* assume every write occurs in the context of
				   a single call to copy; pick one */
				wi = interval(gc.beg, ws[0]);
		}, reverse(is));

		if(wi == nil)
			return nil;
		
		/* find the corresponding call to copy
		   lower bound does not matter, but must
		   include prefix of the gc interval */
		ts = exe.scan('lastexec, &exedom`copy, wi.beg, wi.end);
		if(length(ts) != 1)
			error("no call event!");
		copyt = ts[0];
		
		args = chgetargs(exe, 1, copyt);
		dom = mkdom(exedom.ns, exe.mem(copyt));
		p = (Val*){dom}args[0];
		return copyevent(copyt, *p, addr);
	}

	evs = [];
	while(ev = findcopy(addr, t)){
		append(evs, ev);
		addr = ev.from;
		t = ev.time;
	}
	evs = reverse(evs);
	if(length(evs) == 0){
		orig = addr;
		origt = t;
	}else{
		orig = evs[0].from;
		origt = evs[0].time;
	}

	/* now try to find the allocation event: the
	   last write to the header prior to the first copy
	   over the entire execution prefix */
	ms = exe.scan('lastwrite, orig, sizeof(exedom`Head), 0, origt);
	if(length(ms) != 1)
		return nil;
	push(evs, malevent(ms[0], orig));
//	printf("found mal event for %p\n", orig);
//	dumpstack(exe, ms[0]);
	return evs;
}

@define vallife(ch, addr, t)
{
	@local h, f, a, m;
	h = valhistory(ch, addr, t);
	if(h == nil)
		return nil;
	if(!ismalevent(h[0]))
		error("unexpected history element %a", h[0]);
	m = h[0];
	a = m.addr;
	t = m.time;
	f = valfuture(ch, a, t);
	if(f == nil || length(f) == 0)
		return nil;
	push(f, h[0]);
	return mkspans(f);
}

@define gcintervals(exe)
{
	@local whole, exedom, is;
	exedom = exe.exedom;
	whole = exe.intvl();
	is = callintervals(exe, whole, &exedom`_gc);
	return is;
}

@define gcsummary(exe)
{
	@local is, m;

	is = gcintervals(exe);
	printf("%d calls to _gc\n", length(is));
	m = 0;
	foreach(@lambda(i){
			printf("\t#%d @%d - @%d ", m++, i.beg, i.end);
			showargs(exe, 2, i.beg);
		}, is);
	return is;
}

@define foreachgc(exe, beg, end)
{
	@local whole, exedom, is, m;

	exedom = exe.exedom;
	whole = exe.intvl();

	is = callintervals(exe, whole, &exedom`_gc);
	printf("%d calls to _gc\n", length(is));
	m = 0;
	foreach(@lambda(i){
			printf("\t#%d @%d - @%d ", m++, i.beg, i.end);
			showargs(exe, 2, i.beg);
			if(beg){
				printf("\t@%d:\n", i.beg);
				beg(exe, i.beg);
			}
			if(end){
				printf("\t@%d:\n", i.end);
				end(exe, i.end);
				printf("\n");
			}
		}, is);
}

@define badwrites(exe)
{
	@local whole;
	@local nfs, fss, frs;
	@local inits, finis, window, unstable, stable, m;
	@local exedom;

	exedom = exe.exedom;
	whole = exe.intvl();

	/* critical sections on free list */
	nfs = callintervals(exe, whole, &exedom`nextfree);
	fss = callintervals(exe, whole, &exedom`freeseg);
	frs = callintervals(exe, whole, &exedom`freerange);
	unstable = mergeivs(nfs, mergeivs(fss, frs));

	printf("  %3d calls to nextfree\n", length(nfs));
	printf("  %3d calls to freeseg\n", length(fss));
	printf("  %3d calls to freerange\n", length(frs));
	printf("= %3d calls to segment free list critical sections\n",
	       length(unstable));

	/* define window to search: from return of initmem to return of finimem */
	inits = callintervals(exe, whole, &exedom`initmem);
	finis = callintervals(exe, whole, &exedom`finimem);
	if(length(inits) != 1 || length(finis) != 1)
		error("non-standard l1 execution");
	window = interval(inits[0].end, finis[0].end);

	/* subdivide window into intervals where free list is constant */
	stable = invert(clip(unstable, window), window);
	printf("%d stable intervals in window\n", length(stable));

	/* look for writes into free segments during any of these intervals */

	/* helper: extract list of free segments at time T */
	@defloc freesegs(t)
	{
		@local dom, f, rs, sz;
		rs = [];
		dom = exe.dom(t);
		sz = 1ULL<<20;
		f = dom`segmap.free;
		while(f){
			append(rs, mkrange(f, sz));
			f = *(void**)f;
		}
		return rs;
	}

	m = 0;
	foreach(@lambda(s){
			@local ws, fs;
			fs = freesegs(s.beg);
			printf("stable interval #%3d (%10d - %10d) %d free segments\n", m, s.beg, s.end, length(fs));
			foreach(@lambda(f){
					ws = exe.scan('write, rangebeg(f), rangelen(f), s.beg, s.end);
					foreach(@lambda(w){
							printf("\t@%d write into free segment %016p-%016p\n",
							       w, rangebeg(f), rangebeg(f)+rangelen(f));
						}, ws);
				}, fs);
			m++;
		}, stable);
}

/* given a copy event, find the object it was scanned
   from.  */
@define uncovercopy(exe, ctime)
{
	@local exedom, ts, callt, scant, ldom, ctx, sym;

	exedom = exe.exedom;

	/* who called us? */
	ts = exe.scan('lastexec, &exedom`copy, 0, ctime);
	if(length(ts) != 1)
		error("cannot find call to copy!");
	callt = ts[0]-1;
	
	printf("copy was called @%d\n", callt);
	dumpstack(exe, callt);
	ctx = exe.ctx(callt);
	sym = exedom.ns.lookaddr(ctx->pc);

	if(symid(sym) == 'scan1){
		printf("it's a scan1 call!\n");
		ts = exe.scan('lastexec, &exedom`scan1, 0, callt);
		if(length(ts) != 1)
			error("cannot find call to scan1");
		scant = ts[0]-1;
		ldom = exe.ldom(scant);
		printf("object was encountered while scanning %p %s\n",
		       ldom`h, fmtval(ldom`h));
		/* really want to bound this to the current gc */
		ts = exe.scan('lastwrite, ldom`h, sizeof(exedom`Head), 0, scant);
		if(length(ts) != 1)
			error("cannot find previous write");
		printf("header for object %p was last written @%d\n", ldom`h, ts[0]);
		uncovercopy(exe, ts[0]);
	}else
		printf("it's a %s call!\n", symid(sym));
}

/* dump the gc locked segments */
@define dumplocked(exe, t)
{
	@local dom, s, es, p;
	dom = exe.dom(t);
	s = a2s(dom`segmap.lo);
	es = a2s(dom`segmap.hi);
	while(s < es){
		if(s->gen == dom`Glock){
			printf("\tlocked segment %p\n", s);
			p = s->p;
			while(p){
				@local o;
				o = xcdr(xcar(p));
				printf("\t\t%p %s\n", o, fmtval(o));
				p = xcdr(p);
			}
		}
		s++;
	}
}


/* FIXME: walk through $halt, e.g.,
 in debug-stx9.2/l1/l1.db:
before @670039772:
	6d26c80	            kcapture
	7a00640	               $halt
	7a00640	               $halt
error: no bytes -- what do i do?
 */
@define vmbacktrace(exe, t)
{
	@local dom, vm;
	@local ra, cl, fp, cp;

	dom = exe.dom(t);
	vm = dom`vms[0];
	
	printf("vmbacktrace: vm->stk = %p vm->fp = %p vm->klink = %p\n",
               vm->stk, vm->fp, vm->klink);

	ra = vm->pc;
	cl = vm->cl;
	fp = vm->fp; /* Val* */
	if(fp < vm->stk)
		error("vmbacktrace: fp is below stack (stack = %p - %p, fp = %p)\n",
		      vm->stk, vm->stk+vm->stksz, fp);
	if(fp >= vm->stk+vm->stksz)
		error("vmbacktrace: fp is above stack (stack = %p - %p, fp = %p)\n",
		      vm->stk, vm->stk+vm->stksz, fp);
	if(ra == 0)
		return;
	cp = cl->code;
	printframe(0, ra, cp);
	while(fp > vm->stk){
		ra = fp[0];
		cl = (Closure*)fp[1];
		if(cl == 0){
		      printf("leaving for cl==0\n");
		      return;
		}
		cp = cl->code;
		printframe(fp, ra, cp);
		fp -= ra2size(ra, cp);
//		if((char*)(cl->code->id+1) == "$halt"){
//		      printf("leaving for $halt\n");
//		      return;
//              }
	}
	if(fp < vm->stk){
		printf("fp fell off stack! (fp = %p, stk = %p)\n",
		       fp, vm->stk);
		return;
	}
	cl = (Closure*)fp[1];
	ra = fp[0];
	if(cl == 0){
	      printf("leaving for cl==0\n");
	      return;
	}
	cp = cl->code;
	printframe(fp, ra, cp);
	vmkbacktrace(vm->klink);
}

@define vmkbacktrace(k)
{
	@local base;
	@local ra, cl, fp, cp, sz;

	if(k == 0)
		return;

	ra = k->ra;
	cl = k->cl;
	base = k->base;
	sz = k->sz;
	fp = (Val*)(base+k->sz);

	printf("vmkbacktrace: k = %p, k->base = %p, k->sz = %d, k->base+sz = %p k->link = %p\n",
	       k, k->base, k->sz, k->base+k->sz, k->link);

	if(fp < base)
		error("vmkbacktrace: fp is below stack (stack = %p - %p, fp = %p)\n",
		      base, base+sz, fp);
	if(fp > base+sz)
		error("vmkbacktrace: fp is above stack (stack = %p - %p, fp = %p)\n",
		      base, base+sz, fp);
	if(ra == 0)
		return;
	cp = cl->code;
	printframe(0, ra, cp);
	fp -= ra2size(ra, cp);
	while(fp > base){
		ra = fp[0];
		cl = (Closure*)fp[1];
		if(cl == 0){
		      printf("leaving for cl==0\n");
		      return;
		}
		cp = cl->code;
		printframe(fp, ra, cp);
		fp -= ra2size(ra, cp);
//		if((char*)(cl->code->id+1) == "$halt"){
//		      printf("leaving for $halt\n");
//		      return;
//                }
	}
	if(fp < base){
		printf("fp fell off stack! (fp = %p, stk = %p)\n",
		       fp, base);
		return;
	}
	cl = (Closure*)fp[1];
	ra = fp[0];
	if(cl == 0){
	      printf("leaving for cl==0\n");
	      return;
	}
	cp = cl->code;
	printframe(fp, ra, cp);
	vmkbacktrace(k->link);
}

@define l1demo1()
{
	@local exe, exedom, ldom;
	@local badt, cart, copyt, rett;

	exe = chronicledb("../l1.bug/lock.bug.db");
	exedom = exe.exedom;

	gcsummary(exe);
	badwrites(exe);
	badt = 792518402;
	dumpstack(exe, 792518402);
	dumpstack(exe, badt);
	ldom = exe.ldom(badt);
	fmtval(ldom`argv[0]);
	cart = exe.scan('lastexec, &exedom`l1_car, 0, badt)[0];
	dumpstack(exe, cart);
	ldom = exe.ldom(cart+10);
	fmtval(ldom`argv[0]);
	copyt = exe.scan('lastread, ldom`argv[0], sizeof(exedom`Head), 0, cart)[0];
	dumpstack(exe, copyt);
	rett = exe.findret(copyt);
	dumpstack(exe, rett);
	ldom = exe.ldom(rett);
	_fmtseg({exedom.ns}ldom`s);
	dumplocked(exe, rett);
//	dumpguards(exe, rett);   /* long! */
}

/* TI is an interval.
   IVS is a list of intervals, disjoint and in increasing order.
   return list of intervals representing subintervals
   of TI not in IVS. */
@define maskspan(ti, ivs)
{
	@local b, e, iv, rv, i;

	rv = [];
	b = ti.beg;
	e = ti.end;
	for(i = 0; i < length(ivs); i++){
		iv = ivs[i];
		if(e <= iv.beg){
			append(rv, interval(b, e));
			break;
		}else if(b >= iv.end)
			continue;
		else if(b >= iv.beg && e <= iv.end)
			break;
		else if(b < iv.beg && e <= iv.end){
			append(rv, interval(b, iv.beg));
			break;
		}else if(b < iv.beg && e > iv.end){
			append(rv, interval(b, iv.beg));
			b = iv.end;
			continue;
		}else if(b <= iv.end && e > iv.end){
			b = iv.end;
			continue;
		}else
			error("confusion");
	}
	return rv;
}

/* AVS and BVS are value intervals.
   subdivide so that no interval in AVS overlaps with
   one in BVS and vice-versa. */
@define shred(avs, bvs)
{
	@defloc loop(avs, bvs, navs, nbvs, cnt)
	{
		@local av, bv;
		@local ab, ae, bb, be;
		if(length(avs) == 0)
			return [navs, concat(nbvs, bvs)];
		else if(length(bvs) == 0)
			return [concat(navs, avs), nbvs];
		else{
			av = avs[0];
			bv = bvs[0];
			ab = av.interval.beg;
			ae = av.interval.end;
			bb = bv.interval.beg;
			be = bv.interval.end;

			if(ae <= bb){
				append(navs, pop(avs));
				loop(avs, bvs, navs, nbvs, cnt);
			}else if(ab < bb && ae <= be){
				pop(avs);
				pop(bvs);
				append(navs, valinterval(av.val, interval(ab, bb)));
				append(navs, valinterval(av.val, interval(bb, ae)));
				append(nbvs, valinterval(bv.val, interval(bb, ae)));
				if(ae < be)
					push(bvs, valinterval(bv.val, interval(ae, be)));
				loop(avs, bvs, navs, nbvs, cnt);
			}else if(ab <= bb && ae <= be){
				if(ab == bb && ae == be){
					append(navs, pop(avs));
					append(nbvs, pop(bvs));
					loop(avs, bvs, navs, nbvs, cnt);
				}else if(ab == bb && ae < be){
					pop(bvs);
					append(navs, pop(avs));
					append(nbvs, valinterval(bv.val, interval(bb, ae)));
					push(bvs, valinterval(bv.val, interval(ae, be))); 
					loop(avs, bvs, navs, nbvs, cnt);
				}else if(ab > bb && ae <= be){
					pop(avs);
					pop(bvs);
					append(nbvs, valinterval(bv.val, interval(bb, ab)));
					append(navs, valinterval(av.val, interval(ab, ae)));
					if(ae < be)
						push(bvs, valinterval(bv.val, interval(ae, be)));
					loop(avs, bvs, navs, nbvs, cnt);
				}else
					error("confusion");
			}else{
				printf("symmetry: a = %d - %d; b = %d - %d\n", ab, ae, bb, be);
				/* the remaining cases are symmetric */
				[nbvs, navs] = loop(bvs, avs, nbvs, navs, cnt+1);
				return [navs, nbvs];
			}
		}
	}
	return loop(copy(avs), copy(bvs), [], [], 0);
}

@define mix(avs, bvs, m)
{
	if(length(avs) != length(bvs))
		error("incompatible arguments");
	return map(@lambda(av, bv){
			if(av.interval.beg != bv.interval.beg)
				error("incompatible arguments");
			if(av.interval.end != bv.interval.end)
				error("incompatible arguments");
			valinterval(m(av.val, bv.val), av.interval);
		}, avs, bvs);
}

@define mkspans(mvs)
{
	@local b, v, rs;
	if(length(mvs) == 0)
		error("cannot deal with empty move list\n");
	rs = [];
	foreach(@lambda(e){
			switch(e){
			@match malevent(t, a):
				b = t;
				v = a;
				break;
			@match copyevent(t, old, new):
				append(rs, valinterval(v, interval(b, t)));
				b = t;
				v = new;
				break;
			@match freesegevent(t, r):
				append(rs, valinterval(v, interval(b, t)));
				break;
			}
		}, mvs);
	return rs;
}

/* l is a list of interval lists, each disjoint and in increasing order.
   return single flattened interval list */
@define megamergeivs(ls)
{
	@local acc;
	acc = [];
	foreach(@lambda(l){
			acc = mergeivs(acc, l);
		}, ls);
	return acc;
}

@define flatten(ls)
{
	@local acc;
	acc = [];
	foreach(@lambda(l){
			acc = concat(acc, l);
		}, ls);
	return acc;
}

/* VS is a list of valintervals.
   return valinterval in which t is defined
   or nil if no such valinterval. */
@define lookval(vs, t)
{
	@local i, m, r, iv;
	m = length(vs);
	for(i = 0; i < m; i++){
		r = vs[i];
		iv = r.interval;
		if(iv.beg <= t && t < iv.end)
			return r;
	}
	return nil;
}

/*
  out: remove the subintervals of intervals or
  valintervals in IVS that are in the intervals in MVS.
*/

@define out(ivs, mvs)
{
	if(length(ivs) == 0)
		return [];
	if(isvalinterval(ivs[0]))
		return flatten(map(@lambda(r){
					map(@lambda(iv){ valinterval(r.val, iv); },
					    maskspan(r.interval, mvs));
				}, ivs));
	else if(isinterval(ivs[0]))
		return flatten(map(@lambda(iv){maskspan(iv, mvs);}, ivs));
	else
		error("invalid intervals argument");
}

@define watchlist(ch)
{
	@local is, exe, os, mvs, gcs, vi;
	exe = ch.exedom;
	is = callintervals(ch, ch.intvl(), &exe`_mklist);
	printf("%d calls to _mklist\n", length(is));
	gcs = gcintervals(ch);
	os = map(@lambda(i){
			@local ctx, rv;
			ctx = ch.ctx(i.end);
			rv = (exe`Val){ch.dom(i.end)}ctx->rax;
			return [rv,i.end];
		}, is);
	foreach(@lambda(o){
			@local p, t, rs, vs, hs, ts, hts, htvs, es;
			p = o[0];
			t = o[1];
			printf("** list created @%d **\n", t);
			printf("location:\n");
			mvs = valfuture(ch, p, t);
			push(mvs, malevent(t, p));
			rs = mkspans(mvs);
			rs = out(rs, gcs);
			foreach(@lambda(r) { printf("%a\n", r); }, rs);

			printf("backing store (l->v):\n");
			vs = [];
			foreach(@lambda(r) {
					@local l, b, e, d, ws, a;
					b = r.interval.beg;
					e = r.interval.end;
					d = ch.dom(b);
					l = (List*){d}r.val;
					a = l->v;
					ws = ch.scan('write, &l->v, sizeof(l->v), b, e);
					foreach(@lambda(w){
							append(vs, valinterval(a, interval(b, w+1)));
							b = w+1;
							d = ch.dom(b);
							l = (List*){d}r.val;
							a = l->v;
						}, ws);
					append(vs, valinterval(a, interval(b, e)));
				}, rs);
			foreach(@lambda(r) { printf("%a\n", r); }, vs);

			printf("list head (l->h):\n");
			hs = [];
			foreach(@lambda(r){
					@local l, b, e, d, ws, h;
					b = r.interval.beg;
					e = r.interval.end;
					vi = lookval(rs, b);
					if(vi == nil)
						error("no list address @%d", b);
					d = ch.dom(b);
					l = (List*){d}vi.val;
					h = l->h;
					ws = ch.scan('write, &l->h, sizeof(l->h), b, e);
					foreach(@lambda(w){
							append(hs, valinterval(h, interval(b, w+1)));
							b = w+1;
							vi = lookval(rs, b);
							if(vi == nil)
								error("no list address @%d", b);
							d = ch.dom(b);
							l = (List*){d}vi.val;
							h = l->h;
						}, ws);
					append(hs, valinterval(h, interval(b, e)));
				}, vs);
			foreach(@lambda(r) { printf("%a\n", r); }, hs);


			printf("list tail (l->t):\n");
			ts = [];
			foreach(@lambda(r){
					@local l, b, e, d, ws, t;
					b = r.interval.beg;
					e = r.interval.end;
					vi = lookval(rs, b);
					if(vi == nil)
						error("no list address @%d", b);
					d = ch.dom(b);
					l = (List*){d}vi.val;
					t = l->t;
					ws = ch.scan('write, &l->t, sizeof(l->t), b, e);
					foreach(@lambda(w){
							append(ts, valinterval(t, interval(b, w+1)));
							b = w+1;
							vi = lookval(rs, b);
							if(vi == nil)
								error("no list address @%d", b);
							d = ch.dom(b);
							l = (List*){d}vi.val;
							t = l->t;
						}, ws);
					append(ts, valinterval(t, interval(b, e)));
				}, vs);
			foreach(@lambda(r) { printf("%a\n", r); }, ts);

			[hs, ts] = shred(hs, ts);

			printf("shreded list head (l->h):\n");
			foreach(@lambda(r) { printf("%a\n", r); }, hs);
			printf("shreded list tail (l->t):\n");
			foreach(@lambda(r) { printf("%a\n", r); }, ts);

			hts = mix(hs, ts, list);
			printf("mixed l->h, l->t:\n");
			foreach(@lambda(r) { printf("%a\n", r); }, hts);

			htvs = flatten(map(@lambda(ht){
						@local l, b, e, d, ws, rv, sa, ea;
						b = ht.interval.beg;
						e = ht.interval.end;
						vi = lookval(rs, b);
						if(vi == nil)
							error("no list address @%d", b);
						d = ch.dom(b);
						l = (List*){d}vi.val;
						sa = (void*)(vecdata(l->v)+l->h);
						ea = (void*)(vecdata(l->v)+l->t);
						ws = ch.scan('write, sa, ea-sa, b, e);
						rv = [];
						foreach(@lambda(w){ append(rv, interval(b, w+1)); b = w+1; }, ws);
						append(rv, interval(b, e));
					}, hts));

			@defloc lt(t)
			{
				@local d, vi;
				vi = lookval(rs, t);
				if(vi == nil)
					error("no list defined @%d", t);
				d = ch.dom(t);
				return (List*){d}vi.val;
			}

			@defloc dumpelements(l)
			{
				@local h, t, v;
				h = l->h;
				t = l->t;
				v = vecdata(l->v);
				while(h < t)
					printf(" %p", v[h++]);
			}

			@defloc elementsat(t)
			{
				@local l, h, v, rv;
				l = lt(t);
				h = l->h;
				t = l->t;
				v = vecdata(l->v);
				rv = [];
				while(h < t)
					append(rv, v[h++]);
				return rv;
			}

			printf("intervals of stable elements:\n");
			es = [];
			es = flatten(map(@lambda(r){
						@local es;
						es = elementsat(r.beg);
						printf("%a (%d elements)\n", r, length(es));
						return map(@lambda(e){valinterval(e, r);}, es);
					}, htvs));
			printf("%d stable elements total\n", length(es));

			@defloc containsinterval(s, t)
			{
				return s.beg <= t.beg && s.end >= t.end;
			}

			if(0)foreach(@lambda(e){
					@local vl, vi;
					printf("calling vallife %a\n", e);
					vl = vallife(ch, e.val, e.interval.beg);
					if(vl == nil){
						printf("no value for element %a\n", e);
						return;
					}
					vi = lookval(vl, e.interval.beg);
					if(vi == nil)
						error("bug");
					if(!containsinterval(vi.interval, e.interval)){
						printf("stable element %a extends beyond stable object %a\n", e, vi);
						return;
					}
					printf("stable element %a is contained in stable object %a\n", e, vi);
				}, es);
		}, os);
}
