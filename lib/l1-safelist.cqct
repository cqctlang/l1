@include <chronicle.cqct>
@include <l1-debug.cqct>
@include <l1-mem.cqct>

@global lists, db;

@define flatten(ls)
{
	@local acc;
	acc = [];
	foreach(@lambda(l){
			acc = concat(acc, l);
		}, ls);
	return acc;
}

@define whine(db, str, iv, ws)
{
	@local stks;
	printf("... %s in interval @%d-@%d\n", str, iv.beg, iv.end);
	if(!ws || length(ws) == 0)
		return;
	stks = uniqstacks(db, ws);
	printf("...... %d unique context%s\n", length(stks),
	       length(stks) > 1 ? "s" : "");
	foreach(@lambda(e){
			printf("...... %d writes occurred here (example @%d)\n",
			       length(e[0]), e[0][0]);
			printf("%s", e[1]);
		}, stks);
}

@define assertunwritten(iv)
{
	@local addr, len, ws;
	printf("... assertunwritten: %a\n", iv);
	[addr, len] = iv.val;
	ws = db.scan('write, addr, len, iv.beg, iv.end);
	if(length(ws) != 0)
		whine(db, "write to stable data", iv, ws);
}

@define assertlive(iv)
{
	@local life;
	printf("... assertlive: %a\n", iv);
	life = vallifetime(db, iv.val, iv.beg);
	if(!containsiv(life, iv))
		whine(db, "reference to stale object", iv, nil);
}

/* A and B are the values of two colliding intervals.
   it would be nice to have the intervals */
@define nocollide(a, b)
{
	error("interval collision");
}

@define mkpicktype(type)
{
	@defloc pick(iv)
	{
		@local i, m;
		m = length(iv.val);
		for(i = 0; i < m; i++)
			if(iv.val[i] && @typeof(iv.val[i]) == type)
				return interval(iv.beg, iv.end, iv.val[i]);
			else if(iv.val[i])
				printf("rejecting idx %d of type %t\n", i, @typeof(iv.val[i]));
		error("no value of type %t", type);
	}
	return pick;
}

@define mkpickn(n)
{
	@defloc pick(iv)
	{
		if(n > length(iv.val))
			error("no value at index %d\n", n);
		return interval(iv.beg, iv.end, iv.val[n]);
	}
	return pick;
}

@define iv2list(iv) { return {db.dom(iv.beg)}iv.val; }
@define hloc(iv) { @local l; l = iv2list(iv); return interval(iv.beg, iv.end, [&l->h, sizeof(l->h)]); }
@define tloc(iv) { @local l; l = iv2list(iv); return interval(iv.beg, iv.end, [&l->t, sizeof(l->t)]); }
@define vloc(iv) { @local l; l = iv2list(iv); return interval(iv.beg, iv.end, [&l->v, sizeof(l->v)]); }
@define metalocs(iv) { [ hloc(iv), tloc(iv), vloc(iv) ]; }

@define dataloc(iv)
{
	@local sa, ea;
	@local l;
	l = iv2list(iv); 
	sa = (void*)(vecdata(l->v)+l->h);
	ea = (void*)(vecdata(l->v)+l->t);
	return interval(iv.beg, iv.end, [sa, ea-sa]);
}

@define listcontents(iv)
{
	@local addr, len, p, ep, rv;
	[addr, len] = iv.val;
	p = (Val*)addr;
	ep = (Val*)(addr+len);
	rv = [];
	while(p < ep)
		append(rv, interval(iv.beg, iv.end, *p++));
	return rv;
}

@define containsloc(iv, addr)
{
	return addr >= iv.val[0] && addr < (void*)iv.val[0]+iv.val[1];
}

@define checklist(livs)
{
	@local dom;

	dom = db.exedom;

	/* exclude time in any function that updates the list */
	@defloc excludeupdates(liv)
	{
		@local x, exclude;

		/* functions to exclude */
		exclude = [
			&dom`_mklist,		// List* _mklist(Imm);
			&dom`listset,		// List* listset(List*, Imm, Val);
			&dom`listpop,		// void  listpop(List*, Val*);
			&dom`listdel,		// List* listdel(VM*, List*, Imm);
			&dom`listins,		// List* listins(VM*, List*, Imm, Val);
			&dom`_listappend,	// void  _listappend(List*, Val);
		];

		x = zunionall(map(@lambda(fn){ callrets(db, liv, fn); }, exclude), nocollide);
		x = map(mkpicktype(@typeof(dom`List*)), x);
		x = filter(@lambda(iv){ iv.val == liv.val; }, x);
		return zout([liv], x);
	}

	/* exclude swaps to elements of the list */
	@defloc excludeswap(liv)
	{
		@local x;
		x = callrets(db, liv, &dom`doswap);
		x = map(mkpickn(1), x);
		x = filter(@lambda(iv){ containsloc(dataloc(liv), iv.val); }, x);
		return zout([liv], x);
	}

	/* check one list interval.
	   assume location of list descriptor is constant within LIV.
	   assume location of storage and # of elements may change within LIV. */
	@defloc checkliv(liv)
	{
		@local stable;

		stable = excludeupdates(liv);

		/* verify that metadata variables (h, t, v) are not updated */
		foreach(@lambda(iv){ foreach(assertunwritten, metalocs(iv)); }, stable);
				
		/* verify that storage is not updated */
		stable = flatten(map(excludeswap, stable));
		foreach(@lambda(iv){ assertunwritten(dataloc(iv)); }, stable);

		/* verify that each element is live */
		foreach(@lambda(iv){ foreach(assertlive, listcontents(dataloc(iv))); }, stable);
	}

	printf("checking list allocated @%d\n", livs[0].beg);
	livs = zout(livs, callrets(db, db.interval(), &dom`_gc));

	foreach(checkliv, livs);
}

@define l1db(file)
{
	@local dom, n;

	printf("'db':\n");
	db = chronicledb(file);
	printf("\n");

	dom = db.exedom;

	n = 0;
	lists = returns(db, db.interval(), &dom`_mklist);
	printf("'lists': %d lists allocated\n", length(lists));
	lists = map(@lambda(lit){
			@local livs;
			livs = vallifetime(db, lit.val, lit.t);
			printf("\t#%-3d %a\n", n++, livs);
			return livs;
		    }, lists);

	return nil;
}
