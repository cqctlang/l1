@include <chronicle.cqct>
@include <l1-debug.cqct>
@include <l1-mem.cqct>

@global lists, db;

@define anycalls(db, fns)
{
	ivsequnionall(map(@lambda(fn){ callintervals(db, db.interval(), fn); }, fns), nil);
}

@define dumpreport(db, iv, addr, len, ws)
{
	@local stks;
	printf("... %d unexpected writes in interval @%d-@%d\n",
	       length(ws), iv.beg, iv.end);
	printf("...... object %p (%t), range %p-%p\n",
	       iv.val, iv.val, addr, (void*)addr+len);
	stks = uniqstacks(db, ws);
	printf("...... %d unique context%s\n", length(stks),
	       length(stks) > 1 ? "s" : "");
	foreach(@lambda(e){
			printf("...... %d writes occurred here (example @%d)\n",
			       length(e[0]), e[0][0]);
			printf("%s", e[1]);
		}, stks);
}

@define assertunwritten(db, iv, locs)
{
	@local addr, len, ws;
	printf("assertunwritten %a %a\n", iv, locs);
	foreach(@lambda(loc){
			[addr, len] = loc;
			ws = db.scan('write, addr, len, iv.beg, iv.end);
			if(length(ws) != 0)
				dumpreport(db, iv, addr, len, ws);
		}, locs);
}

/* A and B are the values of two colliding intervals.
   it would be nice to have the intervals */
@define nocollide(a, b)
{
	error("interval collision");
}

@define checklist2(lit)
{
	@local dom, livs, exclude;

	printf("checking list allocated @%d\n", lit.t);
	dom = db.exedom;
	exclude = [
//		&dom`_gc,
//		&dom`_mklist,
		&dom`listset,
		&dom`listpop,
//		&dom`listexpand,
		&dom`listdel,
		&dom`listins,
		&dom`_listappend,
//		&dom`dosort
	];

	livs = vallifetime(db, lit.val, lit.t);
	livs = ivseqout(livs, callrets(db, db.interval(), &dom`_gc));
	livs = ivseqout(livs, callrets(db, db.interval(), &dom`_mklist));

	@defloc iv2list(iv) { return {db.dom(iv.beg)}iv.val; }

	@defloc mkpickval(type)
	{
		@defloc picklistval(iv)
		{
			@local i, m;
			m = length(iv.val);
			for(i = 0; i < m; i++)
				if(iv.val[i] && @typeof(iv.val[i]) == type)
					return interval(iv.beg, iv.end, iv.val[i]);
			error("no value of type %t", type);
		}
		return picklistval;
	}

	@defloc hloc(l) { return [&l->h, sizeof(l->h)]; }
	@defloc tloc(l) { return [&l->t, sizeof(l->t)]; }
	@defloc vloc(l) { return [&l->v, sizeof(l->v)]; }
	@defloc eloc(l)
	{
		@local sa, ea;
		sa = (void*)(vecdata(l->v)+l->h);
		ea = (void*)(vecdata(l->v)+l->t);
		return [sa, ea-sa];
	}

	foreach(@lambda(liv){
			@local xivs, descs, fixeds;
			
			xivs = ivsequnionall(map(@lambda(fn){ callrets(db, liv, fn); }, exclude), nocollide);
			xivs = map(mkpickval(@typeof(dom`List*)), xivs);
			xivs = filter(@lambda(iv){ iv.val == liv.val; }, xivs);

			fixeds = ivseqout([liv], xivs);
			descs = [ hloc(liv.val), tloc(liv.val), vloc(liv.val) ];

			/* descriptor variables should be unchanged during fixed intervals */
			foreach(@lambda(fixed){ assertunwritten(db, fixed, descs); }, fixeds);
				
			/* backing storage should be unchanged during fixed intervals */
			foreach(@lambda(fixed){ assertunwritten(db, fixed, [ eloc(iv2list(fixed)) ]); }, fixeds);
		}, livs);
}

@define checklist(lit)
{
	@local dom, livs, exclude, xivs;

	printf("checking list allocated @%d\n", lit.t);

	dom = db.exedom;
	exclude = [
		&dom`_gc,
		&dom`_mklist,
		&dom`listset,
		&dom`listpop,
		&dom`listexpand,
		&dom`listdel,
		&dom`listins,
		&dom`_listappend,
		&dom`dosort
	];
	
	livs = vallifetime(db, lit.val, lit.t);
	xivs = anycalls(db, exclude);
	livs = ivseqout(livs, xivs);

	@defloc liv2list(iv) { return {db.dom(iv.beg)}iv.val; }

	@defloc hrange(l) { return [&l->h, sizeof(l->h)]; }
	@defloc trange(l) { return [&l->t, sizeof(l->t)]; }
	@defloc vrange(l) { return [&l->v, sizeof(l->v)]; }
	@defloc erange(l)
	{
		@local sa, ea;
		sa = (void*)(vecdata(l->v)+l->h);
		ea = (void*)(vecdata(l->v)+l->t);
		return [sa, ea-sa];
	}

	@defloc assertconfig(iv)
	{
		@local l;
		l = liv2list(iv);
		assertunwritten(db, iv, hrange(l));
		assertunwritten(db, iv, trange(l));
		assertunwritten(db, iv, vrange(l));
		assertunwritten(db, iv, erange(l));
	}

	@defloc listcontents(iv)
	{
		@local l, addr, len, p, ep, rv;
		l = liv2list(iv);
		[addr, len] = erange(l);
		p = (Val*)addr;
		ep = (Val*)(addr+len);
		rv = [];
		while(p < ep)
			append(rv, interval(iv.beg, iv.end, *p++));
		return rv;
	}

	@defloc assertlive(iv)
	{
		printf("...... assertlive: %a\n", iv);
		if(!ivseqlook(vallifetime(db, iv.val, iv.beg), iv))
			printf("... object %p is stale in interval @%d-@%d\n",
			       iv.val, iv.beg, iv.end);
	}

	printf("... verifying %d subintervals are invariant\n", length(livs));
	foreach(assertconfig, livs);

	printf("... verifying %d subintervals have live contents\n", length(livs));
	foreach(@lambda(iv){ foreach(assertlive, listcontents(iv)); }, livs);

	printf("\n");
}

@define safelist(db)
{
	@local dom, lists;

	dom = db.exedom;
	lists = returns(db, db.interval(), &dom`_mklist);

	foreach(@lambda(it){
			printf("list %p allocated @%d\n", it.val, it.time);
			checklist(db, it);
		}, lists);
}

@define l1db(file)
{
	@local dom, n;
	printf("'db':\n");
	db = chronicledb(file);
	printf("\n");
	dom = db.exedom;
	lists = returns(db, db.interval(), &dom`_mklist);
	printf("'lists': %d lists allocated\n", length(lists));
	n = 0;
	foreach(@lambda(it){ printf("\t#%-3d %a\n", n++, it); }, lists);
	printf("\n");
}
