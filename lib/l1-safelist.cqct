@include <chronicle.cqct>
@include <l1-debug.cqct>
@include <l1-mem.cqct>

@define anycalls(db, fns)
{
	ivsequnionall(map(@lambda(fn){ callintervals(db, db.interval(), fn); }, fns), nil);
}

@define assertunwritten(db, what, iv, f)
{
	@local addr, len, ws;

	[addr, len] = f(iv);
	ws = db.scan('write, addr, len, iv.beg, iv.end);
	if(length(ws) != 0)
		error("found %a %a writes: %a", length(ws), what, ws);
}

@define checklist(db, addr, t)
{
	@local dom, livs, exclude, xivs;

	dom = db.exedom;
	exclude = [
		&dom`_gc,
		&dom`_mklist,
		&dom`listset,
		&dom`listpop,
		&dom`listexpand,
		&dom`listdel,
		&dom`listins,
		&dom`_listappend,
		&dom`dosort
	];
	
	livs = vallifetime(db, addr, t);
	xivs = anycalls(db, exclude);
	livs = ivseqout(livs, xivs);

	@defloc hrange(iv) { @local l; l = {db.dom(iv.beg)}iv.val; return [&l->h, sizeof(l->h)]; }
	@defloc trange(iv) { @local l; l = {db.dom(iv.beg)}iv.val; return [&l->t, sizeof(l->t)]; }
	@defloc vrange(iv) { @local l; l = {db.dom(iv.beg)}iv.val; return [&l->v, sizeof(l->v)]; }

	@defloc erange(iv)
	{
		@local l, sa, ea;
		l = {db.dom(iv.beg)}iv.val;
		sa = (void*)(vecdata(l->v)+l->h);
		ea = (void*)(vecdata(l->v)+l->t);
		return [sa, ea-sa];
	}

	@defloc assertconfig(iv)
	{
		assertunwritten(db, 'h, iv, hrange);
		assertunwritten(db, 't, iv, trange);
		assertunwritten(db, 'v, iv, vrange);
		assertunwritten(db, 'e, iv, erange);
	}

	foreach(assertconfig, livs);
}

@define safelist(db)
{
	@local dom, lists;

	dom = db.exedom;
	lists = returns(db, db.interval(), &dom`_mklist);

	foreach(@lambda(it){
			@local addr, time;
			addr = it.val;
			time = it.t;
			printf("list %p allocated @%d\n", addr, time);
			checklist(db, addr, time);
		}, lists);
}
