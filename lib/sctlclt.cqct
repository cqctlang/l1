@include <sctl.cqct>
@include <nsutil.cqct>

@define mksctlns(fd, nsid)
{
	@local type, sym, addr, undef;
	@local ltresolve, ns;
		
	@defloc resetltr()
	{
		ltresolve = mktnresolve(type, undef,
					@lambda(tn){
						sctllooktype(fd,
							     nsid, ns, tn);
					});
	}

	type = [:];
	sym = [:];
	addr = [:];
	undef = [:];
	resetltr();

	@defloc lt(this, tn)
	{
		@local t;
		t = ltresolve(tn);
		if(isundeftype(t))
			return nil;
		return t;
	}

	@defloc et(this)
	{
		@local resolve, ts;

		// FIXME: maybe only muxenumtype if we haven't before

		/* reset cache */
		type = [:];
		undef = [:];
		resetltr();

		ts = sctlenumtype(fd, nsid, ns);
		resolve = mktnresolve(type, undef,
				      @lambda(tn){
					      return ts[typename(tn)];
				      });
		foreach(@lambda(k, v){
				resolve(k);
			}, ts);
		if(0 && length(undef) > 0){
			printf("%d unresolved\n", length(undef));
			foreach(@lambda(k, v){
					printf("\t%t\n", k);
				}, undef);
		}
		return type;
	}

	@defloc psym2sym(psym)
	{
		@local at, v, t;
			
		if(psym.flags&sctl`Sundef)
			return nil;
		if(psym.flags&sctl`Sinline)
			return nil;
		t = ltresolve(psym.type);
		v = psym.val;
		if(psym.flags&sctl`Senum)
			v = {subtype(t)}v;
		at = psym.attrs;
		at["offset"] = v;
		return mksym(t, psym.id, at);
	}
		
	@defloc ls(this, name)
	{
		@local psym, s;
		s = sym[name];
		if(s != nil)
			return s;
		psym = sctllooksym(fd, nsid, name);
		if(psym == nil)
			return nil;
		s = psym2sym(psym);
		if(s != nil){
			sym[symid(s)] = s;
			addr[symoff(s)] = s;
		}
		return s;
	}

	@defloc es(this)
	{
		@local ss, s;

		/* reset cache */
		sym = [:];

		ss = sctlenumsym(fd, nsid);
		foreach(@lambda(psym){
				s = psym2sym(psym);
				if(s != nil)
					sym[psym.id] = s;
			}, ss);
		return sym;
	}

	@defloc la(this, a)
	{
		@local psym, s;
		s = addr[a];
		if(s != nil)
			return s;
		psym = sctllookaddr(fd, nsid, a);
		if(psym == nil)
			return nil;
		s = psym2sym(psym);
		if(s != nil)
			addr[a] = s;
		return s;
	}

	@defloc uw1(this, ctx)
	{
		return sctlunwind1(fd, nsid, ctx);
	}

	@defloc el(this, ctx)
	{
		return sctlenumloc(fd, nsid, ctx);
	}

	ns = mkns([ "looktype" : lt,
		    "enumtype" : et,
		    "looksym"  : ls,
		    "enumsym"  : es,
		    "lookaddr" : la,
		    "unwind1"  : uw1,
		    "enumloc"  : el,
		  ]);
	return ns;
}

@define atnames(path, rest ...)
{
	@local fds, fd, nsid, base, nso, ns;
	fds = popen("sctl", "-c", 2|4|8);
	fd = fds[0];
	finalize(fd, @lambda(fd) { close(fd); });
	sctlversion(fd);
	nsid = sctlnames(fd, path);
	if(nsid == nil)
		return nil;
	ns = mksctlns(fd, nsid);
	if(length(rest) == 0)
		return ns;
	base = rest[0];
	if(!iscvalue(base))
		error("invalid base address");

	@defloc cop(p)
	{
		return {@typeof(p)}getbytes(p);
	}

	@defloc uw1(this, ctx)
	{
		ctx = cop(ctx);
		ctx->rip -= base;
		return ns.unwind1(ctx);
	}

	@defloc el(this, ctx)
	{
		ctx = cop(ctx);
		ctx->rip -= base;
		return ns.enumloc(ctx);
	}

	nso = mknsoff(ns, base);
	return mkns([
		    "looksym"  : @lambda(this, s) { nso.looksym(s); },
		    "enumsym"  : @lambda(this)    { nso.enumsym(); },
		    "lookaddr" : @lambda(this, a) { nso.lookaddr(a); },
		    "looktype" : @lambda(this, t) { nso.looktype(t); },
		    "enumtype" : @lambda(this)    { nso.enumtype(); },
		    "unwind1"  : uw1,
		    "enumloc"  : el,
		    ]);
}
