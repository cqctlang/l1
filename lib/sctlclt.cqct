@include <sctl.cqct>
@include <nsutil.cqct>

@define mksctlns(fd, nsid)
{
	@local type, sym, addr, undef;
	@local ltresolve, ns;
		
	@defloc resetltr()
	{
		ltresolve = mktnresolve(type, undef,
					@lambda(tn){
						sctllooktype(fd,
							     nsid, ns, tn);
					});
	}

	type = [:];
	sym = [:];
	addr = [:];
	undef = [:];
	resetltr();

	@defloc lt(this, tn)
	{
		@local t;
		t = ltresolve(tn);
		if(isundeftype(t))
			return nil;
		return t;
	}

	@defloc et(this)
	{
		@local resolve, ts;

		// FIXME: maybe only muxenumtype if we haven't before

		/* reset cache */
		type = [:];
		undef = [:];
		resetltr();

		ts = sctlenumtype(fd, nsid, ns);
		resolve = mktnresolve(type, undef,
				      @lambda(tn){
					      return ts[typename(tn)];
				      });
		foreach(@lambda(k, v){
				resolve(k);
			}, ts);
		if(0 && length(undef) > 0){
			printf("%d unresolved\n", length(undef));
			foreach(@lambda(k, v){
					printf("\t%t\n", k);
				}, undef);
		}
		return type;
	}

	/*
	  resolve complete type for psym;
	  recast its value if enum constant;
	  reject symbols that don't appear in name spaces.
	*/
	@defloc psym2sym(psym)
	{
		@local at, t, f;
			
		at = symattr(psym);
		f = at["flags"];
		if(f){
			if(f&sctl`Sundef)
				return nil;
			if(f&sctl`Sinline)
				return nil;
		}
		t = ltresolve(symtype(psym));
		if(f && f&sctl`Senum)
			at["offset"] = {subtype(t)}at["offset"];
		return mksym(t, symid(psym), at);
	}
		
	@defloc ls(this, name)
	{
		@local psym, s;
		s = sym[name];
		if(s != nil)
			return s;
		psym = sctllooksym(fd, nsid, name);
		if(psym == nil)
			return nil;
		s = psym2sym(psym);
		if(s != nil){
			sym[symid(s)] = s;
			addr[symoff(s)] = s;
		}
		return s;
	}

	@defloc es(this)
	{
		@local ss, s;

		/* reset cache */
		sym = [:];

		ss = sctlenumsym(fd, nsid);
		foreach(@lambda(psym){
				s = psym2sym(psym);
				if(s != nil)
					sym[psym.id] = s;
			}, ss);
		return sym;
	}

	@defloc la(this, a)
	{
		@local psym, s;
		s = addr[a];
		if(s != nil)
			return s;
		psym = sctllookaddr(fd, nsid, a);
		if(psym == nil)
			return nil;
		s = psym2sym(psym);
		if(s != nil)
			addr[a] = s;
		return s;
	}

	@defloc uw1(this, pc)
	{
		return sctlunwind1(fd, nsid, pc);
	}

	@defloc el(this, ctx)
	{
		return sctlenumloc(fd, nsid, ctx);
	}

	@defloc lsrc(this, addr)
	{
		return sctllooksrc(fd, nsid, addr);
	}

	@defloc lpc(this, file, line)
	{
		return sctllookpc(fd, nsid, file, line);
	}

	ns = mkns([ "looktype" : lt,
		    "enumtype" : et,
		    "looksym"  : ls,
		    "enumsym"  : es,
		    "lookaddr" : la,
		    "unwind1"  : uw1,
		    "enumloc"  : el,
		    "looksrc"  : lsrc,
		    "lookpc"   : lpc,
		  ]);
	return ns;
}

@define atnames(path)
{
	@local fds, fd, nsid;
	fds = popen("sctl", "-c", 2|4|8);
	fd = fds[0];
	finalize(fd, @lambda(fd) { close(fd); });
	sctlversion(fd);
	nsid = sctlnames(fd, path);
	if(nsid == nil)
		return nil;
	return mksctlns(fd, nsid);
}
