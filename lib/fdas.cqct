// on input streams, it is easy to not read all pending input on the
// stream, for example by having a pointer to a struct for the last
// message and not accessing the last byte in the message.  in this
// case, when the stream closes, the other side sees RST instead of
// FIN.

// might be nice to have a way to advance leading portion of window
// without accessing bytes, so that maps knows it is there.
// would replace ifetch mechanism in pras.l1

@define mkindispatch(fd, eofk){
	@local buf, lo, hi, peek, off, max, grow, dispatch;
	lo = 0;
	hi = 0;
	peek = 0;
	off = 0;
	eof = 0;
	max = 1024*1024;
	buf = mkstr(max);

	@define grow(beg, oldlen){
		@local nbuf;
		max = 2*(beg+oldlen);
		nbuf = mkstr(max);
		strput(nbuf, 0, buf);
		buf = nbuf;
	}

	@define dispatch(args ...) {
		@local method, r, s, beg, len, need;
		method = listref(args, 1);
		if(method == "get"){
			r = listref(args, 2);
			beg = rangebeg(r);
			len = rangelen(r);
			if(beg < off)
				fault();
			beg -= off;
			if(beg+len > peek){
				if(beg+len > max)
					grow(beg, len);
				need = beg+len-peek;
				s = read(fd, need);
				if(s == @nil || strlen(s) < need){
					eof = 1;
					if(eofk != @nil)
						eofk(@nil);
					error("end of file on fdas");
				}
				strput(buf, peek, s);
				hi += need;
				peek += need;
			}
			s = substr(buf, beg, beg+len);
			return s;
		}else if(method == "map"){
			return vector(mkrange(off, hi));
		}else if(method == "put"){
			error("attempt to write to input stream");
		}else if(method == "flush"){
			if(hi < peek){
				s = substr(buf, hi, peek);
//				buf = mkstr(max);
				strput(buf, 0, s);
				peek = peek-hi;
			}else{
//				buf = mkstr(max);
				peek = 0;
			}
			off += hi;
			hi = 0;
			return @nil;
		}else if(method == "seteofk"){
			eofk = listref(args, 2);
			return @nil;
		}else if(method == "iseof"){
			if(eof)
				return 1;
			if(hi < peek)
				return 0;
			if(hi+1 > max)
				grow(beg, len);
			s = read(fd, 1);
			if(s == @nil){
				eof = 1;
				return 1;
			}
			strput(buf, hi, s);
			peek = hi+1;
			return 0;
		}else
			error("bad command to fdas: %a", method);
	}
	return dispatch;
}

@define mkoutdispatch(fd, eofk){
	@local buf, lo, hi, off, max, dispatch;
	lo = 0;
	hi = 0;
	off = 0;
	max = 1024*1024;
	buf = mkstr(max);
	@define dispatch(args ...) {
		@local method, r, s, beg, len, need;
		method = listref(args, 1);
		if(method == "get"){
			r = listref(args, 2);
			beg = rangebeg(r);
			len = rangelen(r);
			if(beg < off)
				fault();
			beg -= off;
			if(beg+len > hi)
				fault();
			s = substr(buf, beg, beg+len);
			return s;
		}else if(method == "map"){
			return range(off, off+hi);
		}else if(method == "put"){
			r = listref(args, 2);
			s = listref(args, 3);
			beg = rangebeg(r);
			len = rangelen(r);
			if(beg < off)
				fault();
			beg -= off;
			if(beg+len > max){
				@local nbuf;
				max = 2*(beg+len);
				nbuf = mkstr(max);
				strput(nbuf, 0, buf);
				buf = nbuf;
			}
			strput(buf, beg, s);
			if(beg+len > hi)
				hi = beg+len;
		}else if(method == "flush"){
			write(fd, substr(buf, 0, hi));
			memset(buf, 0, hi);
//			buf = mkstr(max);
			off += hi;
			hi = 0;
			return @nil;
		}else if(method == "seteofk"){
			eofk = listref(args, 2);
			return @nil;
		}else
			error("bad command to fdas: %a", method);
	}
	return dispatch;
}

@define mkfdas(fd, eofk){
	return [ mkas([ "dispatch" : mkindispatch(fd, eofk) ]),
		 mkas([ "dispatch" : mkoutdispatch(fd, eofk) ]) ];
}
