define chase(p, fn)
{
	printf("chase: %a\n", typeof(p));
	if(p && chaseable(typeof(p)))
		work([p], fn);
}

define chasetype(t)
{
	printf("%a\n", t);
	if(istypedef(t))
		return chasetype(typedeftype(t));
	return t;
}

define chaseable(t)
{
	printf("chaseable: %a\n", t);
	t = chasetype(t);
	if(!isptr(t))
		return 0;
	if(!issu(chasetype(subtype(t))))
		return 0;
	return 1;
}

define work(wk, fn)
{
	@local x, y, m, ls, i, seen;
	seen = mktab();
	while(length(wk) > 0){
		x = pop(wk);
		ls = links(x);
		seen[x] = 1;
		fn(x, ls);
		m = length(ls);
		for(i = 0; i < m; i++){
			y = pop(ls);
			if(y && !seen[y] && chaseable(typeof(y)))
				append(wk, y);
		}
	}
}

define links(p)
{
	@local t, fs, f, ft, m, i, ls;
	t = chasetype(subtype(chasetype(typeof(p))));
	if(!issu(t))
		error("chased wrong type: %t", t);
	fs = fields(t);
	m = length(fs);
	ls = [];
	p = (void*)p;
	for(i = 0; i < m; i++){
		f = fs[i];
		ft = chasetype(fieldtype(f));
		if(chaseable(ft))
			append(ls, {ft}*(`uintptr*)(p+fieldoff(f)));
		else if(issu(ft))
			ls = concat(ls,
				    links({mkctype_ptr(ft)}(p+fieldoff(f))));
		else if(isarray(ft))
			printf("implement array support\n");
	}
	return ls;
}

define testchase()
{
	@local ns, as, dom, p, q, i;
	ns = @names c32le {
		struct X {
			@0x00 struct X *x1;
			@0x10 struct Y y;
			@0x20;
		};
		struct Y {
			@0x00 struct X *x2;
			@0x10;
		};
		@0x0 struct X root;
	};
	as = mkzas(1024);
	dom = mkdom(ns, as);
	q = p = (struct X*){dom}0;
	for(i = 0; i < 10; i++){
		p->x1 = p+1;
		p->y.x2 = p+2;
		p++;
	}
	chase(q+1, lambda(p) { printf("%t %p\n", p, p); });
	return nil;
}
