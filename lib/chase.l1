define chase(p, fn)
{
	if(p && chaseable(typeof(p)))
		work([p], fn);
}

define chasetype(t)
{
	if(istypedef(t))
		return chasetype(typedeftype(t));
	return t;
}

define chaseable(t)
{
	t = chasetype(t);
	if(!isptr(t))
		return 0;
	if(!issu(chasetype(subtype(t))))
		return 0;
	return 1;
}

define work(wk, fn)
{
	@local x, y, m, ls, i, seen;
	seen = mktab();
	while(length(wk) > 0){
		x = pop(wk);
		if(seen[x] != nil)
			continue;
		ls = links(x);
		seen[x] = 1;
		fn(x, ls);
		m = length(ls);
		for(i = 0; i < m; i++){
			y = pop(ls);
			if(y && chaseable(typeof(y)))
				append(wk, y);
		}
	}
}

define links(p)
{
	@local t, fs, f, ft, pft, m, n, q, i, j, ls;
	t = chasetype(subtype(chasetype(typeof(p))));
	if(!issu(t))
		error("chased wrong type: %t", t);
	fs = fields(t);
	m = length(fs);
	ls = [];
	p = (void*)p;
	for(i = 0; i < m; i++){
		f = fs[i];
		ft = chasetype(fieldtype(f));
		if(chaseable(ft))
			append(ls, {ft}*(`uintptr*)(p+fieldoff(f)));
		else if(issu(ft))
			ls = concat(ls,
				    links({mkctype_ptr(ft)}(p+fieldoff(f))));
		else if(isarray(ft)){
			n = arraynelm(ft);
			if(n == nil)
				continue;
			ft = chasetype(subtype(ft));
			pft = mkctype_ptr(ft);
			q = p+fieldoff(f);
			for(j = 0; j < n; j++){
				ls = concat(ls, links({pft}q));
				q += sizeof(ft);
			}
		}
	}
	return ls;
}

define fmtnode(p)
{
	return sprintfa("(%t)0x%p", p, p);
}

define testchase()
{
	@local ns, as, dom, p, q, i, j;
	ns = @names c32le {
		struct X {
			@0x00 struct X *x1;
			@0x10 struct Y y;
			@0x20 struct X *x[10];
			@0x100;
		};
		struct Y {
			@0x00 struct X *x2;
			@0x10;
		};
		@0x0 struct X root;
	};
	as = mkzas(10240);
	dom = mkdom(ns, as);
	q = p = (struct X*){dom}0;
	for(i = 0; i < 10; i++){
		p->x1 = p+1;
		p->y.x2 = p+2;
		for(j = 0; j < 9; j++)
			p->x[j] = &q[j];
		p++;
	}
	chase(q+1, lambda(p, ls){
			printf("%s: ", fmtnode(p));
			foreach(lambda(p) { printf("%s ", fmtnode(p)); }, ls);
			printf("\n");
		});
	return nil;
}
