@global
	ivseqshred,
	ivseqout,
	ivseqjoin,
	ivseqlook,
	ivseqsplit
;

rdsetfmt(@record instant { t, val },
	 @lambda(r) { sprintfa("@%d%s", r.t,
			       r.val == nil ? "" :
			       sprintfa(" %a", r.val)); });
rdsetfmt(@record interval { beg, end, val },
	 @lambda(r) { sprintfa("<@%d - @d%s>", r.beg, r.end,
			       r.val == nil ? "" :
			       isprocedure(r.val) ? " *" :
			       sprintfa(" %a", r.val)); });

{

/* split interval sequence into two sequences, before and after.
   before contains intervals before T (i.e., that end no later than T).
   after contains intervals at or after T.
   if T occurs within an interval [B,E,V],
   it is split into [B,T,V] (which goes into before)
   and [T,E,V] (which goes into after).
*/
@define ivseqsplit(ivs, t)
{
	@local before, after;

	before = [];
	after = [];

	@defloc loop(ivs)
	{
		@local iv;
		if(length(ivs) == 0)
			return [before, after];
		iv = ivs[0];
		if(iv.beg >= t)
			return [before, concat(after, ivs)];
		else if(iv.end <= t){
			append(before, iv);
			pop(ivs);
			return loop(ivs);
		}else{
			pop(ivs);
			append(before, interval(iv.beg, t, iv.val));
			push(ivs, interval(t, iv.end, iv.val));
			return loop(ivs);
		}
	}
	return loop(ivs);
}

@define ivseqlook(ivs, t)
{
	@local i, iv, m;
	m = length(ivs);
	for(i = 0; i < m; i++){
		iv = ivs[i];
		if(t < iv.beg)
			continue;
		if(t >= iv.beg && t < iv.end)
			return iv;
		if(t >= iv.end)
			continue;
	}
	return nil;
}

/* AVS and BVS are ivseqs.
   subdivide each so that no interval in AVS overlaps with
   one in BVS and vice-versa. */
@define ivseqshred(avs, bvs)
{
	@defloc loop(avs, bvs, navs, nbvs, cnt)
	{
		@local av, bv;
		@local ab, ae, bb, be;
		if(length(avs) == 0)
			return [navs, concat(nbvs, bvs)];
		else if(length(bvs) == 0)
			return [concat(navs, avs), nbvs];
		else{
			av = avs[0];
			bv = bvs[0];
			ab = av.beg;
			ae = av.end;
			bb = bv.beg;
			be = bv.end;

			if(ae <= bb){
				append(navs, pop(avs));
				loop(avs, bvs, navs, nbvs, cnt);
			}else if(ab < bb && ae <= be){
				pop(avs);
				pop(bvs);
				append(navs, interval(ab, bb, av.val));
				append(navs, interval(bb, ae, av.val));
				append(nbvs, interval(bb, ae, bv.val));
				if(ae < be)
					push(bvs, interval(ae, be, bv.val));
				loop(avs, bvs, navs, nbvs, cnt);
			}else if(ab <= bb && ae <= be){
				if(ab == bb && ae == be){
					append(navs, pop(avs));
					append(nbvs, pop(bvs));
					loop(avs, bvs, navs, nbvs, cnt);
				}else if(ab == bb && ae < be){
					pop(bvs);
					append(navs, pop(avs));
					append(nbvs, interval(bb, ae, bv.val));
					push(bvs, interval(ae, be, bv.val)); 
					loop(avs, bvs, navs, nbvs, cnt);
				}else if(ab > bb && ae <= be){
					pop(avs);
					pop(bvs);
					append(nbvs, interval(bb, ab, bv.val));
					append(navs, interval(ab, ae, av.val));
					if(ae < be)
						push(bvs, interval(ae, be, bv.val));
					loop(avs, bvs, navs, nbvs, cnt);
				}else
					error("confusion");
			}else{
				/* the remaining cases have symmetry with the above cases */
				[nbvs, navs] = loop(bvs, avs, nbvs, navs, cnt+1);
				return [navs, nbvs];
			}
		}
	}
	return loop(copy(avs), copy(bvs), [], [], 0);
}

}

//	/* assume is is contained in iv */
//	@define invert(is, iv)
//	{
//		@local rv, b, e;
//		b = iv.beg;
//		e = iv.end;
//		rv = [];
//		foreach(@lambda(i){
//				if(i.beg < b)
//					error("bug");
//				if(i.end > e)
//					error("bug");
//				if(i.beg == b)
//					b = i.end;
//				else{
//					append(rv, interval(b, i.beg));
//					b = i.end;
//				}
//			}, is);
//		if(b < e)
//			append(rv, interval(b, e));
//		return rv;
//	}
//
//	@define clip(is, iv)
//	{
//		@local rv, b, e;
//		b = iv.beg;
//		e = iv.end;
//		rv = [];
//		foreach(@lambda(i){
//				/* draw a picture; there are six cases */
//				if(i.end <= b)
//					return;
//				if(i.beg >= e)
//					return;
//				if(i.beg >= b && i.end <= e)
//					append(rv, i);
//				else if(i.beg <= b && i.end >= e)
//					append(rv, interval(b, e));
//				else if(i.beg <= b && i.end < e)
//					append(rv, interval(b, i.end));
//				else if(i.beg < e && i.end >= e)
//					append(rv, interval(i.beg, e));
//				else
//					error("confusion");
//			}, is);
//		return rv;
//	}
//
//	@define clipend(is, t)
//	{
//		@local rv;
//		rv = [];
//		foreach(@lambda(i){
//				if(i.beg > t)
//					return;
//				else if(i.end >= t)
//					append(rv, interval(i.beg, t));
//				else
//					append(rv, i);
//			}, is);
//		return rv;
//	}
//
//	@define clipbeg(is, t)
//	{
//		@local rv;
//		rv = [];
//		foreach(@lambda(i){
//				if(i.end <= t)
//					return;
//				if(i.beg < t)
//					append(rv, interval(t, i.end));
//				else
//					append(rv, i);
//			}, is);
//		return rv;
//	}
//
//	@define indexof(is, t)
//	{
//		@defloc loop(is, n)
//		{
//			@local iv;
//			if(length(is) == 0)
//				return nil;
//			iv = pop(is);
//			if(t >= iv.beg && t < iv.end)
//				return n;
//			loop(is, n+1);
//		}
//		loop(copy(is), 0);
//	}
//
//	@define lookinterval(is, t)
//	{
//		@local i, iv, m;
//		m = length(is);
//		for(i = 0; i < m; i++){
//			iv = is[i];
//			if(t < iv.beg)
//				continue;
//			if(t >= iv.beg && t < iv.end)
//				return iv;
//			if(t >= iv.end)
//				continue;
//		}
//		return nil;
//	}
//
//	/* this function assumes the intervals are disjoint */
//	@define mergeivs(as, bs)
//	{
//		@local rv, a, b;
//	
//		as = copy(as);
//		bs = copy(bs);
//		rv = [];
//		a = pop(as);
//		b = pop(bs);
//		while(a && b){
//			if(a.beg < b.beg){
//				append(rv, a);
//				a = pop(as);
//			}else{
//				append(rv, b);
//				b = pop(bs);
//			}
//		}
//		while(a){
//			append(rv, a);
//			a = pop(as);
//		}
//		while(b){
//			append(rv, b);
//			b = pop(bs);
//		}
//		return rv;
//	}
//
