@define printtype(t){
	@local ct, i, fld, flds, sz, off;

	if(issu(t)){
		printf("%s %s {\n", suekind(t), suetag(t));
		flds = fields(t);
		for(i = 0; i < veclen(flds); i++){
			fld = vecref(flds, i);
			off = fieldoff(fld);
			ft = fieldtype(fld);
			id = fieldid(fld);
			if(isnil(off)){
				printf("\t");
				printf("\t%t;\n", fld);
			}else if(isbitfield(ft)){
				printf("\t@@(8*0x%x+%x)",
				       off, bitfieldpos(ft));
				printf("\t%t %s : %d\n",
				       bitfieldcontainer(ft), id,
				       bitfieldwidth(ft));
			}else{
				printf("\t@0x%x", off);
				printf("\t%t;\n", fld);
			}
		}
		sz = susize(t);
		if(!isnil(sz))
			printf("\t@0x%x;\n", sz);
		printf("};\n");
	}else if(istypedef(t))
		printf("typedef %t %s;\n", typedeftype(t), typedefid(t));
	else if(isenum(t)){
		printf("%s %s {\n", suekind(t), suetag(t));
		ens = enumconsts(t);
		for(i = 0; i < veclen(ens); i++){
			en = vecref(ens, i);
			printf("\t%s = %d,\n", vecref(en, 0), vecref(en, 1));
		}
		printf("};\n");
	}
};

@define dumpns(dn){
	@local ns, fn;
	if(isdom(dn))
		ns = dn.ns;
	else
		ns = dn;
	
	fn = nsenumtype(ns);
	vec = tabvals(fn(ns));
	for(i = 0; i < veclen(vec); i++)
		printtype(vecref(vec, i));

	fn = nsenumsym(ns);
	vec = tabvals(fn(ns));
	for(i = 0; i < veclen(vec); i++)
		printf("%t;\n", vecref(vec, i));
}

@define foo(){
	@local ns, fn, tab, vec, i;

 	ns = @names c32le {
 		typedef struct foo foo_t;
		enum et {
			a = 1,
			b = 2,
			c = 3,
		};
 		struct abc { int x; @0x4; };
 		struct foo {
 			@0x00 int x;
 			@0x04 int y;
 			@0x08 int z;
 			@0x0c int *xp;
 			@0x10 int (*foo)();
 			@0x14 int (*bar)(void);
 			@0x18 int (*baz)(int p1);
 			@0x20 int (*baz)(int p1, struct foo *p2);
 			@0x24 char *a[10];
			@0x30 struct blah {
				@0x0	int x;
				@@35	int y : 4;
				@0x8;
			} blahvar;
			@0x34 foo_t *ptrtofoo;
 			@0x28;
 		};
 		struct bar {
 			@0x0 int x, y;
			@0x8;
 		};
 		struct foo a;
		@0x100 struct t2 { int x; @0x4; } x;
		@0x100 struct t2 { int x, y; @0x8; } x;
		@0x100 struct t2 { int z; @0x4; } x;
 	};

	fn = nsenumtype(ns);
	vec = tabvals(fn(ns));
	for(i = 0; i < veclen(vec); i++)
		printtype(vecref(vec, i));
};

//usage: objectStr(x) returns a string representation of the 
//object pointed to by x (including its values in memory).
@define objectStr(argv ...)
{
	@local p, t, indent;
	if (length(argv) == 0) fault();
	p = argv[0]; 
	//indent is the amount to indent all except the first line
	if (length(argv) > 1) indent = argv[1];
	else indent = "";
	t = @typeof(p); 
	if (isptr(t)) {
		@local t2;
		t2 = subtype(t);
		if (!ismapped(p)) return "UNMAPPED";
		else if (issu(t2)) {
			@local flds, i, nxt_indent, ret;
			@local adr;
			if (strlen(indent)>70 ) return sprintfa("...",p);
			flds = fields(t2);
			if (isstruct(t2)) ret = "struct ";
			else if (isunion(t2)) ret = "union ";
			else ret = "aggregate ";
			ret += sprintfa("%s at 0x%x {", suetag(t2), p);
			for(i=0; i<length(flds); ++i)
			{
				@local buf;
				buf = sprintfa("\n%s%t %s = ",
					indent + "   ",
					fieldtype(flds[i]),
					fieldid(flds[i]));
				nxt_indent = "";
				foreach(@lambda(x) {
					nxt_indent += " "; 
				}, mkvec(strlen(buf)-1));
				ret += buf + objectStr(
					{mkctype_ptr(fieldtype(flds[i]),
						nsptr(domof(p).ns))}
					  (({nsptr(domof(p))}p) +
					   fieldoff(flds[i])),
						nxt_indent);
			}
			ret += sprintfa("\n%s};",indent);
			return ret;
		} else if (isbase(t2) && baseid(t2)=="char") {
			return stringof(p);
		} else if (isbase(t2)) {
			if (baseid(t2)=="int") 
			{
				return sprintfa("%d (0x%x)",*p,p);
			} else if (baseid(t2)=="unsigned int") 
				return sprintfa("%u",*p);
			else if (baseid(t2)=="char")
				return sprintfa("%c",*p);
			else if (baseid(t2)=="long")
				return sprintfa("%l",*p);
			else return sprintfa("%d",*p);
		} else if (isenumconst(t2)) {
			return sprintfa("%d",*p);
		} else if (isfunc(t2)) {
			return sprintfa("<function:0x%x>",p);
		} else if (isarray(t2)) {
			@local len, i, nxt_indent, ret;
			nxt_indent = indent+" ";
			len = arraynelm(t2);
			ret = "[";
			for(i=0; i<len; ++i) {
				if (i != 0) ret += ",\n"+nxt_indent;
				ret += objectStr((*p)[i],nxt_indent);
			}
			ret += "]";
			return ret;
		} else if (isptr(t2)) {
			return sprintfa("0x%x",*p);
		}
		return "UNKNOWN TYPE";
	} else {
		return sprintfa("%d",p);
	}
}

//foo();
