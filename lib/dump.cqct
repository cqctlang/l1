
@global dump_defined;

/**
dump.cqct provides code for printing out namespaces and the values associated 
with typed pointers. 
*/

@include <xsas.cqct>

if (dump_defined == nil)
{
@global printtype, dumpns, objectstr, bintohex, hextobin, hexdump;

dump_defined = 1;

/**
Prints the type t in a way parsable in a .names file.
*/
@define printtype(t){
	@local i, fld, flds, sz, off;

	if(issu(t)){
		printf("%s %s {\n", suekind(t), suetag(t));
		flds = fields(t);
		for(i = 0; i < length(flds); i++){
			@local ft,id;
			fld = flds[i];
			off = fieldoff(fld);
			ft = fieldtype(fld);
			id = fieldid(fld);
			if(isnil(off)){
				printf("\t");
				printf("\t%t;\n", fld);
			}else if(isbitfield(ft)){
				printf("\t@@(8*0x%x+0x%x)",
				       off, bitfieldpos(ft));
				printf("\t%t %s : %d;\n",
				       bitfieldcontainer(ft), id,
				       bitfieldwidth(ft));
			}else{
				printf("\t@0x%x", off);
				printf("\t%t;\n", fld);
			}
		}
		sz = susize(t);
		if(!isnil(sz))
			printf("\t@0x%x;\n", sz);
		printf("};\n");
	}else if(istypedef(t))
		printf("typedef %t %s;\n", typedeftype(t), typedefid(t));
	else if(isenum(t)){
		@local ens,en;
		printf("%s %s {\n", suekind(t), suetag(t));
		ens = enumconsts(t);
		for(i = 0; i < length(ens); i++){
			en = ens[i];
			printf("\t%s = %d,\n", en[0], en[1]);
		}
		printf("};\n");
	}else
		printf("%t;\n", t);
};

/**
print a namespace in .names file format.
*/
@define dumpns(dn){
	@local ns, vec,i;
	if(isdom(dn))
		ns = dn.ns;
	else
		ns = dn;
	
	vec = copy(tabvals(ns.enumtype()));
	sort(vec,@lambda(x,y) { 
		return strcmp(sprintfa("%t",x),sprintfa("%t",y));
	}); //possibly wasteful, but makes the output cleaner.
	for(i = 0; i < length(vec); i++) {
		if (isbase(vec[i])) continue;
		if (isptr(vec[i])) continue;
			printtype(vec[i]);
	}

	vec = copy(tabvals(ns.enumsym()));
	sort(vec,@lambda(x,y) { 
		return strcmp(sprintfa("%s",symid(x)),sprintfa("%s",symid(y)));
	}); //possibly wasteful, but makes the output cleaner.
	for(i = 0; i < length(vec); i++)
		if(!isenumconst(symtype(vec[i])))
			printf("%t;\n", vec[i]);
}

/**
* returns a string representation of the object pointed to by x (including 
* its values in memory).
* params: x is a pointer to an object
* returns: a string representation of x and its content
*/
@define objectstr(argv ...)
{
	@local p, t, indent;

	if (length(argv) == 0) fault();
	p = argv[0]; 
	//indent is the amount to indent all except the first line
	if (length(argv) > 1) indent = argv[1];
	else indent = "";
	t = @typeof(p); 
	if (isptr(t)) {
		@local t2;

		t2 = subtype(t);
		while(istypedef(t2))
			t2 = typedeftype(t2);

		if (isvoid(t2)) return "VOID";
		//check if it is an unspecified array before checking if it is mapped.
		if (isarray(t2) && arraynelm(t2) == nil)
			; //do nothing, no need to check if unspecified array is mapped
		else if (!ismapped(p)) return "UNMAPPED";

		if (issu(t2)) {
			@local flds, i, nxt_indent, ret;

			if (strlen(indent)>70 ) return sprintfa("...",p);
			flds = fields(t2);
			if (isstruct(t2)) ret = "struct ";
			else if (isunion(t2)) ret = "union ";
			else ret = "aggregate ";
			ret += sprintfa("%s at 0x%x {", suetag(t2), p);
			for(i=0; i<length(flds); ++i)
			{
				@local buf;

				buf = sprintfa("\n%s%t %s = ",
					indent + "   ",
					fieldtype(flds[i]),
					fieldid(flds[i]));
				nxt_indent = "";
				foreach(@lambda(x) {
					nxt_indent += " "; 
				}, mkvec(strlen(buf)-1));
				ret += buf + objectstr(
					{mkctype_ptr(fieldtype(flds[i]),
						nsptr(domof(p).ns))}
					(((void*)p) +
					   fieldoff(flds[i])),
						nxt_indent);
			}
			ret += sprintfa("\n%s};",indent);
			return ret;
		} else if (isbase(t2) && baseid(t2)=="char") {
			return stringof(p);
		} else if (isenum(t2)) {
			return sprintfa("%e (%d)",{t2}*p,*p);
		} else if (isbase(t2)) {
			if (baseid(t2)=="int") 
				return sprintfa("%d",*p);
			else if (baseid(t2)=="unsigned int") 
				return sprintfa("%u",*p);
			else if (baseid(t2)=="char")
				return sprintfa("%c",*p);
			else if (baseid(t2)=="long")
				return sprintfa("%d",*p);
			else return sprintfa("%a",*p);
		} else if (isenumconst(t2)) {
			return sprintfa("%d",*p);
		} else if (isfunc(t2)) {
			return sprintfa("<function:0x%x>",p);
		} else if (isarray(t2)) {
			@local len, i, nxt_indent, ret;

			nxt_indent = indent+" ";
			len = arraynelm(t2);
			if (len == nil) return sprintfa("[] // unknown size");
			ret = "[";
			for(i=0; i<len; ++i) {
				if (i != 0) ret += ",\n"+nxt_indent;
					ret += objectstr((*p)[i],nxt_indent);
			}
			ret += "]";
			return ret;
		} else if (isptr(t2)) {
			return sprintfa("0x%x",*p);
		}
		return sprintfa("UNKNOWN TYPE: %t", t2);
	} else {
		return sprintfa("%d",p);
	}
}

@defloc tohex(b)
{
	return "0123456789abcdef"[b];
}

@defloc tobin(x)
{
	if(x >= '0' && x <= '9')
		return x-'0';
	if(x >= 'A' && x <= 'F')
		return x-'A'+10;
	if(x >= 'a' && x <= 'f')
		return x-'a'+10;
	error("bad hex digit");
}

@define hextobin(s)
{
	@local i, n, m, t;
	t = m = mkxs();
	n = length(s);
	for(i = 0; i < n; i += 2)
		*t++ = (tobin(s[i])<<4)|tobin(s[i+1]);
	return getbytes(m, n/2);
}

@define bintohex(b)
{
	@local i, n, m, t;
	t = m = mkxs();
	n = length(b);
	for(i = 0; i < n; i++){
		*t++ = tohex(b[i]>>4);
		*t++ = tohex(b[i]&0xf);
	}
	return getbytes(m, t-m);
}


/*
8 chars offset, 16 bytes from b per row
*/
@define hexdump(b)
{
	@local i,j,l,ret,bin;
	l = length(b);
	ret = "";
	for(i=0; i < l; i+=16) {
		ret += sprintfa("%08x:",i);
		bin = "";
		for(j=0; j<16 && i+j<l; ++j) {
			if (j == 8) {
				ret += " ";
			}
			ret += sprintfa(" %02x",b[i+j]);
			if ( isprint(b[i+j]) && !iscntrl(b[i+j]) ) {
				bin += sprintfa("%c",b[i+j]);
			} else {
				bin += ".";
			}
		}
		if (j < 16) {
			for(; j<16; ++j) {
				if (j == 8) {
					ret += " ";
				}
				ret += "   ";
			}
		}
		ret += "  " + bin + "\n";
	}
	return ret;
}

}
