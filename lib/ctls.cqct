@include <sctlclt.cqct>

@global
	mkctlmux,
        ctllaunch,
	ctlattach,
	;

{

@record muxrec {
	/* user interface */
	run,

	/* ctl interface */
	bindctl,
	unbindctl,
	msgsync,  /* msgsync(op, body) */
	msgasync, /* msgasync(op, body, handler) */
};

@record ctlrec {
	/* user/ctl interface */
	id,

	/* ctl interface */
	handleevent,
};

@defloc mkmux(fd)
{
	@local ctls, taghandler, nexttag, freetags, aborted, verbose;

	verbose = 0;
	nexttag = 0;
	freetags = [ ];
	ctls = [:];
	taghandler = [:];

	@defloc bindctl(ctl)
	{
		if(ctls[ctl.id])
			error("ctl %d is already bound to mux", ctl.id);
		ctls[ctl.id] = ctl;
	}

	@defloc unbindctl(ctl)
	{
		if(ctls[ctl.id] == nil)
			error("ctl %d is not bound to mux", ctl.id);
		tabdelete(ctls, ctl.id);
	}

	@defloc freshtag()
	{
		if(isempty(freetags))
			return nexttag++;
		return pop(freetags);
	}

	@defloc reusetag(tag)
	{
		push(freetags, tag);
	}

	@defloc log(arg ...)
	{
		if(verbose){
			apply(printf, arg);
			printf("\n");
		}
	}

	@defloc cop(p)
	{
		return {@typeof(p)}getbytes(p);
	}

	@defloc xread(fd, sz)
	{
		@local p, e;
		p = read(fd, sz);
		if(p == nil){
			e = errno();
			if(e[0])
				error("ctlmux: recvmsg: %d %s", getpid(), e[1]);
			return nil;
		}
		return p;
	}

	@defloc recvmsg(fd)
	{
		@local p, sz, rep, dat;

		p = xread(fd, sizeof(litdom`uint64));
		if(p == nil)
			return [nil, 'closed];
		p = (uint64*)p;
		sz = *p++;
		p = xread(fd, sz);
		if(p == nil)
			error("ctlmux: remote sctl hung up");
		rep = (sctl`Rmsg*)p;
		dat = getbytes(rep+1, sz-sizeof(sctl`Rmsg));
		return [rep, dat];
	}

	@defloc sendmsg(fd, arg ...)
	{
		@local p, sz, e;
		p = arg[0];
		switch(length(arg)){
		case 1:
			sz = sizeof(*p);
			break;
		case 2:
			sz = arg[1];
			break;
		default:
			error("bad sendmsg");
		}
		if(verbose)
			printf("(send) %s\n", fmtmsg(p, sz));
		write(fd, cval2str((uint64)sz));
		e = errno();
		if(e[0] != 0)
			error("sctl sendmsg: %s", e[1]);
		write(fd, getbytes(p, sz));
		e = errno();
		if(e[0] != 0)
			error("sctl sendmsg: %s", e[1]);
	}

	@defloc runtil(pred)
	{
		@local rep, dat, tag, h;

		if(aborted)
			return;
		if(pred())
			return;
		if(noinflight() && noctls())
			error("ctlmux: runtil: nothing to do");

		[rep, dat] = recvmsg(fd);
		if(rep == nil)
			error("ctlmux: remote sctl hung up");

		if(rep->op == sctl`Aevent){
			aevent(rep, dat);
			return runtil(pred);
		}
		tag = rep->tag;
		h = taghandler[tag];
		tabdelete(taghandler, tag);
		reusetag(tag);
		if(h == nil)
			log("unhandled tag %d", tag);
		else
			h(rep, dat);
		runtil(pred);
	}

	@defloc noctls()
	{
		return length(ctls) == 0;
	}

	@defloc noinflight()
	{
		return length(taghandler) == 0;
	}


}
