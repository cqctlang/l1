// convenient syscall wrappers
// that offer semantics that closely
// resemble the low-level semantics
// available in C programs through
// libc and friends. 
{
@local _unameres;
@local __malloc;

@global unix;
@global linuxns;

_unameres = nil;

// this entire mechanism is a crock.
{
	@local u,r,a,o,w;

	u=uname();
	o=u[0];
	a=u[3];

	r=myrootns();
	w=sizeof(r`long);

	switch([o,a,w]) {
	case ["Linux","x86_64",8]:
		eval("@include <linux-x86_64.cqct>"); 
		break;
	case ["Linux","x86_64",4]:
	case ["Linux","i686",4]:
		eval("@include <linux-x86.cqct>"); 
		break;
	case ["Linux","armv7l",4]:
	case ["Linux","armv6l",4]:
		eval("@include <linux-arm.cqct>"); 
		break;
	case ["Darwin","x86_64",8]:
		eval("@include <darwin-x86_64.cqct>"); 
		break;
	case ["Darwin","x86_64",4]:
	default:
	// no direct syscalls for you
		fprintf(stderr,"Unsupported OS: %a\n",[o,a,w]);
	}

	@define __malloc(s) {
		s=malloc(s);
		if(s) {
			return {mkdom(r,asof(s))}s;
		} else {
			return s;
		}
	}

	_unameres = u;
};

@global sys_open;
@define sys_open(filename,oflag,rest ...) {
	@local m,r;

	m=__malloc(length(filename)+1);
	putbytes(m,filename);
	m[length(filename)]=0;

	if(oflag & unix`O_CREAT) {
		r=syscall(unix`open,m,oflag,rest[0]);
	} else {
		r=syscall(unix`open,m,oflag);
	}

	return r;
}

@global sys_close;
@define sys_close(fd) {
	syscall(unix`close,fd);
}

@global sys_read;
@define sys_read(fd,buf,len) {
	@local m,r,c;

	m=__malloc(len);
	r=syscall(unix`read,fd,m,len);
	if(r>0) {
		c=getbytes(m,r);
		putbytes(buf,c);
	}

	return r;
}

@global sys_write;
@define sys_write(fd,buf,len) {
	@local m,r;

	m=__malloc(len);

	if(isstring(buf)) {
		if(length(buf) > len) {
			putbytes(m,substr(buf,0,len));
		} else {
			putbytes(m,buf);
		}
	} else {
		memcpy(m,buf,len);
	}

	r=syscall(unix`write,fd,m,len);

	return r;
}

@global sys_lseek;
@define sys_lseek(fd,pos,whence) {
	@local r;

	r=syscall(unix`lseek,fd,pos,whence);

	return r;
}

@global sys_ioctl;
@define sys_ioctl(fd,req,data) {
	@local r;

	r=syscall(unix`ioctl,fd,req,data);

	return r;
}

@global sys_dup2;
@define sys_dup2(fd1,fd2) {

	return syscall(unix`dup2,fd1,fd2);
}

@global posix;
posix = @names myrootns() {
	enum Stat_modes {
		S_IFMT	= 00170000,
		S_IFSOCK	= 0140000,
		S_IFLNK	= 0120000,
		S_IFREG	= 0100000,
		S_IFBLK	= 0060000,
		S_IFDIR	= 0040000,
		S_IFCHR	= 0020000,
		S_IFIFO	= 0010000,
		S_ISUID	= 0004000,
		S_ISGID	= 0002000,
		S_ISVTX	= 0001000,
	};
};

//S_ISREG = @lambda(statbuf) {
//};

@global S_ISDIR;
@define S_ISDIR(statbuf) {
	return (statbuf->st_mode & posix`S_IFDIR) ? 1 : 0;
}

@global S_ISCHR;
@define S_ISCHR(statbuf) {
	return (statbuf->st_mode & posix`S_IFCHR) ? 1 : 0;
}

@global S_ISBLK;
@define S_ISBLK(statbuf) {
	return (statbuf->st_mode & posix`S_IFBLK) ? 1 : 0;
}

@global S_ISFIFO;
@define S_ISFIFO(statbuf) {
	return (statbuf->st_mode & posix`S_IFIFO) ? 1 : 0;
}

@global S_ISLNK;
@define S_ISLNK(statbuf) {
	return (statbuf->st_mode & posix`S_ISLNK) ? 1 : 0;
}

//S_ISSOC = @lambda(m) {
//};

{
@local _fstat;

if (unix.looksym('fstat64) != nil)
{
	_fstat = @lambda(fd,m) { syscall(unix`fstat64,fd,m); };
} else if (unix.looksym('fstat) != nil) {
	_fstat = @lambda(fd,m) { syscall(unix`fstat,fd,m); };
} else {
	_fstat = @lambda(a...) { error("No fstat system call found!"); };
}

@global sys_fstat;
@define sys_fstat(fd,statbuf) {
	@local m,r,l;

	l=sizeof(struct unix`stat);

	m=__malloc(l);
	if(0 > m)
		error("fstat: couldn't allocate stat buf");

	if(isstring(statbuf)) {
		if(length(statbuf) > l) {
			putbytes(m,substr(statbuf,0,l));
		} else {
			putbytes(m,statbuf);
		}
		//if sl < l it will be caught by the below putbytes
	} else {
		memcpy(m,statbuf,l);
	}

	r=_fstat(fd,m);

	m=(struct unix`stat *)m;

	if(!r) {
		putbytes(statbuf,getbytes(m,l));
	}

	return r;
}

}//end scope for _fstat

@global FD_ALLOC;
@define FD_ALLOC() {
	return (unsigned char *)__malloc(128);
}

@global FD_ISSET;
@define FD_ISSET(fd,set) {
	@local bit,byte;
	byte=(fd)>>3;
	bit=1<<(fd - (byte*8));
	if(set[byte]&bit) {
		return 1;
	} else {
		return 0;
	}
}

@global FD_SET;
@define FD_SET(fd,set) {
	@local bit,byte;
	byte=(fd)>>3;
	bit=1<<(fd - (byte*8));
	set[byte]|=bit;
}

@global sys_pselect;
@global sys_select;
@global selnr;
selnr=nil;
if(looksym(unix,'select)) {
	selnr=unix`select;
} else if(looksym(unix,'_newselect)) {
	selnr=unix`_newselect;
}
if(selnr) {
@define sys_pselect(n,rfds,wfds,xfds,timeout,sigmask) {
	@local rfds_foo,wfds_foo,xfds_foo,timeout_foo,r,x,rr,rw,rx;
	@local maxbyte;

	rfds_foo=FD_ALLOC();
	wfds_foo=FD_ALLOC();
	xfds_foo=FD_ALLOC();

	maxbyte=n>>3;
	for(x=0;x<=maxbyte;x++) {
		rfds_foo[x]=0;
		wfds_foo[x]=0;
		xfds_foo[x]=0;
	}

	if(timeout != 0) {
		timeout_foo=(unsigned char *)__malloc(128);
		timeout_foo[0]=0;
		timeout_foo[1]=0;
		timeout_foo[2]=0;
		timeout_foo[3]=0;
		timeout_foo[4]=0;
		timeout_foo[5]=0;
		timeout_foo[6]=0;
		timeout_foo[7]=0;
	} else {
		timeout_foo=(unix`unsigned char *)0;
	}

	foreach(@lambda(v) {
		FD_SET(v,rfds_foo);
	},rfds);
	foreach(@lambda(v) {
		FD_SET(v,wfds_foo);
	},wfds);
	foreach(@lambda(v) {
		FD_SET(v,xfds_foo);
	},xfds);

	r=syscall(selnr,n,rfds_foo,wfds_foo,xfds_foo,timeout_foo);

	if(r==-1) {
		return [[],[],[]];
	}

	rr=[];
	foreach(@lambda(v) {
		if(FD_ISSET(v,rfds_foo)) {
			append(rr,v);
		}
	},rfds);
	rw=[];
	foreach(@lambda(v) {
		if(FD_ISSET(v,wfds_foo)) {
			append(rw,v);
		}
	},wfds);
	rx=[];
	foreach(@lambda(v) {
		if(FD_ISSET(v,xfds_foo)) {
			append(rx,v);
		}
	},xfds);

	return [rr,rw,rx];
}

@define sys_select(n,rfds,wfds,xfds,timeout) {
	return sys_pselect(n,rfds,wfds,xfds,timeout,0);
}
}

@global sys_unlink;
@define sys_unlink(filename) {
	@local m;

	m=__malloc(length(filename)+1);
	putbytes(m,filename);
	m[length(filename)]=0;

	return syscall(unix`unlink,m);
}

@global sys_mmap;
if(unix.looksym('mmap2)) {
	// some linuxes don't support old mmap anymore
	@define sys_mmap(addr,length,prot,flags,fd,offset) {
		return (linuxns`void *)syscall(unix`mmap2,addr,length,prot,
						flags,fd,offset>>12);
	}
} else {
	@define sys_mmap(addr,length,prot,flags,fd,offset) {
		return (unix`void *)syscall(unix`mmap,addr,length,prot,flags,
						fd,offset);
	}
}

@global sys_msync;
@define sys_msync(addr,size,flags) {

	return syscall(unix`msync,addr,size,flags);
}

@global sys_munmap;
@define sys_munmap(addr,length) {

	return syscall(unix`munmap,addr,length);
}

@global sys_socket;
@define sys_socket(domain,type,protocol) {

	return syscall(unix`socket,domain,type,protocol);
}

@global sys_connect;
@define sys_connect(fd,sockaddr,size) {
	@local sa;

	if(isnil(size)) {
		size=sizeof(*sockaddr);
	}
	sa=__malloc(size);
	if(!sa) return nil;

	putbytes(sa,getbytes(sockaddr,size));

	return syscall(unix`connect,fd,sa,size);
}

@global sys_bind;
@define sys_bind(fd,sockaddr,size) {
	@local sa;

	if(isnil(size)) {
		size=sizeof(*sockaddr);
	}
	sa=__malloc(size);
	if(!sa) return nil;

	putbytes(sa,getbytes(sockaddr,size));

	return syscall(unix`bind,fd,sa,size);
}

@global sys_listen;
@define sys_listen(fd,backlog) {

	return syscall(unix`listen,fd,backlog);
};

@global sys_accept;
@define sys_accept(fd,sockaddr,size) {
	@local sa,ss;

	if(isnil(size)) {
		size=sizeof(*sockaddr);
	} else {
		size=*size;
	}
	sa=__malloc(size);
	if(!sa) return nil;

	putbytes(sa,getbytes(sockaddr,size));

	ss=__malloc(sizeof(linuxns`int));
	if(!ss) return nil;

	ss=(linuxns`int *)ss;

	*ss=size;

	return syscall(unix`accept,fd,sa,ss);
}

@global sys_getsockname;
@define sys_getsockname(fd,sa,len) {
	return syscall(unix`getsockname,fd,sa,len);
}

@global sys_setsockopt;
@define sys_setsockopt(socket,level,option_name,option_value,option_len) {

	return syscall(unix`setsockopt,socket,level,option_name,option_value,option_len);
}

/*
 * Process calls
 */

@global sys_exit;
@define sys_exit(status) {

	syscall(unix`exit,status);
}

@global sys_fork;

if(_unameres[0] == "Darwin") {

@define sys_fork() {
	@local r,p;

	r=syscall(unix`fork);
	p=sys_getpid();

	if(0 > r) {
		return r;
	} else if(r == p) {
		// this is the child.
		return 0;
	} else {
		return r;
	}
}

} else {

@define sys_fork() {

	syscall(unix`fork);
}

}

@global sys_wait4;
if(looksym(unix,'wait4)) {
@define sys_wait4(pid,status,options,rusage) {

	syscall(unix`wait4,pid,status,options,rusage);
};
}

@global sys_getpid;
@define sys_getpid() {

	syscall(unix`getpid);
}

@global sys_getppid;
@define sys_getppid() {

	syscall(unix`getppid);
}

@global sys_getpgid;
@define sys_getpgid(pid) {

	syscall(unix`getpgid,pid);
}

@global sys_setpgid;
@define sys_setpgid(pid,pgid) {

	syscall(unix`setpgid,pid,pgid);
}

@global sys_setsid;
@define sys_setsid() {

	syscall(unix`setsid);
}

@global sys_sleep;
@define sys_sleep(secs) {
	@local r,m,m2;

	m=__malloc(sizeof(struct unix`timespec));
	m=(struct unix`timespec *)m;
	m->tv_sec=secs;
	m->tv_nsec=0;
	m2=__malloc(sizeof(struct unix`timespec));
	m2=(struct unix`timespec *)m2;

	r=syscall(unix`nanosleep,m,m2);

	if(!r) {
		return r;
	} else {
		return m2->tv_sec;
	}
}

@global sys_reboot;
@define sys_reboot(magic, magic2, cmd, arg) {
	@local r;

	r=syscall(unix`reboot, magic, magic2, cmd, arg);

	return r;
}

@global sys_sched_getaffinity;
@define sys_sched_getaffinity(pid, cpusetsize, mask) {
	@local m,r;

	m=(unsigned char *)__malloc(cpusetsize);
	memset(m,0,cpusetsize);

	r=syscall(unix`sched_getaffinity,pid,cpusetsize,m);

	return r;
}

@global sys_sched_setaffinity;
@define sys_sched_setaffinity(pid, cpusetsize, mask) {
	@local m,r;

	if(isstring(mask) && length(mask) <= cpusetsize) {
		m=(unsigned char *)__malloc(cpusetsize);
		putbytes(m,mask);
	} else {
		error("BAD MASK!\n");
	}

	r=syscall(unix`sched_setaffinity,pid,cpusetsize,m);

	return r;
}

// MPOL_DEFAULT, MPOL_BIND, MPOL_INTERLEAVE or MPOL_PREFERRED. All modes except MPOL_DEFAULT

@global sys_getmempolicy;
@define sys_getmempolicy(mode, nodemask, maxnode,addr,flags) {
	@local m,r;

	if(isstring(nodemask)) {
		m=(unsigned char *)__malloc(length(nodemask));
		putbytes(m,nodemask);
	} else {
		error("nodemask should be a string");
	}

	r=syscall(unix`get_mempolicy,mode, m, maxnode, addr, flags);

	return r;
}

@global sys_setmempolicy;
@define sys_setmempolicy(mode, nodemask, maxnode) {
	@local m,r;

	if(isstring(nodemask)) {
		m=(unsigned char *)__malloc(length(nodemask));
		putbytes(m,nodemask);
	} else {
		error("nodemask should be a string");
	}

	r=syscall(unix`get_setpolicy,mode, m, maxnode);

	return r;
}

@global sys_getuid;
@define sys_getuid() {

	return syscall(unix`getuid);
}

@global sys_geteuid;
@define sys_geteuid() {

	return syscall(unix`geteuid);
}

@global sys_setuid;
@define sys_setuid(uid) {

	return syscall(unix`setuid,uid);
}

@global sys_getgid;
@define sys_getgid() {

	return syscall(unix`getgid);
}

@global sys_getegid;
@define sys_getegid() {

	return syscall(unix`getegid);
}

@global sys_setgid;
@define sys_setgid(gid) {

	return syscall(unix`setgid,gid);
}

@global sys_kill;
@define sys_kill(pid, sig) {

	return syscall(unix`kill, pid, sig);
}

@global sys_execve;
@define sys_execve(filename,argv,envp) {
	@local f,fl,a,e;

	if(iscvalue(filename) && isptr(@typeof(filename))) {
		@local fl;

		fl=strlen(filename);
		f=(unsigned char *)__malloc(fl + 1);
		putbytes(f,getbytes(filename,fl));
		f[fl]=0;
	} else if(isstring(filename)) {
		fl=length(filename);
		f=(unsigned char *)__malloc(fl+1);
		putbytes(f,filename);
		f[fl]=0;
	} else {
		error("filename must be a string or a cptr");
	}

	[a,e] = map(@lambda(ary) {
		@local ret,i,len,strs;

		len = sizeof(char*) * (length(ary)+1);
		foreach(@lambda(v) { 
			if (isstring(v)) len += length(v)+1; 
			else len += sizeof(v);
		},ary);
		ret=(char**)__malloc(len);
		strs = (char*)&ret[length(ary)+1];
		for(i=0; i<length(ary); ++i) {
			ret[i] = strs;
			if (isstring(ary[i])) {
				putbytes(strs,ary[i]);
				strs+=length(ary[i]);
				*strs = 0;
				strs += 1;
			} else {
				@local v;
				v = ary[i];
				*{mkctype_ptr(@typeof(v),nsptr(nsof(v)))}strs = v;
				strs += sizeof(ary[i]);
			}
		}
		ret[i] = 0; //final null pointer (i == length(ary))
		return ret;
	}, [argv,envp]);

	return syscall(unix`execve,f,a,e);
}

@global sys_readlink;
@define sys_readlink(path, buf, bufsize) {
	@local pathlen, thepath, thebuf, ret;

	pathlen = strlen(path);
	thepath = (char*)__malloc(pathlen+1);
	memcpy(thepath, (char*)path, pathlen);
	thepath[pathlen] = 0;

	thebuf = (char*)__malloc(bufsize);
	memcpy(thebuf, (char*)buf, bufsize);

	ret = syscall(unix`readlink, thepath, thebuf, bufsize);

	memcpy((char*)buf, thebuf, bufsize);

	return ret;
}

};


// vim: ts=8 noet sw=8
