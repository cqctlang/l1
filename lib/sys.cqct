
@global unix;
@global linuxns;

_unameres = nil;

{
  @local u,r,a,o,w;

  u=uname();
  o=u[0];
  a=u[3];

  r=myrootns();
  w=sizeof(r`long);

  switch([o,a,w]) {
    case ["Linux","x86_64",8]:
      eval("@include <linux-x86_64.cqct>"); 
      break;
    case ["Darwin","x86_64",8]:
      eval("@include <darwin-x86_64.cqct>"); 
      break;
    case ["Linux","x86_64",4]:
    case ["Darwin","x86_64",4]:
    default:
      // no direct syscalls for you
      printf("Unsupported OS: %a\n",[o,a,w]);
  }

  _unameres = u;

};

sys_open = @lambda(filename,oflag,rest ...) {
  @local m,r;

  m=malloc(length(filename)+1);
  putbytes(m,filename);
  m[length(filename)]=0;

  if(oflag & unix`O_CREAT) {
    r=syscall(linuxns`open,m,oflag,rest[0]);
  } else {
    r=syscall(linuxns`open,m,oflag);
  }
  return r;
};

sys_close = @lambda(fd) {
  syscall(linuxns`close,fd);
};

sys_read = @lambda(fd,buf,len) {
  @local m,r,c;

  m=malloc(len);
  r=syscall(linuxns`read,fd,m,len);
  if(r>0) {
    c=getbytes(m,r);
    putbytes(buf,c);
  }
  return r;
};

sys_write = @lambda(fd,buf,len) {
  @local m,r;

  m=malloc(len);

  if(isstring(buf)) {
    if(length(buf) > len) {
      putbytes(m,substr(buf,0,len));
    } else {
      putbytes(m,buf);
    }
  } else {
    memcpy(m,buf,len);
  }

  r=syscall(linuxns`write,fd,m,len);
  return r;
};

sys_ioctl = @lambda(fd,req,data) {
  @local r;

  r=syscall(linuxns`ioctl,fd,req,data);

  return r;

};

sys_fstat = @lambda(fd,statbuf) {
  @local m,r,l;

  l=sizeof(struct unix`stat);

  m=malloc(l);
  if(0 > m)
    error("fstat: couldn't allocate stat buf");

  if(isstring(statbuf)) {
    if(length(statbuf) > l) {
      putbytes(m,substr(statbuf,0,l));
    } else {
      putbytes(m,statbuf);
    }
  } else {
    memcpy(m,statbuf,l);
  }

  r=syscall(linuxns`fstat,fd,m);

  m=(struct unix`stat *)m;

  if(!r) {
    putbytes(statbuf,getbytes(m,sizeof(*m)));
  }

  return r;
};

FD_ALLOC=@lambda() {
  return (unsigned char *)malloc(128);
};

FD_ISSET=@lambda(fd,set) {
  @local bit,byte;
  byte=(fd+1)>>3;
  bit=1<<(fd - (byte*8));
  if(set[byte]&bit) {
    return 1;
  } else {
    return 0;
  }
};

FD_SET=@lambda(fd,set) {
    @local bit,byte;
    byte=(fd+1)>>3;
    bit=1<<(fd - (byte*8));
    set[byte]|=bit;
};

sys_pselect = @lambda(n,rfds,wfds,xfds,timeout,sigmask) {
  @local rfds_foo,wfds_foo,xfds_foo,timeout_foo,r,x,rr,rw,rx;
  @local maxbyte;

  rfds_foo=FD_ALLOC();
  wfds_foo=FD_ALLOC();
  xfds_foo=FD_ALLOC();

  maxbyte=n>>3;
  for(x=0;x<=maxbyte;x++) {
    rfds_foo[x]=0;
    wfds_foo[x]=0;
    xfds_foo[x]=0;
  }

  if(timeout != 0) {
    timeout_foo=(unsigned char *)malloc(128);
    timeout_foo[0]=0;
    timeout_foo[1]=0;
    timeout_foo[2]=0;
    timeout_foo[3]=0;
    timeout_foo[4]=0;
    timeout_foo[5]=0;
    timeout_foo[6]=0;
    timeout_foo[7]=0;
  } else {
    timeout_foo=(unix`unsigned char *)0;
  }

  foreach(@lambda(v) {
    FD_SET(v,rfds_foo);
  },rfds);
  foreach(@lambda(v) {
    FD_SET(v,wfds_foo);
  },wfds);
  foreach(@lambda(v) {
    FD_SET(v,xfds_foo);
  },xfds);

  r=syscall(linuxns`select,n,rfds_foo,wfds_foo,xfds_foo,timeout_foo);

  if(r==-1) {
    return [[],[],[]];
  }

  rr=[];
  foreach(@lambda(v) {
    if(FD_ISSET(v,rfds_foo)) {
      append(rr,v);
    }
  },rfds);
  rw=[];
  foreach(@lambda(v) {
    if(FD_ISSET(v,wfds_foo)) {
      append(rw,v);
    }
  },wfds);
  rx=[];
  foreach(@lambda(v) {
    if(FD_ISSET(v,xfds_foo)) {
      append(rx,v);
    }
  },xfds);

  return [rr,rw,rx];
};

sys_select = @lambda(n,rfds,wfds,xfds,timeout) {
  return sys_pselect(n,rfds,wfds,xfds,timeout,0);
};

sys_unlink = @lambda(filename) {
  @local m;

  m=malloc(length(filename)+1);
  putbytes(m,filename);
  m[length(filename)]=0;

  return syscall(linuxns`unlink,m);
};

@global sys_mmap;
if(linuxns.looksym('mmap2)) {
  sys_mmap = @lambda(addr,length,prot,flags,fd,offset) {                                
    return (linuxns`void *)syscall(linuxns`mmap2,addr,length,prot,flags,fd,offset>>12);                
  };
} else {
  sys_mmap = @lambda(addr,length,prot,flags,fd,offset) {                                
    return (linuxns`void *)syscall(linuxns`mmap,addr,length,prot,flags,fd,offset);                
  };

}

sys_msync=@lambda(addr,size,flags) {

  return syscall(linuxns`msync,addr,size,flags);

};

sys_munmap=@lambda(addr,length) {

  return syscall(linuxns`munmap,addr,length);

};

sys_socket = @lambda(domain,type,protocol) {

  return syscall(linuxns`socket,domain,type,protocol);

};

sys_connect = @lambda(fd,sockaddr,size) {
  @local sa;

  if(isnil(size)) {
    size=sizeof(*sockaddr);
  }
  sa=malloc(size);
  if(!sa) return nil;

  putbytes(sa,getbytes(sockaddr,size));

  return syscall(linuxns`connect,fd,sa,size);
};

sys_bind = @lambda(fd,sockaddr,size) {
  @local sa;

  if(isnil(size)) {
    size=sizeof(*sockaddr);
  }
  sa=malloc(size);
  if(!sa) return nil;

  putbytes(sa,getbytes(sockaddr,size));

  return syscall(linuxns`bind,fd,sa,size);
};

sys_listen = @lambda(fd,backlog) {

  return syscall(linuxns`listen,fd,backlog);
};

sys_accept = @lambda(fd,sockaddr,size) {
  @local sa,ss;

  if(isnil(size)) {
    size=sizeof(*sockaddr);
  } else {
    size=*size;
  }
  sa=malloc(size);
  if(!sa) return nil;

  putbytes(sa,getbytes(sockaddr,size));

  ss=malloc(sizeof(linuxns`int));
  if(!ss) return nil;

  ss=(linuxns`int *)ss;

  *ss=size;

  return syscall(linuxns`accept,fd,sa,ss);

};

/*
 * Process calls
 */

sys_exit = @lambda(status) {

  syscall(linuxns`exit,status);

};

@global sys_fork;

if(_unameres[0] == "Darwin") {

  sys_fork = @lambda() {
    @local r,p;

    r=syscall(linuxns`fork);
    p=sys_getpid();

    if(0 > r) {
      return r;
    } else if(r == p) {
      // this is the child.
      return 0;
    } else {
      return r;
    }

  };

} else {

  sys_fork = @lambda() {

    syscall(linuxns`fork);

  };

}

sys_getpid = @lambda() {

  syscall(linuxns`getpid);

};

sys_getppid = @lambda() {

  syscall(linuxns`getppid);

};

sys_getpgid = @lambda(pid) {

  syscall(linuxns`getpgid,pid);

};

sys_setpgid = @lambda(pid,pgid) {

  syscall(linuxns`setpgid,pid,pgid);

};

sys_sleep = @lambda(secs) {
  @local r,m,m2;

  m=malloc(sizeof(struct unix`timespec));
  m=(struct unix`timespec *)m;
  m->tv_sec=secs;
  m->tv_nsec=0;
  m2=malloc(sizeof(struct unix`timespec));
  m2=(struct unix`timespec *)m2;
  
  r=syscall(linuxns`nanosleep,m,m2);
  
  if(!r) {
    return r;
  } else {
    return m2->tv_sec;
  }

};

sys_reboot = @lambda(magic, magic2, cmd, arg) {
  @local r;

  r=syscall(linuxns`reboot, magic, magic2, cmd, arg);

  return r;
};


sys_sched_getaffinity = @lambda(pid, cpusetsize, mask) {
  @local m,r;

  m=(unsigned char *)malloc(cpusetsize);    
  memset(m,0,cpusetsize);

  r=syscall(linuxns`sched_getaffinity,pid,cpusetsize,m);

  return r;

};

sys_sched_setaffinity = @lambda(pid, cpusetsize, mask) {
  @local m,r;

  if(isstring(mask) && length(mask) <= cpusetsize) {
    m=(unsigned char *)malloc(cpusetsize);    
    putbytes(m,mask);
  } else {
    error("BAD MASK!\n");
  }

  r=syscall(linuxns`sched_setaffinity,pid,cpusetsize,m);

  return r;

};

// MPOL_DEFAULT, MPOL_BIND, MPOL_INTERLEAVE or MPOL_PREFERRED. All modes except MPOL_DEFAULT

sys_getmempolicy = @lambda(mode, nodemask, maxnode,addr,flags) {
  @local m,r;

  if(isstring(nodemask)) {
    m=(unsigned char *)malloc(length(nodemask));
    putbytes(m,nodemask);
  } else {
    error("nodemask should be a string");
  }

  r=syscall(linuxns`get_mempolicy,mode, m, maxnode, addr, flags);

  return r;

};


sys_setmempolicy = @lambda(mode, nodemask, maxnode) {
  @local m,r;

  if(isstring(nodemask)) {
    m=(unsigned char *)malloc(length(nodemask));
    putbytes(m,nodemask);
  } else {
    error("nodemask should be a string");
  }

  r=syscall(linuxns`get_setpolicy,mode, m, maxnode);

  return r;
};

@define execve(filename,argv,envp) {
  @local f,a,e;

  //filename
  f=malloc(length(filename)+1);
  putbytes(f,filename);
  f[length(filename)]=0;

  //argv[0] is the filename
  push(argv,filename);

  [a,e] = map(@lambda(ary) {
    @local ret,i,len,strs;
    len = sizeof(char*) * (length(ary)+1);
    foreach(@lambda(v) { len += length(v)+1; },ary);
    ret=(char**)malloc(len);
    strs = (char*)&ret[length(ary)+1];
    for(i=0; i<length(ary); ++i) {
      ret[i] = strs;
      putbytes(strs,ary[i]);
      strs+=length(ary[i]);
      *strs = 0;
      strs += 1;
    }
    ret[i] = 0; //final null pointer (i == length(ary))
    return ret;
  }, [argv,envp]);

  return syscall(linuxns`execve,f,a,e);
};


